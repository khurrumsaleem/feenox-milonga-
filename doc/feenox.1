.\" Automatically generated by Pandoc 2.11.2
.\"
.TH "FEENOX" "1" "2021-03-31" "FeenoX" "FeenoX User Manual"
.hy
.SH NAME
.PP
FeenoX - a free no-fee no-X uniX-like finite-element(ish) computational
engineering tool
.SH SYNOPSIS
.PP
The basic usage is to execute the \f[B]feenox\f[R] binary passing a path
to an input file that defines the problem, along with other options and
command-line replacement arguments which are explained below:
.PP
\f[B]feenox\f[R] [\f[I]options\f[R] \&...] \f[I]input-file\f[R]
[\f[I]optional_commandline_replacement_arguments\f[R] \&...]
.PP
For large problems that do not fit in a single computer, a parallel run
using \f[B]mpirun\f[R]\f[C](1)\f[R] will be needed:
.PP
\f[B]mpirun\f[R] \f[B]-n\f[R] \f[I]number_of_threads\f[R]
\f[B]feenox\f[R] [\f[I]options\f[R] \&...] \f[I]input-file\f[R]
[\f[I]optional_commandline_replacement_arguments\f[R] \&...]
.PP
Besides executing the \f[B]feenox\f[R] binary, there is an API that
allows to use FeenoX from Python or Julia.
.SH DESCRIPTION
.PP
FeenoX is a computational tool that can solve engineering problems which
are usually casted as differential-algebraic equations (DAEs) or partial
differential equations (PDEs).
In particular, it can solve
.IP \[bu] 2
dynamical systems defined by a set of user-provided DAEs (such as plant
control dynamics for example)
.IP \[bu] 2
mechanical elasticity
.IP \[bu] 2
heat conduction
.IP \[bu] 2
structural modal analysis
.IP \[bu] 2
neutron diffusion
.PP
FeenoX reads a plain-text input file which contains the problem
definition and writes 100%-user defined results in ASCII (through
\f[I]PRINT\f[R] or other user-defined output instructions within the
input file).
For PDE problems, it needs a reference to at least one
\f[B]gmsh\f[R]\f[C](1)\f[R] mesh file for the discretization of the
domain.
It can write post-processing views in either \f[I].msh\f[R] or
\f[I].vtk\f[R] formats.
.PP
Keep in mind that FeenoX is just a back end reading a set of input files
and writing a set of output files following the design philosophy of
UNIX (separation, composition, representation, economy, extensibility,
etc).
Think of it as a transfer function between input files and output files:
.IP
.nf
\f[C]
                  +----------------+
                  |                |
input files ----->|     FeenoX     |-----> output files
                  |                |
                  +----------------+ 
\f[R]
.fi
.PP
Following the UNIX programming philosophy, there are no graphical
interfaces attached to the FeenoX core, although a wide variety of pre
and post-processors can be used with FeenoX.
See for example <https://www.caeplex.com> for a web-based interface.
.SH OPTIONS
.TP
\f[B]\f[CB]-h\f[B]\f[R], \f[B]\f[CB]--help\f[B]\f[R]
display usage and commmand-line help and exit
.TP
\f[B]\f[CB]-v\f[B]\f[R], \f[B]\f[CB]--version\f[B]\f[R]
display brief version information and exit
.TP
\f[B]\f[CB]-V\f[B]\f[R], \f[B]\f[CB]--versions\f[B]\f[R]
display detailed version information
.TP
\f[B]\f[CB]-s\f[B]\f[R], \f[B]\f[CB]--sumarize\f[B]\f[R]
list all symbols in the input file and exit
.PP
Instructions will be read from standard input if \[lq]-\[rq] is passed
as inputfile, i.e.
.IP
.nf
\f[C]
$ echo \[dq]PRINT 2+2\[dq] | feenox -
4
\f[R]
.fi
.SH EXAMPLES
.SS The Lorenz system
.SS Tensile test minimum working example
.PP
The following is a MWE input file for FeenoX that reads a Gmsh-generated
\f[I].msh\f[R] file, solves a linear elastic problem and writes the
results in a \f[I].vtk\f[R] file which can be post-processed by
\f[B]paraview\f[R]\f[C](1)\f[R]:
.IP
.nf
\f[C]
\f[R]
.fi
.PP
The \f[I].geo\f[R] file that generates the mesh with Gmsh and the CAD
file in \f[I].step\f[R] format can be found in the \f[I]examples\f[R]
directory.
.SS Extended annotated example
.PP
The example above can be extended to give more information as the
following annotated input shows:
.IP
.nf
\f[C]
\f[R]
.fi
.SH EXIT STATUS
.SH ENVIRONMENT
.SH FILES
.SH CONFORMING TO
.SH INPUT-FILE KEYWORDS
.SS ABORT
.PP
Catastrophically abort the execution and quit FeenoX.
.PP
\f[C]ABORT\f[R]
.PP
Whenever the instruction \f[C]ABORT\f[R] is executed, FeenoX quits with
a non-zero error leve.
It does not close files nor unlock shared memory objects.
The objective of this instruction is to either debug complex input files
by using only parts of them or to conditionally abort the execution
using \f[C]IF\f[R] clauses.
.SS ALIAS
.PP
Define a scalar alias of an already-defined indentifier.
.PP
\f[C]ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }\f[R]
.PP
The existing object can be a variable, a vector element or a matrix
element.
In the first case, the name of the variable should be given as the
existing object.
In the second case, to alias the second element of vector \f[C]v\f[R] to
the new name \f[C]new\f[R], \f[C]v(2)\f[R] should be given as the
existing object.
In the third case, to alias second element (2,3) of matrix \f[C]M\f[R]
to the new name \f[C]new\f[R], \f[C]M(2,3)\f[R] should be given as the
existing object.
.SS BC
.PP
Define a boundary condition to be applied to faces, edges and/or
vertices.
.PP
\f[C]BC <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1>  [ PHYSICAL_GROUP <name_2> [ ... ] ] ]\f[R]
.PP
If the name of the boundary condition matches a physical group in the
mesh, it is automatically linked to that physical group.
If there are many meshes, the mesh this keyword refers to has to be
given with \f[C]MESH\f[R].
If the boundary condition applies to more than one physical group in the
mesh, they can be added using as many \f[C]PHYSICAL_GROUP\f[R] keywords
as needed.
.SS CLOSE
.PP
Explicitly close a file after input/output.
.PP
\f[C]CLOSE <name>\f[R]
.PP
The given \f[C]<name>\f[R] can be either a fixed-string path or an
already-defined \f[C]FILE\f[R].
.SS DEFAULT_ARGUMENT_VALUE
.PP
Give a default value for an optional commandline argument.
.PP
\f[C]DEFAULT_ARGUMENT_VALUE <constant> <string>\f[R]
.PP
If a \f[C]$n\f[R] construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional.
The \f[C]<constant>\f[R] should be 1, 2, 3, etc.
and \f[C]<string>\f[R] will be expanded character-by-character where the
\f[C]$n\f[R] construction is.
Whether the resulting expression is to be interpreted as a string or as
a numerical expression will depend on the context.
.SS FILE
.PP
Define a file with a particularly formatted name to be used either as
input or as output.
.PP
\f[C]< FILE | OUTPUT_FILE | INPUT_FILE > <name> PATH <format> expr_1 expr_2 ... expr_n [ INPUT | OUTPUT | MODE <fopen_mode> ]\f[R]
.PP
For reading or writing into files with a fixed path, this instruction is
usually not needed as the \f[C]FILE\f[R] keyword of other instructions
(such as \f[C]PRINT\f[R] or \f[C]MESH\f[R]) can take a fixed-string path
as an argument.
However, if the file name changes as the execution progresses (say
because one file for each step is needed), then an explicit
\f[C]FILE\f[R] needs to be defined with this keyword and later
referenced by the given name.
The path should be given as a \f[C]printf\f[R]-like format string
followed by the expressions which shuold be evaluated in order to obtain
the actual file path.
The expressions will always be floating-point expressions, but the
particular integer specifier \f[C]%d\f[R] is allowed and internally
transformed to \f[C]%.0f\f[R].
The file can be explicitly defined and \f[C]INPUT\f[R], \f[C]OUTPUT\f[R]
or a certain \f[C]fopen()\f[R] mode can be given (i.e.\ \[lq]a\[rq]).
If not explicitly given, the nature of the file will be taken from
context, i.e.\ \f[C]FILE\f[R]s in \f[C]PRINT\f[R] will be
\f[C]OUTPUT\f[R] and \f[C]FILE\f[R]s in \f[C]FUNCTION\f[R] will be
\f[C]INPUT\f[R].
This keyword justs defines the \f[C]FILE\f[R], it does not open it.
The file will be actually openened (and eventually closed)
automatically.
In the rare case where the automated opening and closing does not fit
the expected workflow, the file can be explicitly opened or closed with
the instructions \f[C]FILE_OPEN\f[R] and \f[C]FILE_CLOSE\f[R].
.SS FIT
.PP
Fit a function of one or more arguments to a set of pointwise-defined
data.
.PP
\f[C]FIT <function_to_be_fitted>  TO <function_with_data> VIA <var_1> <var_2> ... <var_n>\[at] [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]\[at] [ RANGE_MIN <expr_1> <expr_2> ... <expr_j> ]\[at] [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ]\[at] [ DELTAEPSREL <expr> ] [ DELTAEPSABS <expr> ] [ MAX_ITER <expr> ]\[at] [ VERBOSE ] [ RERUN | DO_NOT_RERUN ]\[at]\f[R]
.PP
The function with the data has to be point-wise defined (i.e.\ a
\f[C]FUNCTION\f[R] read from a file with inline \f[C]DATA\f[R]).
The function to be fitted has to be parametrized with at least one of
the variables provided after the \f[C]VIA\f[R] keyword.
Only the names of the functions have to be given, not the arguments.
Both functions have to have the same number of arguments.
The initial guess of the solution is given by the initial value of the
variables listed in the \f[C]VIA\f[R] keyword.
Analytical expressions for the gradient of the function to be fitted
with respect to the parameters to be fitted can be optionally given with
the \f[C]GRADIENT\f[R] keyword.
If none is provided, the gradient will be computed numerically using
finite differences.
A range over which the residuals are to be minimized can be given with
\f[C]RANGE_MIN\f[R] and \f[C]RANGE_MAX\f[R].
The expressions give the range of the arguments of the functions, not of
the parameters.
For multidimensional fits, the range is an hypercube.
If no range is given, all the definition points of the function with the
data are used for the fit.
Convergence can be controlled by giving the relative and absolute
tolreances with \f[C]DELTAEPSREL\f[R] (default
\f[C]DEFAULT_NLIN_FIT_EPSREL\f[R]) and \f[C]DELTAEPSABS\f[R] (default
\f[C]DEFAULT_NLIN_FIT_EPSABS\f[R]), and with the maximum number of
iterations \f[C]MAX_ITER\f[R] (default DEFAULT_NLIN_FIT_MAX_ITER).
If the optional keyword \f[C]VERBOSE\f[R] is given, some data of the
intermediate steps is written in the standard output.
The combination of arguments that minimize the function are computed and
stored in the variables.
So if \f[C]f(x,y)\f[R] is to be minimized, after a \f[C]MINIMIZE f\f[R]
both \f[C]x\f[R] and \f[C]y\f[R] would have the appropriate values.
The details of the method used can be found in GSL\[cq]s
documentation (https://www.gnu.org/software/gsl/doc/html/multimin.html).
Some of them use derivatives and some of them do not.
Default method is \f[C]DEFAULT_MINIMIZER_METHOD\f[R], which does not
need derivatives.
.SS FUNCTION
.PP
Define a function of one or more variables.
.PP
\f[C]FUNCTION <function_name>(<var_1>[,var2,...,var_n]) { [ = <expr> | FILE_PATH <file_path> | ROUTINE <name> | | MESH <name> { DATA <new_vector_name> | VECTOR <existing_vector_name> } { NODES | CELLS } | [ VECTOR_DATA <vector_1> <vector_2> ... <vector_n> <vector_n+1> ] } [COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | nearest | shepard | shepard_kd | bilinear } ] [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ] [ SIZES <expr_1> <expr_2> ... <expr_n> ] [ X_INCREASES_FIRST <expr> ] [ DATA <num_1> <num_2> ... <num_N> ]\f[R]
.PP
The number of variables \f[I]n\f[R] is given by the number of arguments
given between parenthesis after the function name.
The arguments are defined as new variables if they had not been already
defined explictly as scalar variables.
If the function is given as an algebraic expression, the short-hand
operator \f[C]:=\f[R] can be used.
That is to say, \f[C]FUNCTION f(x) = x\[ha]2\f[R] is equivalent to
\f[C]f(x) := x\[ha]2\f[R].
If a \f[C]FILE_PATH\f[R] is given, an ASCII file containing at least
\f[I]n\f[R]\[u2005]+\[u2005]1 columns is expected.
By default, the first \f[I]n\f[R] columns are the values of the
arguments and the last column is the value of the function at those
points.
The order of the columns can be changed with the keyword
\f[C]COLUMNS\f[R], which expects \f[I]n\f[R]\[u2005]+\[u2005]1
expressions corresponding to the column numbers.
A function of type \f[C]ROUTINE\f[R] calls an already-defined
user-provided routine using the \f[C]CALL\f[R] keyword and passes the
values of the variables in each required evaluation as a
\f[C]double *\f[R] argument.
If \f[C]MESH\f[R] is given, the definition points are the nodes or the
cells of the mesh.
The function arguments should be (\f[I]x\f[R]),
(\f[I]x\f[R],\[u2006]\f[I]y\f[R]) or
(\f[I]x\f[R],\[u2006]\f[I]y\f[R],\[u2006]\f[I]z\f[R]) matching the
dimension the mesh.
If the keyword \f[C]DATA\f[R] is used, a new empty vector of the
appropriate size is defined.
The elements of this new vector can be assigned to the values of the
function at the \f[I]i\f[R]-th node or cell.
If the keyword \f[C]VECTOR\f[R] is used, the values of the dependent
variable are taken to be the values of the already-existing vector.
Note that this vector should have the size of the number of nodes or
cells the mesh has, depending on whether \f[C]NODES\f[R] or
\f[C]CELLS\f[R] is given.
If \f[C]VECTOR_DATA\f[R] is given, a set of
\f[I]n\f[R]\[u2005]+\[u2005]1 vectors of the same size is expected.
The first \f[I]n\f[R]\[u2005]+\[u2005]1 correspond to the arguments and
the last one is the function value.
Interpolation schemes can be given for either one or multi-dimensional
functions with \f[C]INTERPOLATION\f[R].
Available schemes for \f[I]n\f[R]\[u2004]=\[u2004]1 are:
.IP \[bu] 2
linear
.IP \[bu] 2
polynomial, the grade is equal to the number of data minus one
.IP \[bu] 2
spline, cubic (needs at least 3 points)
.IP \[bu] 2
spline_periodic
.IP \[bu] 2
akima (needs at least 5 points)
.IP \[bu] 2
akima_periodic (needs at least 5 points)
.IP \[bu] 2
steffen, always-monotonic splines-like (available only with GSL >= 2.0)
.PP
Default interpolation scheme for one-dimensional functions is
\f[C]DEFAULT_INTERPOLATION\f[R].
.PP
Available schemes for \f[I]n\f[R]\[u2004]>\[u2004]1 are:
.IP \[bu] 2
nearest, \f[I]f\f[R](\f[I]x\[u20D7]\f[R]) is equal to the value of the
closest definition point
.IP \[bu] 2
shepard, inverse distance weighted average definition
points (https://en.wikipedia.org/wiki/Inverse_distance_weighting) (might
lead to inefficient evaluation)
.IP \[bu] 2
shepard_kd, average of definition points within a
kd-tree (https://en.wikipedia.org/wiki/Inverse_distance_weighting#Modified_Shepard's_method)
(more efficient evaluation provided \f[C]SHEPARD_RADIUS\f[R] is set to a
proper value)
.IP \[bu] 2
bilinear, only available if the definition points configure an
structured hypercube-like grid.
If \f[I]n\f[R]\[u2004]>\[u2004]3, \f[C]SIZES\f[R] should be given.
.PP
For \f[I]n\f[R]\[u2004]>\[u2004]1, if the euclidean distance between the
arguments and the definition points is smaller than
\f[C]INTERPOLATION_THRESHOLD\f[R], the definition point is returned and
no interpolation is performed.
Default value is square root of
\f[C]DEFAULT_MULTIDIM_INTERPOLATION_THRESHOLD\f[R].
The initial radius of points to take into account in
\f[C]shepard_kd\f[R] is given by \f[C]SHEPARD_RADIUS\f[R].
If no points are found, the radius is double until at least one
definition point is found.
The radius is doubled until at least one point is found.
Default is \f[C]DEFAULT_SHEPARD_RADIUS\f[R].
The exponent of the \f[C]shepard\f[R] method is given by
\f[C]SHEPARD_EXPONENT\f[R].
Default is \f[C]DEFAULT_SHEPARD_EXPONENT\f[R].
When requesting \f[C]bilinear\f[R] interpolation for
\f[I]n\f[R]\[u2004]>\[u2004]3, the number of definition points for each
argument variable has to be given with \f[C]SIZES\f[R], and wether the
definition data is sorted with the first argument changing first
(\f[C]X_INCREASES_FIRST\f[R] evaluating to non-zero) or with the last
argument changing first (zero).
The function can be pointwise-defined inline in the input using
\f[C]DATA\f[R].
This should be the last keyword of the line, followed by
\f[I]N\f[R]\[u2004]=\[u2004]\f[I]k\f[R]\[u2005]\[md]\[u2005](\f[I]n\f[R]\[u2005]+\[u2005]1)
expresions giving \f[I]k\f[R] definition points: \f[I]n\f[R] arguments
and the value of the function.
Multiline continuation using brackets \f[C]{\f[R] and \f[C]}\f[R] can be
used for a clean data organization.
See the examples.
.SS HISTORY
.PP
Record the time history of a variable as a function of time.
.PP
\f[C]HISTORY <variable> <function>\f[R]
.SS IF
.PP
Execute a set of instructions if a condition is met.
.PP
\f[C]IF expr \[at]  <block_of_instructions_if_expr_is_true> \[at] [ ELSE  \[at]  <block_of_instructions_if_expr_is_false> ] \[at] ENDIF\f[R]
.SS IMPLICIT
.PP
Define whether implicit definition of variables is allowed or not.
.PP
\f[C]IMPLICIT { NONE | ALLOWED }\f[R]
.PP
By default, FeenoX allows variables (but not vectors nor matrices) to be
implicitly declared.
To avoid introducing errors due to typos, explicit declaration of
variables can be forced by giving \f[C]IMPLICIT NONE\f[R].
Whether implicit declaration is allowed or explicit declaration is
required depends on the last \f[C]IMPLICIT\f[R] keyword given, which by
default is \f[C]ALLOWED\f[R].
.SS INCLUDE
.PP
Include another FeenoX input file.
.PP
\f[C]INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]\f[R]
.PP
Includes the input file located in the string \f[C]file_path\f[R] at the
current location.
The effect is the same as copying and pasting the contents of the
included file at the location of the \f[C]INCLUDE\f[R] keyword.
The path can be relative or absolute.
Note, however, that when including files inside \f[C]IF\f[R] blocks that
instructions are conditionally-executed but all definitions (such as
function definitions) are processed at parse-time independently from the
evaluation of the conditional.
The included file has to be an actual file path (i.e.\ it cannot be a
FeenoX \f[C]FILE\f[R]) because it needs to be resolved at parse time.
Yet, the name can contain a commandline replacement argument such as
\f[C]$1\f[R] so \f[C]INCLUDE $1.fee\f[R] will include the file specified
after the main input file in the command line.
The optional \f[C]FROM\f[R] and \f[C]TO\f[R] keywords can be used to
include only portions of a file.
.SS INITIAL_CONDITIONS
.PP
Define how initial conditions of DAE problems are computed.
.PP
\f[C]INITIAL_CONDITIONS { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }\f[R]
.PP
In DAE problems, initial conditions may be either:
.IP \[bu] 2
equal to the provided expressions (\f[C]AS_PROVIDED\f[R])
.IP \[bu] 2
the derivatives computed from the provided phase-space variables
(\f[C]FROM_VARIABLES\f[R])
.IP \[bu] 2
the phase-space variables computed from the provided derivatives
(\f[C]FROM_DERIVATIVES\f[R])
.PP
In the first case, it is up to the user to fulfill the DAE system
at\ \f[I]t\f[R]\[u2004]=\[u2004]0.
If the residuals are not small enough, a convergence error will occur.
The \f[C]FROM_VARIABLES\f[R] option means calling IDA\[cq]s
\f[C]IDACalcIC\f[R] routine with the parameter
\f[C]IDA_YA_YDP_INIT\f[R].
The \f[C]FROM_DERIVATIVES\f[R] option means calling IDA\[cq]s
\f[C]IDACalcIC\f[R] routine with the parameter IDA_Y_INIT.
Wasora should be able to automatically detect which variables in
phase-space are differential and which are purely algebraic.
However, the [\f[C]DIFFERENTIAL\f[R]] keyword may be used to explicitly
define them.
See the (SUNDIALS
documentation)[https://computation.llnl.gov/casc/sundials/documentation/ida_guide.pdf]
for further information.
.SS M4
.PP
Call the \f[C]m4\f[R] macro processor with definitions from feenox
variables or expressions.
.PP
\f[C]M4 { INPUT_FILE <file_id> | FILE_PATH <file_path> } { OUTPUT_FILE <file_id> | OUTPUT_FILE_PATH <file_path> } [ EXPAND <name> ] ... } [ MACRO <name> [ <format> ] <definition> ] ... }\f[R]
.SS MATERIAL
.PP
Define a material its and properties to be used in volumes.
.PP
\f[C]MATERIAL <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1>  [ PHYSICAL_GROUP <name_2> [ ... ] ] ] [ <property_name_1>=<expr_1> [ <property_name_2>=<expr_2> [ ... ] ] ] [ <bc_data1> [ <bc_data2> [ ... ] ] ]\f[R]
.PP
If the name of the material matches a physical group in the mesh, it is
automatically linked to that physical group.
If there are many meshes, the mesh this keyword refers to has to be
given with \f[C]MESH\f[R].
If the material applies to more than one physical group in the mesh,
they can be added using as many \f[C]PHYSICAL_GROUP\f[R] keywords as
needed.
.SS MATRIX
.PP
Define a matrix.
.PP
\f[C]MATRIX <name> ROWS <expr> COLS <expr> [ DATA <expr_1> <expr_2> ... <expr_n> |\f[R]
.PP
A new matrix of the prescribed size is defined.
The number of rows and columns can be an expression which will be
evaluated the very first time the matrix is used and then kept at those
constant values.
All elements will be initialized to zero unless \f[C]DATA\f[R] is given
(which should be the last keyword of the line), in which case the
expressions will be evaluated the very first time the matrix is used and
row-major-assigned to each of the elements.
If there are less elements than the matrix size, the remaining values
will be zero.
If there are more elements than the matrix size, the values will be
ignored.
.SS MESH_READ
.PP
\f[C]{ <file_path> | <file_id> } [ DIMENSIONS <num_expr> ]\[at] [ SCALE <expr> ] [ OFFSET <expr_x> <expr_y> <expr_z> ]\[at] [ INTEGRATION { full | reduced } ]\[at] [ MAIN ] [ UPDATE_EACH_STEP ]\[at] [ READ_FIELD <name_in_mesh> AS <function_name> ] [ READ_FIELD ... ] \[at] [ READ_FUNCTION <function_name> ] [READ_FUNCTION ...] \[at]\f[R]
.PP
Either a file identifier (defined previously with a \f[C]FILE\f[R]
keyword) or a file path should be given.
The format is read from the extension, which should be either
.IP \[bu] 2
\f[C].msh\f[R], \f[C].msh2\f[R] or \f[C].msh4\f[R] Gmsh ASCII
format (http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format),
versions 2.2, 4.0 or 4.1
.IP \[bu] 2
\f[C].vtk\f[R] ASCII legacy
VTK (https://lorensen.github.io/VTKExamples/site/VTKFileFormats/)
.IP \[bu] 2
\f[C].frd\f[R] CalculiX\[cq]s FRD ASCII
output (https://web.mit.edu/calculix_v2.7/CalculiX/cgx_2.7/doc/cgx/node4.html))
.PP
Note than only MSH is suitable for defining PDE domains, as it is the
only one that provides information about physical groups.
The other formats are primarily supported to read function data
contained in the file.
The file path or file id can be used to refer to a particular mesh when
reading more than one, for instance in a \f[C]MESH_WRITE\f[R] or
\f[C]MESH_INTEGRATE\f[R] keyword.
If a file path is given such as \f[C]cool_mesh.msh\f[R], it can be
referred to as either \f[C]cool_mesh.msh\f[R] or just
\f[C]cool_mesh\f[R].
The spatial dimensions cab be given with \f[C]DIMENSION\f[R].
If material properties are uniform and given with variables, the number
of dimensions are not needed and will be read from the file at runtime.
But if either properties are given by spatial functions or if functions
are to be read from the mesh with \f[C]READ_DATA\f[R] or
\f[C]READ_FUNCTION\f[R], then the number of dimensions ought to be given
explicitly because FeenoX needs to know how many arguments these
functions take.
If either \f[C]OFFSET\f[R] and/or \f[C]SCALE\f[R] are given, the node
locations are first shifted and then scaled by the provided values.
When defining several meshes and solving a PDE problem, the mesh used as
the PDE domain is the one marked with \f[C]MAIN\f[R].
If none of the meshes is explicitly marked as main, the first one is
used.
If \f[C]UPDATE_EACH_STEP\f[R] is given, then the mesh data is re-read
from the file at each time step.
Default is to read the mesh once, except if the file path changes with
time.
For each \f[C]READ_FIELD\f[R] keyword, a point-wise defined function of
space named \f[C]<function_name>\f[R] is defined and filled with the
scalar data named \f[C]<name_in_mesh>\f[R] contained in the mesh file.
The \f[C]READ_FUNCTION\f[R] keyword is a shortcut when the scalar name
and the to-be-defined function are the same.
If no mesh is marked as \f[C]MAIN\f[R], the first one is the main one.
.SS MINIMIZE
.PP
Find the combination of arguments that give a (relative) minimum of a
function.
.PP
\f[C]MINIMIZE <function>\[at] [ METHOD { nmsimplex2 | nmsimplex | nmsimplex2rand | conjugate_fr | conjugate_pr | vector_bfgs2 | vector_bfgs | steepest_descent}\[at] [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]\[at] [ GUESS <expr_1> <expr_2> ... <expr_n> ]\[at] [ MIN <expr_1> <expr_2> ... <expr_n> ]\[at] [ MAX <expr_1> <expr_2> ... <expr_n> ]\[at] [ STEP <expr_1> <expr_2> ... <expr_n> ]\[at] [ MAX_ITER <expr> ] [ TOL <expr> ] [ GRADTOL <expr> ]\[at] [ VERBOSE ] [ NORERUN ]\[at]\f[R]
.SS OPEN
.PP
Explicitly open a file for input/output.
.PP
\f[C]OPEN <name> [ MODE <fopen_mode> ]\f[R]
.PP
The given \f[C]<name>\f[R] can be either a fixed-string path or an
already-defined \f[C]FILE\f[R].
The mode is only taken into account if the file is not already defined.
Default is write \f[C]w\f[R].
.SS PARAMETRIC
.PP
Systematically sweep a zone of the parameter space, i.e.\ perform a
parametric run.
.PP
\f[C]PARAMETRIC <var_1> [ ... <var_n> ] [ TYPE { linear  | logarithmic  | random  | gaussianrandom  | sobol  | niederreiter  | halton  | reversehalton } ] [ MIN <num_expr_1> ... <num_expr_n> ] [ MAX <num_expr_1> ... <num_expr_n> ] [ STEP <num_expr_1> ... <num_expr_n> ] [ NSTEPS <num_expr_1> ... <num_expr_n> ] [ OUTER_STEPS <num_expr> ] [ MAX_DAUGHTERS <num_expr>  ] [ OFFSET <num_expr> ] [ ADIABATIC ]\f[R]
.SS PHASE_SPACE
.PP
Define the variables, vectors and/or matrices that span the phase space
of the DAE system of equations.
.PP
\f[C]PHASE_SPACE PHASE_SPACE { <vars> ... | <vectors> ... | <matrices> ... }\f[R]
.SS PHYSICAL_GROUP
.PP
Explicitly defines a physical group of elements on a mesh.
.PP
\f[C]PHYSICAL_GROUP <name> [ MESH <name> ] [ DIMENSION <expr> ] [ ID <expr> ]\[at] [ MATERIAL <name> | | BC <name> [ BC ... ] ]\[at]\f[R]
.PP
This keyword should seldom be needed.
Most of the times, a combination of \f[C]MATERIAL\f[R] and \f[C]BC\f[R]
ought to be enough for most purposes.
The name of the \f[C]PHYSICAL_GROUP\f[R] keyword should match the name
of the physical group defined within the input file.
If there is no physical group with the provided name in the mesh, this
instruction has no effect.
If there are many meshes, an explicit mesh can be given with
\f[C]MESH\f[R].
Otherwise, the physical group is defined on the main mesh.
An explicit dimension of the physical group can be provided with
\f[C]DIMENSION\f[R].
An explicit id can be given with \f[C]ID\f[R].
Both dimension and id should match the values in the mesh.
For volumetric elements, physical groups can be linked to materials
using \f[C]MATERIAL\f[R].
Note that if a material is created with the same name as a physical
group in the mesh, they will be linked automatically, so there is no
need to use \f[C]PHYSCAL_GROUP\f[R] for this.
The \f[C]MATERIAL\f[R] keyword in \f[C]PHYSICAL_GROUP\f[R] is used to
link a physical group in a mesh file and a material in the feenox input
file with different names.
Likewise, for non-volumetric elements, physical groups can be linked to
boundary using \f[C]BC\f[R].
As in the preceeding case, if a boundary condition is created with the
same name as a physical group in the mesh, they will be linked
automatically, so there is no need to use \f[C]PHYSCAL_GROUP\f[R] for
this.
The \f[C]BC\f[R] keyword in \f[C]PHYSICAL_GROUP\f[R] is used to link a
physical group in a mesh file and a boundary condition in the feenox
input file with different names.
Note that while there can be only one \f[C]MATERIAL\f[R] associated to a
physical group, there can be many \f[C]BC\f[R]s associated to a physical
group.
.SS PRINT
.PP
Write plain-text and/or formatted data to the standard output or into an
output file.
.PP
\f[C]PRINT [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ] \[at] [ FILE < <file_path> | <file_id> > ] [ HEADER ] [ NONEWLINE ] [ SEP <string> ] \[at] [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] \[at]\f[R]
.PP
Each argument \f[C]object\f[R] which is not a keyword of the
\f[C]PRINT\f[R] instruction will be part of the output.
Objects can be either a matrix, a vector or any valid scalar algebraic
expression.
If the given object cannot be solved into a valid matrix, vector or
expression, it is treated as a string literal if \f[C]IMPLICIT\f[R] is
\f[C]ALLOWED\f[R], otherwise a parser error is raised.
To explicitly interpret an object as a literal string even if it
resolves to a valid numerical expression, it should be prefixed with the
\f[C]TEXT\f[R] keyword such as \f[C]PRINT TEXT 1+1\f[R] that would print
\f[C]1+1\f[R] instead of \f[C]2\f[R].
Objects and string literals can be mixed and given in any order.
Hashes \f[C]#\f[R] appearing literal in text strings have to be quoted
to prevent the parser to treat them as comments within the FeenoX input
file and thus ignoring the rest of the line, like
\f[C]PRINT \[dq]\[rs]# this is a printed comment\[dq]\f[R].
Whenever an argument starts with a porcentage sign \f[C]%\f[R], it is
treated as a C \f[C]printf\f[R]-compatible format specifier and all the
objects that follow it are printed using the given format until a new
format definition is found.
The objects are treated as double-precision floating point numbers, so
only floating point formats should be given.
See the \f[C]printf(3)\f[R] man page for further details.
The default format is \f[C]DEFAULT_PRINT_FORMAT\f[R].
Matrices, vectors, scalar expressions, format modifiers and string
literals can be given in any desired order, and are processed from left
to right.
Vectors are printed element-by-element in a single row.
See \f[C]PRINT_VECTOR\f[R] to print vectors column-wise.
Matrices are printed element-by-element in a single line using row-major
ordering if mixed with other objects but in the natural row and column
fashion if it is the only given object in the \f[C]PRINT\f[R]
instruction.
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
\f[C]stdout\f[R].
If the \f[C]HEADER\f[R] keyword is given, a single line containing the
literal text given for each object is printed at the very first time the
\f[C]PRINT\f[R] instruction is processed, starting with a hash
\f[C]#\f[R] character.
If the \f[C]NONEWLINE\f[R] keyword is not provided, default is to write
a newline \f[C]\[rs]n\f[R] character after all the objects are
processed.
Otherwise, if the last token to be printed is a numerical value, a
separator string will be printed but not the newline \f[C]\[rs]n\f[R]
character.
If the last token is a string, neither the separator nor the newline
will be printed.
The \f[C]SEP\f[R] keyword expects a string used to separate printed
objects.
To print objects without any separation in between give an empty string
like \f[C]SEP \[dq]\[dq]\f[R].
The default is a tabulator character `DEFAULT_PRINT_SEPARATOR'
character.
To print an empty line write \f[C]PRINT\f[R] without arguments.
By default the \f[C]PRINT\f[R] instruction is evaluated every step.
If the \f[C]SKIP_STEP\f[R] (\f[C]SKIP_STATIC_STEP\f[R]) keyword is
given, the instruction is processed only every the number of transient
(static) steps that results in evaluating the expression, which may not
be constant.
The \f[C]SKIP_HEADER_STEP\f[R] keyword works similarly for the optional
\f[C]HEADER\f[R] but by default it is only printed once.
The \f[C]SKIP_TIME\f[R] keyword use time advancements to choose how to
skip printing and may be useful for non-constant time-step problems.
.SS PRINT_FUNCTION
.PP
Print one or more functions as a table of values of dependent and
independent variables.
.PP
\f[C]PRINT_FUNCTION <function_1> [ { function | expr } ... { function | expr } ] \[at] [ FILE { <file_path> | <file_id> } ] [ HEADER ] \[at] [ MIN <expr_1> <expr_2> ... <expr_k> ] [ MAX <expr_1> <expr_2> ... <expr_k> ] \[at] [ STEP <expr_1> <expr_2> ... <expr_k> ] [ NSTEPs <expr_1> <expr_2> ... <expr_k> ] \[at] [ FORMAT <print_format> ] [ PHYSICAL_ENTITY <name> ]\f[R]
.PP
Each argument should be either a function or an expression.
The output of this instruction consists
of\ \f[I]n\f[R]\[u2005]+\[u2005]\f[I]k\f[R] columns, where\ \f[I]n\f[R]
is the number of arguments of the first function of the list
and\ \f[I]k\f[R] is the number of functions and expressions given.
The first\ \f[I]n\f[R] columns are the arguments (independent variables)
and the last\ \f[I]k\f[R] one has the evaluated functions and
expressions.
The columns are separated by a tabulator, which is the format that most
plotting tools understand.
Only function names without arguments are expected.
All functions should have the same number of arguments.
Expressions can involve the arguments of the first function.
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
\f[C]stdout\f[R].
If \f[C]HEADER\f[R] is given, the output is prepended with a single line
containing the names of the arguments and the names of the functions,
separated by tabs.
The header starts with a hash\ \f[C]#\f[R] that usually acts as a
comment and is ignored by most plotting tools.
If there is no explicit range where to evaluate the functions and the
first function is point-wise defined, they are evalauted at the points
of definition of the first one.
The range can be explicitly given as a product of\ \f[I]n\f[R]
ranges\ [\f[I]x\f[R]~\f[I]i\f[R],\[u2006]min\[u2006]~,\[u2006]\f[I]x\f[R]~\f[I]i\f[R],\[u2006]max\[u2006]~]
for \f[I]i\f[R]\[u2004]=\[u2004]1,\[u2006]\&...,\[u2006]\f[I]n\f[R].
The values \f[I]x\f[R]~\f[I]i\f[R],\[u2006]min\[u2006]~ and
\f[I]x\f[R]~\f[I]i\f[R],\[u2006]max\[u2006]~ are given with the
\f[C]MIN\f[R] \f[I]and\f[R] \f[C]MAX\f[R] keywords.
The discretization steps of the ranges are given by either
\f[C]STEP\f[R] that gives\ \f[I]\[*d]\f[R]\f[I]x\f[R] \f[I]or\f[R]
\f[C]NSTEPS\f[R] that gives the number of steps.
If the first function is not point-wise defined, the ranges are
mandatory.
.SS PRINT_VECTOR
.PP
Print the elements of one or more vectors.
.PP
\f[C]PRINT_VECTOR [ FILE <file_id> ] FILE_PATH <file_path> ] [ { VERTICAL | HORIZONTAL } ] [ ELEMS_PER_LINE <expr> ] [ FORMAT <print_format> ] <vector_1> [ vector_2 ... vector_n ]\f[R]
.SS PROBLEM
.PP
Sets the problem type that FeenoX has to solve.
.PP
\f[C]PROBLEM [ mechanical | thermal | modal ]\[at] [ AXISYMMETRIC | PLANE_STRESS | PLANE_STRAIN ] [ SYMMETRY_AXIS { x | y } ] [ LINEAR | NON_LINEAR ]\[at] [ QUASISTATIC | TRANSIENT ]\[at] [ DIMENSIONS <expr> ] [ MESH <identifier> ] \[at] [ N_MODES <expr> ] \[at]\f[R]
.IP \[bu] 2
\f[C]mechanical\f[R] (or \f[C]elastic\f[R]) solves the mechanical
elastic problem.
.IP \[bu] 2
\f[C]thermal\f[R] (or \f[C]heat\f[R] ) solves the heat conduction
problem.
.IP \[bu] 2
\f[C]modal\f[R] computes the natural frequencies and oscillation modes.
.PP
If the \f[C]AXISYMMETRIC\f[R] keyword is given, the mesh is expected to
be two-dimensional in the \f[I]x\f[R]-\f[I]y\f[R] plane and the problem
is assumed to be axi-symmetric around the axis given by
\f[C]SYMMETRY_AXIS\f[R] (default is \f[I]y\f[R]).
If the problem type is mechanical and the mesh is two-dimensional on the
\f[I]x\f[R]-\f[I]y\f[R] plane and no axisymmetry is given, either
\f[C]PLANE_STRESS\f[R] and \f[C]PLAIN_STRAIN\f[R] can be provided
(default is plane stress).
By default Fino tries to detect wheter the computation should be linear
or non-linear.
An explicit mode can be set with either \f[C]LINEAR\f[R] on
\f[C]NON_LINEAR\f[R].
The number of spatial dimensions of the problem needs to be given either
with the keyword \f[C]DIMENSIONS\f[R] or by defining a \f[C]MESH\f[R]
(with an explicit \f[C]DIMENSIONS\f[R] keyword) before
\f[C]PROBLEM\f[R].
If there are more than one \f[C]MESH\f[R]es define, the one over which
the problem is to be solved can be defined by giving the explicit mesh
name with \f[C]MESH\f[R].
By default, the first mesh to be defined in the input file is the one
over which the problem is solved.
The number of modes to be computed in the modal problem.
The default is DEFAULT_NMODES.
.SS READ
.PP
Read data (variables, vectors o matrices) from files or shared-memory
segments.
.PP
\f[C][ READ | WRITE ] [ SHM <name> ] [ { ASCII_FILE_PATH | BINARY_FILE_PATH } <file_path> ] [ { ASCII_FILE | BINARY_FILE } <identifier> ] [ IGNORE_NULL ] [ object_1 object_2 ... object_n ]\f[R]
.SS READ_MESH
.PP
Read an unstructured mesh and (optionally) functions of space-time from
a file.
.PP
\f[C]READ_MESH\f[R]
.SS SEMAPHORE
.PP
Perform either a wait or a post operation on a named shared semaphore.
.PP
\f[C][ SEMAPHORE | SEM ] <name> { WAIT | POST }\f[R]
.SS SHELL
.PP
Execute a shell command.
.PP
\f[C]SHELL <print_format> [ expr_1 expr_2 ... expr_n ]\f[R]
.SS SOLVE
.PP
Solve a non-linear system of\ \f[I]n\f[R] equations with\ \f[I]n\f[R]
unknowns.
.PP
\f[C]SOLVE <n>  UNKNOWNS <var_1> <var_2> ... <var_n> RESIDUALS <expr_1> <expr_2> ... <expr_n> ] GUESS <expr_1> <expr_2> ... <expr_n> ] [ METHOD { dnewton | hybrid | hybrids | broyden } ] [ EPSABS <expr> ] [ EPSREL <expr> ] [ MAX_ITER <expr> ] [ VERBOSE ]\f[R]
.SS SOLVE_PROBLEM
.PP
Explicitly solve the PDE problem.
.PP
\f[C]SOLVE_PROBLEM\f[R]
.PP
Whenever the instruction \f[C]SOLVE_PROBLEM\f[R] is executed, FeenoX
solves the PDE problem.
For static problems, that means solving the equations and filling in the
result functions.
For transient or quasisstatic problems, that means advancing one time
step.
.SS SORT_VECTOR
.PP
Sort the elements of a vector, optionally making the same rearrangement
in another vector.
.PP
\f[C]SORT_VECTOR <vector> [ ASCENDING | DESCENDING ] [ <other_vector> ]\f[R]
.PP
This instruction sorts the elements of \f[C]<vector>\f[R] into either
ascending or descending numerical order.
If \f[C]<other_vector>\f[R] is given, the same rearrangement is made on
it.
Default is ascending order.
.SS TIME_PATH
.PP
Force time-dependent problems to pass through specific instants of time.
.PP
\f[C]TIME_PATH <expr_1> [ <expr_2>  [ ... <expr_n> ] ]\f[R]
.PP
The time step \f[C]dt\f[R] will be reduced whenever the distance between
the current time \f[C]t\f[R] and the next expression in the list is
greater than \f[C]dt\f[R] so as to force \f[C]t\f[R] to coincide with
the expressions given.
The list of expresssions should evaluate to a sorted list of values for
all times.
.SS VAR
.PP
Explicitly define one or more scalar variables.
.PP
\f[C]VAR <name_1> [ <name_2> ] ... [ <name_n> ]\f[R]
.PP
When implicit definition is allowed (see [\f[C]IMPLICIT\f[R]]), scalar
variables need not to be defined before being used if from the context
FeenoX can tell that an scalar variable is needed.
For instance, when defining a function like \f[C]f(x) = x\[ha]2\f[R] it
is not needed to declare \f[C]x\f[R] explictly as a scalar variable.
But if one wants to define a function like
\f[C]g(x) = integral(f(x\[aq]), x\[aq], 0, x)\f[R] then the variable
\f[C]x\[aq]\f[R] needs to be explicitly defined as \f[C]VAR x\[aq]\f[R]
before the integral.
.SS VECTOR
.PP
Define a vector.
.PP
\f[C]VECTOR <name> SIZE <expr> [ FUNCTION_DATA <function> ] [ DATA <expr_1> <expr_2> ... <expr_n> |\f[R]
.PP
A new vector of the prescribed size is defined.
The size can be an expression which will be evaluated the very first
time the vector is used and then kept at that constant value.
If the keyword \f[C]FUNCTION_DATA\f[R] is given, the elements of the
vector will be synchronized with the inpedendent values of the function,
which should be point-wise defined.
The sizes of both the function and the vector should match.
All elements will be initialized to zero unless \f[C]DATA\f[R] is given
(which should be the last keyword of the line), in which case the
expressions will be evaluated the very first time the vector is used and
assigned to each of the elements.
If there are less elements than the vector size, the remaining values
will be zero.
If there are more elements than the vector size, the values will be
ignored.
.SS WRITE
.PP
Write data (variables, vectors o matrices) to files or shared-memory
segments.
See the \f[C]READ\f[R] keyword for usage details.
.SS WRITE_MESH
.PP
Write a mesh and functions of space-time to a file for post-processing.
.PP
\f[C]WRITE_MESH\f[R]
.SH SPECIAL VARIABLES
.PP
TBD.
.SH MATERIAL PROPERTIES
.PP
TBD.
.SH BOUNDARY CONDITIONS
.PP
TBD.
.SH RESULTING DISTRIBUTIONS
.PP
TBD.
.SH BUILT-IN FUNCTIONS
.PP
TBD.
.SH BUILT-IN FUNCTIONALS
.PP
TBD.
.SH BUILT-IN VECTOR FUNCTIONS
.PP
TBD.
.SH NOTES
.PP
TBD.
.SH BUGS
.PP
Report on Github or at <jeremy@seamplex.com>
.SH SEE ALSO
.PP
\f[B]gmsh\f[R]\f[C](1)\f[R], \f[B]mpirun\f[R]\f[C](1)\f[R],
\f[B]paraview\f[R]\f[C](1)\f[R]
.PP
The FeenoX web page contains links to the full source code, binary
versions, updates, examples, verification & validation cases and full
documentation: <https://www.seamplex.com/feenox>.
.PP
The FeenoX Case files contains fully-annotated example:
<https://www.seamplex.com/feenox/cases/>
.SH AUTHORS
Jeremy Theler <jeremy@seamplex.com>.
