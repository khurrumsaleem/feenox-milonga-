.\" Automatically generated by Pandoc 2.14.2
.\"
.TH "FEENOX" "1" "2021-10-01" "FeenoX" "FeenoX User Manual"
.hy
.SH NAME
.PP
FeenoX - a free no-fee no-X uniX-like finite-element(ish) computational
engineering tool
.SH SYNOPSIS
.PP
The basic usage is to execute the \f[B]feenox\f[R] binary passing a path
to an input file that defines the problem, along with other options and
command-line replacement arguments which are explained below:
.PP
\f[B]feenox\f[R] [\f[I]options\f[R] \&...] \f[I]input-file\f[R]
[\f[I]optional_commandline_replacement_arguments\f[R] \&...]
.PP
For large problems that do not fit in a single computer, a parallel run
using \f[B]mpirun\f[R]\f[C](1)\f[R] will be needed:
.PP
\f[B]mpirun\f[R] \f[B]-n\f[R] \f[I]number_of_threads\f[R]
\f[B]feenox\f[R] [\f[I]options\f[R] \&...] \f[I]input-file\f[R]
[\f[I]optional_commandline_replacement_arguments\f[R] \&...]
.PP
Besides executing the \f[B]feenox\f[R] binary, there is an API that
allows to use FeenoX from Python or Julia.
.SH DESCRIPTION
.PP
FeenoX is a computational tool that can solve engineering problems which
are usually casted as differential-algebraic equations (DAEs) or partial
differential equations (PDEs).
It is to finite elements programs and libraries what Markdown is to Word
and TeX, respectively.
In particular, it can solve
.IP \[bu] 2
dynamical systems defined by a set of user-provided DAEs (such as plant
control dynamics for example)
.IP \[bu] 2
mechanical elasticity
.IP \[bu] 2
heat conduction
.IP \[bu] 2
structural modal analysis
.IP \[bu] 2
neutron diffusion
.IP \[bu] 2
neutron transport
.PP
FeenoX reads a plain-text input file which contains the problem
definition and writes 100%-user defined results in ASCII (through
\f[C]PRINT\f[R] or other user-defined output instructions within the
input file).
For PDE problems, it needs a reference to at least one Gmsh mesh file
for the discretization of the domain.
It can write post-processing views in either \f[C].msh\f[R] or
\f[C].vtk\f[R] formats.
.PP
Keep in mind that FeenoX is just a back end reading a set of input files
and writing a set of output files following the design philosophy of
UNIX (separation, composition, representation, economy, extensibility,
etc).
Think of it as a transfer function (or a filter in computer-science
jargon) between input files and output files:
.IP
.nf
\f[C]
                             +------------+
 mesh (*.msh)  }             |            |             { terminal
 data (*.dat)  } input ----> |   FeenoX   |----> output { data files
 input (*.fee) }             |            |             { post (vtk/msh)
                             +------------+
\f[R]
.fi
.PP
Following the UNIX programming philosophy, there are no graphical
interfaces attached to the FeenoX core, although a wide variety of pre
and post-processors can be used with FeenoX.
To illustrate the transfer-function approach, consider the following
input file that solves Laplace\[cq]s equation on a square with some
space-dependent boundary conditions
.PP
.RS
$$
\[rs]begin{cases}
\[rs]phi(x,y) = +y & \[rs]text{for $x=-1$ (left)} \[rs]\[rs]
\[rs]phi(x,y) = -y & \[rs]text{for $x=+1$ (right)} \[rs]\[rs]
\[rs]nabla \[rs]phi \[rs]cdot \[rs]hat{\[rs]vec{n}} = \[rs]sin\[rs]left(\[rs]frac{\[rs]pi}{2} x\[rs]right) & \[rs]text{for $y=-1$ (bottom)} \[rs]\[rs]
\[rs]nabla \[rs]phi \[rs]cdot \[rs]hat{\[rs]vec{n}} =0 & \[rs]text{for $y=+1$ (top)} \[rs]\[rs]
\[rs]end{cases}
$$
.RE
.IP
.nf
\f[C]
PROBLEM laplace 2d
READ_MESH square-centered.msh # [-1:+1]x[-1:+1]

# boundary conditions
BC left    phi=+y
BC right   phi=-y
BC bottom  dphidn=sin(pi/2*x)
BC top     dphidn=0

SOLVE_PROBLEM

# same output in .msh and in .vtk formats
WRITE_MESH laplace-square.msh phi VECTOR dphidx dphidy 0
WRITE_MESH laplace-square.vtk phi VECTOR dphidx dphidy 0
\f[R]
.fi
.PP
The \f[C].msh\f[R] file can be post-processed with Gmsh, and the
\f[C].vtk\f[R] file can be post-processed with Paraview.
See https://www.caeplex.com for a mobile-friendly web-based interface
for solving finite elements in the cloud directly from the browser.
.PP
.PP
.SH OPTIONS
.TP
\f[B]\f[CB]-h\f[B]\f[R], \f[B]\f[CB]--help\f[B]\f[R]
display usage and commmand-line help and exit
.TP
\f[B]\f[CB]-v\f[B]\f[R], \f[B]\f[CB]--version\f[B]\f[R]
display brief version information and exit
.TP
\f[B]\f[CB]-V\f[B]\f[R], \f[B]\f[CB]--versions\f[B]\f[R]
display detailed version information
.PP
Instructions will be read from standard input if \[lq]-\[rq] is passed
as inputfile, i.e.
.IP
.nf
\f[C]
$ echo \[aq]PRINT 2+2\[aq] | feenox -
4
\f[R]
.fi
.PP
PETSc and SLEPc options can be passed in \f[C][options]\f[R] as well,
with the difference that two hyphens have to be used instead of only
once.
For example, to pass the PETSc option \f[C]-ksp_view\f[R] the actual
FeenoX invocation should be
.IP
.nf
\f[C]
$ feenox --ksp_view input.fee
\f[R]
.fi
.PP
The optional \f[C][replacement arguments]\f[R] part of the command line
mean that each argument after the input file that does not start with an
hyphen will be expanded verbatim in the input file in each occurrence of
\f[C]$1\f[R], \f[C]$2\f[R], etc.
For example
.IP
.nf
\f[C]
$ echo \[aq]PRINT $1+$2\[aq] | feenox - 3 4
7
\f[R]
.fi
.SH EXAMPLES
.SH EXIT STATUS
.SH ENVIRONMENT
.SH FILES
.SH CONFORMING TO
.SH INPUT-FILE KEYWORDS
.SS \f[C]ABORT\f[R]
.PP
Catastrophically abort the execution and quit FeenoX.
.IP
.nf
\f[C]
ABORT  
\f[R]
.fi
.PP
Whenever the instruction \f[C]ABORT\f[R] is executed, FeenoX quits with
a non-zero error leve.
It does not close files nor unlock shared memory objects.
The objective of this instruction is to either debug complex input files
by using only parts of them or to conditionally abort the execution
using \f[C]IF\f[R] clauses.
.SS \f[C]ALIAS\f[R]
.PP
Define a scalar alias of an already-defined indentifier.
.IP
.nf
\f[C]
ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }  
\f[R]
.fi
.PP
The existing object can be a variable, a vector element or a matrix
element.
In the first case, the name of the variable should be given as the
existing object.
In the second case, to alias the second element of vector \f[C]v\f[R] to
the new name \f[C]new\f[R], \f[C]v(2)\f[R] should be given as the
existing object.
In the third case, to alias second element (2,3) of matrix \f[C]M\f[R]
to the new name \f[C]new\f[R], \f[C]M(2,3)\f[R] should be given as the
existing object.
.SS \f[C]CLOSE\f[R]
.PP
Explicitly close a file after input/output.
.IP
.nf
\f[C]
CLOSE <name>  
\f[R]
.fi
.PP
The given \f[C]<name>\f[R] can be either a fixed-string path or an
already-defined \f[C]FILE\f[R].
.SS \f[C]DEFAULT_ARGUMENT_VALUE\f[R]
.PP
Give a default value for an optional commandline argument.
.IP
.nf
\f[C]
DEFAULT_ARGUMENT_VALUE <constant> <string>  
\f[R]
.fi
.PP
If a \f[C]$n\f[R] construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional.
The \f[C]<constant>\f[R] should be 1, 2, 3, etc.
and \f[C]<string>\f[R] will be expanded character-by-character where the
\f[C]$n\f[R] construction is.
Whether the resulting expression is to be interpreted as a string or as
a numerical expression will depend on the context.
.SS \f[C]FILE\f[R]
.PP
Define a file with a particularly formatted name to be used either as
input or as output.
.IP
.nf
\f[C]
< FILE | OUTPUT_FILE | INPUT_FILE > <name> PATH <format> expr_1 expr_2 ... expr_n [ INPUT | OUTPUT | MODE <fopen_mode> ]  
\f[R]
.fi
.PP
For reading or writing into files with a fixed path, this instruction is
usually not needed as the \f[C]FILE\f[R] keyword of other instructions
(such as \f[C]PRINT\f[R] or \f[C]MESH\f[R]) can take a fixed-string path
as an argument.
However, if the file name changes as the execution progresses (say
because one file for each step is needed), then an explicit
\f[C]FILE\f[R] needs to be defined with this keyword and later
referenced by the given name.
The path should be given as a \f[C]printf\f[R]-like format string
followed by the expressions which shuold be evaluated in order to obtain
the actual file path.
The expressions will always be floating-point expressions, but the
particular integer specifier \f[C]%d\f[R] is allowed and internally
transformed to \f[C]%.0f\f[R].
The file can be explicitly defined and \f[C]INPUT\f[R], \f[C]OUTPUT\f[R]
or a certain \f[C]fopen()\f[R] mode can be given (i.e.\ \[lq]a\[rq]).
If not explicitly given, the nature of the file will be taken from
context, i.e.\ \f[C]FILE\f[R]s in \f[C]PRINT\f[R] will be
\f[C]OUTPUT\f[R] and \f[C]FILE\f[R]s in \f[C]FUNCTION\f[R] will be
\f[C]INPUT\f[R].
This keyword justs defines the \f[C]FILE\f[R], it does not open it.
The file will be actually openened (and eventually closed)
automatically.
In the rare case where the automated opening and closing does not fit
the expected workflow, the file can be explicitly opened or closed with
the instructions \f[C]FILE_OPEN\f[R] and \f[C]FILE_CLOSE\f[R].
.SS \f[C]FIT\f[R]
.PP
Find parameters to fit an analytical function to a pointwise-defined
function.
.IP
.nf
\f[C]
FIT <function_to_be_fitted>  TO <function_with_data> VIA <var_1> <var_2> ... <var_n>
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ RANGE_MIN <expr_1> <expr_2> ... <expr_j> ]
 [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ]
 [ TOL_REL <expr> ] [ TOL_ABS <expr> ] [ MAX_ITER <expr> ]
 [ VERBOSE ]  
\f[R]
.fi
.PP
The function with the data has to be point-wise defined (i.e.\ a
\f[C]FUNCTION\f[R] read from a file, with inline \f[C]DATA\f[R] or
defined over a mesh).
The function to be fitted has to be parametrized with at least one of
the variables provided after the \f[C]USING\f[R] keyword.
For example to
fit\ \f[I]f\f[R](\f[I]x\f[R],\f[I]y\f[R])\[u2004]=\[u2004]\f[I]a\f[R]\f[I]x\f[R]^2^\[u2005]+\[u2005]\f[I]b\f[R]\f[I]s\f[R]\f[I]q\f[R]\f[I]r\f[R]\f[I]t\f[R](\f[I]y\f[R])
to a pointwise-defined function\ \f[I]g\f[R](\f[I]x\f[R],\f[I]y\f[R])
one gives \f[C]FIT f TO g VIA a b\f[R].
Only the names of the functions have to be given, not the arguments.
Both functions have to have the same number of arguments.
The initial guess of the solution is given by the initial value of the
variables after the \f[C]VIA\f[R] keyword.
Analytical expressions for the gradient of the function to be fitted
with respect to the parameters to be fitted can be optionally given with
the \f[C]GRADIENT\f[R] keyword.
If none is provided, the gradient will be computed numerically using
finite differences.
A range over which the residuals are to be minimized can be given with
\f[C]RANGE_MIN\f[R] and \f[C]RANGE_MAX\f[R].
The expressions give the range of the arguments of the functions, not of
the parameters.
For multidimensional fits, the range is an hypercube.
If no range is given, all the definition points of the function with the
data are used for the fit.
Convergence can be controlled by giving the relative and absolute
tolreances with \f[C]TOL_REL\f[R] (default
\f[C]DEFAULT_NLIN_FIT_EPSREL\f[R]) and \f[C]TOL_ABS\f[R] (default
\f[C]DEFAULT_NLIN_FIT_EPSABS\f[R]), and with the maximum number of
iterations \f[C]MAX_ITER\f[R] (default DEFAULT_NLIN_FIT_MAX_ITER).
If the optional keyword \f[C]VERBOSE\f[R] is given, some data of the
intermediate steps is written in the standard output.
.SS \f[C]FUNCTION\f[R]
.PP
Define a scalar function of one or more variables.
.IP
.nf
\f[C]
FUNCTION <function_name>(<var_1>[,var2,...,var_n]) { 
   = <expr> | 
   FILE { <file> } | 
   VECTORS <vector_1> <vector_2> ... <vector_n> <vector_data> | 
   DATA <num_1> <num_2> ... <num_N> 
 } 
 [ COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] 
 [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | 
 nearest | shepard | shepard_kd | bilinear } ] 
 [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ]  
\f[R]
.fi
.PP
The number of variables \f[I]n\f[R] is given by the number of arguments
given between parenthesis after the function name.
The arguments are defined as new variables if they had not been already
defined explictly as scalar variables.
If the function is given as an algebraic expression, the short-hand
operator \f[C]=\f[R] (or \f[C]:=\f[R] for compatiblity with Maxima) can
be used.
That is to say, \f[C]FUNCTION f(x) = x\[ha]2\f[R] is equivalent to
\f[C]f(x) = x\[ha]2\f[R] (or \f[C]f(x) := x\[ha]2\f[R]).
If a \f[C]FILE\f[R] is given, an ASCII file containing at least
\f[I]n\f[R]\[u2005]+\[u2005]1 columns is expected.
By default, the first \f[I]n\f[R] columns are the values of the
arguments and the last column is the value of the function at those
points.
The order of the columns can be changed with the keyword
\f[C]COLUMNS\f[R], which expects \f[I]n\f[R]\[u2005]+\[u2005]1
expressions corresponding to the column numbers.
If \f[C]VECTORS\f[R] is given, a set of \f[I]n\f[R]\[u2005]+\[u2005]1
vectors of the same size is expected.
The first \f[I]n\f[R] correspond to the arguments and the last one to
the function values.
The function can be pointwise-defined inline in the input using
\f[C]DATA\f[R].
This should be the last keyword of the line, followed by
\f[I]N\f[R]\[u2004]=\[u2004]\f[I]k\f[R]\[u2005]\[md]\[u2005](\f[I]n\f[R]+1)
expresions giving\ \f[I]k\f[R] definition points: \f[I]n\f[R] arguments
and the value of the function.
Multiline continuation using brackets \f[C]{\f[R] and \f[C]}\f[R] can be
used for a clean data organization.
Interpolation schemes can be given for either one or multi-dimensional
functions with \f[C]INTERPOLATION\f[R].
Available schemes for \f[I]n\f[R]\[u2004]=\[u2004]1 are:
.IP \[bu] 2
linear
.IP \[bu] 2
polynomial, the grade is equal to the number of data minus one
.IP \[bu] 2
spline, cubic (needs at least 3 points)
.IP \[bu] 2
spline_periodic
.IP \[bu] 2
akima (needs at least 5 points)
.IP \[bu] 2
akima_periodic (needs at least 5 points)
.IP \[bu] 2
steffen, always-monotonic splines-like interpolator
.PP
Default interpolation scheme for one-dimensional functions is
\f[C]DEFAULT_INTERPOLATION\f[R].
.PP
Available schemes for \f[I]n\f[R]\[u2004]>\[u2004]1 are:
.IP \[bu] 2
nearest, \f[I]f\f[R](\f[I]x\[u20D7]\f[R]) is equal to the value of the
closest definition point
.IP \[bu] 2
shepard, inverse distance weighted average definition points (might lead
to inefficient evaluation)
.IP \[bu] 2
shepard_kd, average of definition points within a kd-tree (more
efficient evaluation provided \f[C]SHEPARD_RADIUS\f[R] is set to a
proper value)
.IP \[bu] 2
bilinear, only available if the definition points configure an
structured hypercube-like grid.
If \f[I]n\f[R]\[u2004]>\[u2004]3, \f[C]SIZES\f[R] should be given.
.PP
For \f[I]n\f[R]\[u2004]>\[u2004]1, if the euclidean distance between the
arguments and the definition points is smaller than
\f[C]INTERPOLATION_THRESHOLD\f[R], the definition point is returned and
no interpolation is performed.
Default value is square root of
\f[C]DEFAULT_MULTIDIM_INTERPOLATION_THRESHOLD\f[R].
.PP
The initial radius of points to take into account in
\f[C]shepard_kd\f[R] is given by \f[C]SHEPARD_RADIUS\f[R].
If no points are found, the radius is double until at least one
definition point is found.
The radius is doubled until at least one point is found.
Default is \f[C]DEFAULT_SHEPARD_RADIUS\f[R].
The exponent of the \f[C]shepard\f[R] method is given by
\f[C]SHEPARD_EXPONENT\f[R].
Default is \f[C]DEFAULT_SHEPARD_EXPONENT\f[R].
.SS \f[C]IF\f[R]
.PP
Execute a set of instructions if a condition is met.
.IP
.nf
\f[C]
IF expr 
  <block_of_instructions_if_expr_is_true> 
 [ ELSE  
  <block_of_instructions_if_expr_is_false> ] 
 ENDIF  
\f[R]
.fi
.SS \f[C]IMPLICIT\f[R]
.PP
Define whether implicit definition of variables is allowed or not.
.IP
.nf
\f[C]
IMPLICIT { NONE | ALLOWED }  
\f[R]
.fi
.PP
By default, FeenoX allows variables (but not vectors nor matrices) to be
implicitly declared.
To avoid introducing errors due to typos, explicit declaration of
variables can be forced by giving \f[C]IMPLICIT NONE\f[R].
Whether implicit declaration is allowed or explicit declaration is
required depends on the last \f[C]IMPLICIT\f[R] keyword given, which by
default is \f[C]ALLOWED\f[R].
.SS \f[C]INCLUDE\f[R]
.PP
Include another FeenoX input file.
.IP
.nf
\f[C]
INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]  
\f[R]
.fi
.PP
Includes the input file located in the string \f[C]file_path\f[R] at the
current location.
The effect is the same as copying and pasting the contents of the
included file at the location of the \f[C]INCLUDE\f[R] keyword.
The path can be relative or absolute.
Note, however, that when including files inside \f[C]IF\f[R] blocks that
instructions are conditionally-executed but all definitions (such as
function definitions) are processed at parse-time independently from the
evaluation of the conditional.
The included file has to be an actual file path (i.e.\ it cannot be a
FeenoX \f[C]FILE\f[R]) because it needs to be resolved at parse time.
Yet, the name can contain a commandline replacement argument such as
\f[C]$1\f[R] so \f[C]INCLUDE $1.fee\f[R] will include the file specified
after the main input file in the command line.
The optional \f[C]FROM\f[R] and \f[C]TO\f[R] keywords can be used to
include only portions of a file.
.SS \f[C]MATRIX\f[R]
.PP
Define a matrix.
.IP
.nf
\f[C]
MATRIX <name> ROWS <expr> COLS <expr> [ DATA <expr_1> <expr_2> ... <expr_n> |  
\f[R]
.fi
.PP
A new matrix of the prescribed size is defined.
The number of rows and columns can be an expression which will be
evaluated the very first time the matrix is used and then kept at those
constant values.
All elements will be initialized to zero unless \f[C]DATA\f[R] is given
(which should be the last keyword of the line), in which case the
expressions will be evaluated the very first time the matrix is used and
row-major-assigned to each of the elements.
If there are less elements than the matrix size, the remaining values
will be zero.
If there are more elements than the matrix size, the values will be
ignored.
.SS \f[C]OPEN\f[R]
.PP
Explicitly open a file for input/output.
.IP
.nf
\f[C]
OPEN <name> [ MODE <fopen_mode> ]  
\f[R]
.fi
.PP
The given \f[C]<name>\f[R] can be either a fixed-string path or an
already-defined \f[C]FILE\f[R].
The mode is only taken into account if the file is not already defined.
Default is write \f[C]w\f[R].
.SS \f[C]PRINT\f[R]
.PP
Write plain-text and/or formatted data to the standard output or into an
output file.
.IP
.nf
\f[C]
PRINT [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ] 
 [ FILE { <file_path> | <file_id> } ] [ HEADER ] [ NONEWLINE ] [ SEP <string> ] 
 [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] 
  
\f[R]
.fi
.PP
Each argument \f[C]object\f[R] which is not a keyword of the
\f[C]PRINT\f[R] instruction will be part of the output.
Objects can be either a matrix, a vector or any valid scalar algebraic
expression.
If the given object cannot be solved into a valid matrix, vector or
expression, it is treated as a string literal if \f[C]IMPLICIT\f[R] is
\f[C]ALLOWED\f[R], otherwise a parser error is raised.
To explicitly interpret an object as a literal string even if it
resolves to a valid numerical expression, it should be prefixed with the
\f[C]TEXT\f[R] keyword such as \f[C]PRINT TEXT 1+1\f[R] that would print
\f[C]1+1\f[R] instead of \f[C]2\f[R].
Objects and string literals can be mixed and given in any order.
Hashes \f[C]#\f[R] appearing literal in text strings have to be quoted
to prevent the parser to treat them as comments within the FeenoX input
file and thus ignoring the rest of the line, like
\f[C]PRINT \[dq]\[rs]# this is a printed comment\[dq]\f[R].
Whenever an argument starts with a porcentage sign \f[C]%\f[R], it is
treated as a C \f[C]printf\f[R]-compatible format specifier and all the
objects that follow it are printed using the given format until a new
format definition is found.
The objects are treated as double-precision floating point numbers, so
only floating point formats should be given.
See the \f[C]printf(3)\f[R] man page for further details.
The default format is \f[C]DEFAULT_PRINT_FORMAT\f[R].
Matrices, vectors, scalar expressions, format modifiers and string
literals can be given in any desired order, and are processed from left
to right.
Vectors are printed element-by-element in a single row.
See \f[C]PRINT_VECTOR\f[R] to print one or more vectors with one element
per line (i.e.\ vertically).
Matrices are printed element-by-element in a single line using row-major
ordering if mixed with other objects but in the natural row and column
fashion if it is the only given object in the \f[C]PRINT\f[R]
instruction.
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
\f[C]stdout\f[R].
If the \f[C]HEADER\f[R] keyword is given, a single line containing the
literal text given for each object is printed at the very first time the
\f[C]PRINT\f[R] instruction is processed, starting with a hash
\f[C]#\f[R] character.
If the \f[C]NONEWLINE\f[R] keyword is not provided, default is to write
a newline \f[C]\[rs]n\f[R] character after all the objects are
processed.
Otherwise, if the last token to be printed is a numerical value, a
separator string will be printed but not the newline \f[C]\[rs]n\f[R]
character.
If the last token is a string, neither the separator nor the newline
will be printed.
The \f[C]SEP\f[R] keyword expects a string used to separate printed
objects.
To print objects without any separation in between give an empty string
like \f[C]SEP \[dq]\[dq]\f[R].
The default is a tabulator character `DEFAULT_PRINT_SEPARATOR'
character.
To print an empty line write \f[C]PRINT\f[R] without arguments.
By default the \f[C]PRINT\f[R] instruction is evaluated every step.
If the \f[C]SKIP_STEP\f[R] (\f[C]SKIP_STATIC_STEP\f[R]) keyword is
given, the instruction is processed only every the number of transient
(static) steps that results in evaluating the expression, which may not
be constant.
The \f[C]SKIP_HEADER_STEP\f[R] keyword works similarly for the optional
\f[C]HEADER\f[R] but by default it is only printed once.
The \f[C]SKIP_TIME\f[R] keyword use time advancements to choose how to
skip printing and may be useful for non-constant time-step problems.
.SS \f[C]PRINT_FUNCTION\f[R]
.PP
Print one or more functions as a table of values of dependent and
independent variables.
.IP
.nf
\f[C]
PRINT_FUNCTION <function_1> [ { function | expr } ... { function | expr } ] 
 [ FILE { <file_path> | <file_id> } ] [ HEADER ] 
 [ MIN <expr_1> <expr_2> ... <expr_k> ] [ MAX <expr_1> <expr_2> ... <expr_k> ] 
 [ STEP <expr_1> <expr_2> ... <expr_k> ] [ NSTEPs <expr_1> <expr_2> ... <expr_k> ] 
 [ FORMAT <print_format> ] <vector_1> [ { vector | expr } ... { vector | expr } ]  
\f[R]
.fi
.PP
Each argument should be either a function or an expression.
The output of this instruction consists
of\ \f[I]n\f[R]\[u2005]+\[u2005]\f[I]k\f[R] columns, where\ \f[I]n\f[R]
is the number of arguments of the first function of the list
and\ \f[I]k\f[R] is the number of functions and expressions given.
The first\ \f[I]n\f[R] columns are the arguments (independent variables)
and the last\ \f[I]k\f[R] one has the evaluated functions and
expressions.
The columns are separated by a tabulator, which is the format that most
plotting tools understand.
Only function names without arguments are expected.
All functions should have the same number of arguments.
Expressions can involve the arguments of the first function.
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
\f[C]stdout\f[R].
If \f[C]HEADER\f[R] is given, the output is prepended with a single line
containing the names of the arguments and the names of the functions,
separated by tabs.
The header starts with a hash\ \f[C]#\f[R] that usually acts as a
comment and is ignored by most plotting tools.
If there is no explicit range where to evaluate the functions and the
first function is point-wise defined, they are evalauted at the points
of definition of the first one.
The range can be explicitly given as a product of\ \f[I]n\f[R]
ranges\ [\f[I]x\f[R]~\f[I]i\f[R],\[u2006]min\[u2006]~,\f[I]x\f[R]~\f[I]i\f[R],\[u2006]max\[u2006]~]
for \f[I]i\f[R]\[u2004]=\[u2004]1,\[u2006]\&...,\[u2006]\f[I]n\f[R].
The values \f[I]x\f[R]~\f[I]i\f[R],\[u2006]min\[u2006]~ and
\f[I]x\f[R]~\f[I]i\f[R],\[u2006]max\[u2006]~ are given with the
\f[C]MIN\f[R] \f[I]and\f[R] \f[C]MAX\f[R] keywords.
The discretization steps of the ranges are given by either
\f[C]STEP\f[R] that gives\ \f[I]\[*d]\f[R]\f[I]x\f[R] \f[I]or\f[R]
\f[C]NSTEPS\f[R] that gives the number of steps.
If the first function is not point-wise defined, the ranges are
mandatory.
.SS \f[C]PRINT_VECTOR\f[R]
.PP
Print the elements of one or more vectors, one element per line.
.IP
.nf
\f[C]
PRINT_VECTOR 
 [ FILE { <file_path> | <file_id> } ] [ HEADER ] 
 [ FORMAT <print_format> ]  
\f[R]
.fi
.PP
Each argument should be either a vector or an expression of the
integer\ \f[C]i\f[R].
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
\f[C]stdout\f[R].
If \f[C]HEADER\f[R] is given, the output is prepended with a single line
containing the names of the arguments and the names of the functions,
separated by tabs.
The header starts with a hash\ \f[C]#\f[R] that usually acts as a
comment and is ignored by most plotting tools.
.SS \f[C]SORT_VECTOR\f[R]
.PP
Sort the elements of a vector, optionally making the same rearrangement
in another vector.
.IP
.nf
\f[C]
SORT_VECTOR <vector> [ ASCENDING | DESCENDING ] [ <other_vector> ]  
\f[R]
.fi
.PP
This instruction sorts the elements of \f[C]<vector>\f[R] into either
ascending or descending numerical order.
If \f[C]<other_vector>\f[R] is given, the same rearrangement is made on
it.
Default is ascending order.
.SS \f[C]VAR\f[R]
.PP
Explicitly define one or more scalar variables.
.IP
.nf
\f[C]
VAR <name_1> [ <name_2> ] ... [ <name_n> ]  
\f[R]
.fi
.PP
When implicit definition is allowed (see \f[C]IMPLICIT\f[R]), scalar
variables need not to be defined before being used if from the context
FeenoX can tell that an scalar variable is needed.
For instance, when defining a function like \f[C]f(x) = x\[ha]2\f[R] it
is not needed to declare \f[C]x\f[R] explictly as a scalar variable.
But if one wants to define a function like
\f[C]g(x) = integral(f(x\[aq]), x\[aq], 0, x)\f[R] then the variable
\f[C]x\[aq]\f[R] needs to be explicitly defined as \f[C]VAR x\[aq]\f[R]
before the integral.
.SS \f[C]VECTOR\f[R]
.PP
Define a vector.
.IP
.nf
\f[C]
VECTOR <name> SIZE <expr> [ FUNCTION_DATA <function> ] [ DATA <expr_1> <expr_2> ... <expr_n> |  
\f[R]
.fi
.PP
A new vector of the prescribed size is defined.
The size can be an expression which will be evaluated the very first
time the vector is used and then kept at that constant value.
If the keyword \f[C]FUNCTION_DATA\f[R] is given, the elements of the
vector will be synchronized with the inpedendent values of the function,
which should be point-wise defined.
The sizes of both the function and the vector should match.
All elements will be initialized to zero unless \f[C]DATA\f[R] is given
(which should be the last keyword of the line), in which case the
expressions will be evaluated the very first time the vector is used and
assigned to each of the elements.
If there are less elements than the vector size, the remaining values
will be zero.
If there are more elements than the vector size, the values will be
ignored.
.SH SPECIAL VARIABLES
.SS \f[C]done\f[R]
.PP
Flag that indicates whether the overall calculation is over.
.PP
This variable is set to true by FeenoX when the computation finished so
it can be checked in an \f[C]IF\f[R] block to do something only in the
last step.
But this variable can also be set to true from the input file,
indicating that the current step should also be the last one.
For example, one can set \f[C]end_time = infinite\f[R] and then finish
the computation at \f[I]t\f[R]\[u2004]=\[u2004]10 by setting
\f[C]done = t > 10\f[R].
This \f[C]done\f[R] variable can also come from (and sent to) other
sources, like a shared memory object for coupled calculations.
.SS \f[C]done_static\f[R]
.PP
Flag that indicates whether the static calculation is over or not.
.PP
It is set to true (i.e.\ \[u2004]\[!=]\[u2004]0) by feenox if
\f[C]step_static\f[R] \[>=] \f[C]static_steps\f[R].
If the user sets it to true, the current step is marked as the last
static step and the static calculation ends after finishing the step.
It can be used in \f[C]IF\f[R] blocks to check if the static step is
finished or not.
.SS \f[C]done_transient\f[R]
.PP
Flag that indicates whether the transient calculation is over or not.
.PP
It is set to true (i.e.\ \[u2004]\[!=]\[u2004]0) by feenox if
\f[C]t\f[R] \[>=] \f[C]end_time\f[R].
If the user sets it to true, the current step is marked as the last
transient step and the transient calculation ends after finishing the
step.
It can be used in \f[C]IF\f[R] blocks to check if the transient steps
are finished or not.
.SS \f[C]dt\f[R]
.PP
Actual value of the time step for transient calculations.
.PP
When solving DAE systems, this variable is set by feenox.
It can be written by the user for example by importing it from another
transient code by means of shared-memory objects.
Care should be taken when solving DAE systems and overwriting
\f[C]t\f[R].
Default value is DEFAULT_DT, which is a power of two and roundoff errors
are thus reduced.
.SS \f[C]end_time\f[R]
.PP
Final time of the transient calculation, to be set by the user.
.PP
The default value is zero, meaning no transient calculation.
.SS \f[C]i\f[R]
.PP
Dummy index, used mainly in vector and matrix row subindex expressions.
.SS \f[C]infinite\f[R]
.PP
A very big positive number.
.PP
It can be used as \f[C]end_time = infinite\f[R] or to define improper
integrals with infinite limits.
Default is 2^50^\[u2004]\[~=]\[u2004]1\[u2005]\[tmu]\[u2005]10^15^.
.SS \f[C]in_static\f[R]
.PP
Flag that indicates if FeenoX is solving the iterative static
calculation.
.PP
This is a read-only variable that is non zero if the static calculation.
.SS \f[C]in_static_first\f[R]
.PP
Flag that indicates if feenox is in the first step of the iterative
static calculation.
.SS \f[C]in_static_last\f[R]
.PP
Flag that indicates if feenox is in the last step of the iterative
static calculation.
.SS \f[C]in_transient\f[R]
.PP
Flag that indicates if feenox is solving transient calculation.
.SS \f[C]in_transient_first\f[R]
.PP
Flag that indicates if feenox is in the first step of the transient
calculation.
.SS \f[C]in_transient_last\f[R]
.PP
Flag that indicates if feenox is in the last step of the transient
calculation.
.SS \f[C]j\f[R]
.PP
Dummy index, used mainly in matrix column subindex expressions.
.SS \f[C]max_dt\f[R]
.PP
Maximum bound for the time step that feenox should take when solving DAE
systems.
.SS \f[C]min_dt\f[R]
.PP
Minimum bound for the time step that feenox should take when solving DAE
systems.
.SS \f[C]ncores\f[R]
.PP
The number of online available cores, as returned by
\f[C]sysconf(_SC_NPROCESSORS_ONLN)\f[R].
.PP
This value can be used in the \f[C]MAX_DAUGHTERS\f[R] expression of the
\f[C]PARAMETRIC\f[R] keyword (i.e \f[C]ncores/2\f[R]).
.SS \f[C]on_gsl_error\f[R]
.PP
This should be set to a mask that indicates how to proceed if an error
ir raised in any routine of the GNU Scientific Library.
.SS \f[C]on_ida_error\f[R]
.PP
This should be set to a mask that indicates how to proceed if an error
ir raised in any routine of the SUNDIALS Library.
.SS \f[C]on_nan\f[R]
.PP
This should be set to a mask that indicates how to proceed if
Not-A-Number signal (such as a division by zero) is generated when
evaluating any expression within feenox.
.SS \f[C]pi\f[R]
.PP
A double-precision floating point representaion of the number
\f[I]\[*p]\f[R]
.PP
It is equal to the \f[C]M_PI\f[R] constant in \f[C]math.h\f[R] .
.SS \f[C]pid\f[R]
.PP
The UNIX process id of the FeenoX instance.
.SS \f[C]realtime_scale\f[R]
.PP
If this variable is not zero, then the transient problem is run trying
to syncrhonize the problem time with realtime, up to a scale given.
.PP
For example, if the scale is set to one, then FeenoX will advance the
problem time at the same pace that the real wall time advances.
If set to two, FeenoX time wil advance twice as fast as real time, and
so on.
If the calculation time is slower than real time modified by the scale,
this variable has no effect on the overall behavior and execution will
proceed as quick as possible with no delays.
.SS \f[C]static_steps\f[R]
.PP
Number of steps that ought to be taken during the static calculation, to
be set by the user.
.PP
The default value is one, meaning only one static step.
.SS \f[C]step_static\f[R]
.PP
Indicates the current step number of the iterative static calculation.
.PP
This is a read-only variable that contains the current step of the
static calculation.
.SS \f[C]step_transient\f[R]
.PP
Indicates the current step number of the transient static calculation.
.PP
This is a read-only variable that contains the current step of the
transient calculation.
.SS \f[C]t\f[R]
.PP
Actual value of the time for transient calculations.
.PP
This variable is set by FeenoX, but can be written by the user for
example by importing it from another transient code by means of
shared-memory objects.
Care should be taken when solving DAE systems and overwriting
\f[C]t\f[R].
.SS \f[C]zero\f[R]
.PP
A very small positive number.
.PP
It is taken to avoid roundoff errors when comparing floating point
numbers such as replacing
\f[I]a\f[R]\[u2004]\[<=]\[u2004]\f[I]a\f[R]~max~ with
\f[I]a\f[R]\[u2004]<\[u2004]\f[I]a\f[R]~max~+ \f[C]zero\f[R].
Default is
(1/2)^\[mi]50^\[u2004]\[~=]\[u2004]9\[u2005]\[tmu]\[u2005]10^\[mi]16^ .
.SH MATERIAL PROPERTIES
.PP
TBD.
.SH BOUNDARY CONDITIONS
.PP
TBD.
.SH RESULTING DISTRIBUTIONS
.PP
TBD.
.SH BUILT-IN FUNCTIONS
.SS \f[C]abs\f[R]
.PP
Returns the absolute value of the argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
abs(x)  
\f[R]
.fi
.SS Example #1, abs.fee
.IP
.nf
\f[C]
PRINT sqrt(abs(-2))

# exercise: remove the absolute value from the sqrt argument
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox abs.fee
1.41421
$
\f[R]
.fi
.SS \f[C]acos\f[R]
.PP
Computes the arc in radians whose cosine is equal to the
argument\ \f[I]x\f[R].
A NaN error is raised if\ |\f[I]x\f[R]|\[u2004]>\[u2004]1.
.IP
.nf
\f[C]
acos(x)  
\f[R]
.fi
.SS Example #1, acos.fee
.IP
.nf
\f[C]
PRINT acos(0)
PRINT acos(1)
PRINT cos(acos(0.5))  acos(cos(0.5))
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox acos.fee
1.5708
0
0.5	0.5
$
\f[R]
.fi
.SS \f[C]asin\f[R]
.PP
Computes the arc in radians whose sine is equal to the
argument\ \f[I]x\f[R].
A NaN error is raised if\ |\f[I]x\f[R]|\[u2004]>\[u2004]1.
.IP
.nf
\f[C]
asin(x)  
\f[R]
.fi
.SS Example #1, asin.fee
.IP
.nf
\f[C]
PRINT asin(0)
PRINT asin(1)
PRINT sin(asin(0.5))  asin(sin(0.5))
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox asin.fee
0
1.5708
0.5	0.5
$
\f[R]
.fi
.SS \f[C]atan\f[R]
.PP
Computes, in radians, the arc tangent of the argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
atan(x)  
\f[R]
.fi
.SS \f[C]atan2\f[R]
.PP
Computes, in radians, the arc tangent of
quotient\ \f[I]y\f[R]/\f[I]x\f[R], using the signs of the two arguments
to determine the quadrant of the result, which is in the range
[\[mi]\f[I]\[*p]\f[R],\f[I]\[*p]\f[R]].
.IP
.nf
\f[C]
atan2(y,x)  
\f[R]
.fi
.SS Example #1, atan.fee
.IP
.nf
\f[C]
PRINT atan(-0.5)  mod(atan(-0.5),2*pi)-pi
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox atan.fee
-0.463648	2.67795
$
\f[R]
.fi
.SS Example #2, atan2.fee
.IP
.nf
\f[C]
PRINT atan2(1,-2) mod(atan(-0.5),2*pi)-pi
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox atan2.fee
2.67795	2.67795
$
\f[R]
.fi
.SS \f[C]ceil\f[R]
.PP
Returns the smallest integral value not less than the
argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
ceil(x)  
\f[R]
.fi
.SS \f[C]clock\f[R]
.PP
Returns the value of a certain clock in seconds measured from a certain
(but specific) milestone.
The kind of clock and the initial milestone depend on the optional
integer argument\ \f[I]f\f[R].
It defaults to one, meaning \f[C]CLOCK_MONOTONIC\f[R].
The list and the meanings of the other available values for\ \f[I]f\f[R]
can be checked in the \f[C]clock_gettime (2)\f[R] system call manual
page.
.IP
.nf
\f[C]
clock([f])  
\f[R]
.fi
.SS Example #1, clock.fee
.IP
.nf
\f[C]
t1 = clock()
PRINT \[dq]doing something in between\[dq]
t2 = clock()
# PRINT \[dq]difference\[dq] t2-t1 \[dq][seconds]\[dq]
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox clock.fee
doing something in between
$
\f[R]
.fi
.SS \f[C]cos\f[R]
.PP
Computes the cosine of the argument\ \f[I]x\f[R], where\ \f[I]x\f[R] is
in radians.
A cosine wave can be generated by passing as the argument\ \f[I]x\f[R] a
linear function of time such
as\ \f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R], where
\f[I]\[*w]\f[R] controls the frequency of the wave and \f[I]\[*f]\f[R]
controls its phase.
.IP
.nf
\f[C]
cos(x)  
\f[R]
.fi
.SS \f[C]cosh\f[R]
.PP
Computes the hyperbolic cosine of the argument\ \f[I]x\f[R],
where\ \f[I]x\f[R] is in radians.
.IP
.nf
\f[C]
cosh(x)  
\f[R]
.fi
.SS \f[C]cpu_time\f[R]
.PP
Returns the CPU time used by FeenoX, in seconds.
If the optional argument \f[C]f\f[R] is not provided or it is zero
(default), the sum of times for both user-space and kernel-space usage
is returned.
For \f[C]f=1\f[R] only user time is returned.
For \f[C]f=2\f[R] only system time is returned.
.IP
.nf
\f[C]
cpu_time([f])  
\f[R]
.fi
.SS \f[C]d_dt\f[R]
.PP
Computes the time derivative of the expression given in the
argument\ \f[I]x\f[R] during a transient problem using the difference
between the value of the signal in the previous time step and the actual
value divided by the time step\ \f[I]\[*d]\f[R]\f[I]t\f[R] stored in
\f[C]dt\f[R].
The argument\ \f[I]x\f[R] does not neet to be a variable, it can be an
expression involving one or more variables that change in time.
For \f[I]t\f[R]\[u2004]=\[u2004]0, the return value is zero.
Unlike the functional \f[C]derivative\f[R], the full dependence of these
variables with time does not need to be known beforehand, i.e.\ the
expression \f[C]x\f[R] might involve variables read from a shared-memory
object at each time step.
.IP
.nf
\f[C]
d_dt(x)  
\f[R]
.fi
.SS Example #1, d_dt.fee
.IP
.nf
\f[C]
end_time = 5
dt = 1/10
t0 = 0.5
r = heaviside(t-t0)

PRINT t r lag(r,1) d_dt(lag(r,1)) r*exp(-(t-t0)) HEADER

# exercise: plot output for different values of dt
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox d_dt.fee > d_dt.dat
$
\f[R]
.fi
.PP
\ 
.SS \f[C]deadband\f[R]
.PP
Filters the first argument\ \f[I]x\f[R] with a deadband centered at zero
with an amplitude given by the second argument \f[I]a\f[R].
.IP
.nf
\f[C]
deadband(x, a)  
\f[R]
.fi
.SS \f[C]equal\f[R]
.PP
Checks if the two first expressions \f[I]a\f[R] and \f[I]b\f[R] are
equal, up to the tolerance given by the third optional argument
\f[I]\[+e]\f[R].
If either |\f[I]a\f[R]|\[u2004]>\[u2004]1 or
|\f[I]b\f[R]|\[u2004]>\[u2004]1, the arguments are compared using
GSL\[cq]s \f[C]gsl_fcmp\f[R], otherwise the absolute value of their
difference is compared against \f[I]\[+e]\f[R].
This function returns zero if the arguments are not equal and one
otherwise.
Default value for \f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[mi]9^.
.IP
.nf
\f[C]
equal(a, b, [eps])  
\f[R]
.fi
.SS \f[C]exp\f[R]
.PP
Computes the exponential function the argument\ \f[I]x\f[R], i.e.\ the
base of the natural logarithm\ \f[I]e\f[R] raised to the\ \f[I]x\f[R]-th
power.
.IP
.nf
\f[C]
exp(x)  
\f[R]
.fi
.SS Example #1, exp.fee
.IP
.nf
\f[C]
PHASE_SPACE x
end_time = 1
alpha = 1.8
x_0 = 1.2
y(t) := x_0 * exp(-alpha*t)

x_dot .= -alpha*x

PRINT t x y(t) y(t)-x 
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox exp.fee > exp.dat
$
\f[R]
.fi
.PP
\ 
.SS \f[C]expint1\f[R]
.PP
Computes the first exponential integral function of the
argument\ \f[I]x\f[R].
If\ \f[I]x\f[R] is zero, a NaN error is issued.
.IP
.nf
\f[C]
expint1(x)  
\f[R]
.fi
.SS Example #1, expint1.fee
.IP
.nf
\f[C]
Def(x) := integral(exp(-x*t)/t,t,1,99)
PRINT_FUNCTION Def expint1(x) MIN 1e-2 MAX 2.0 STEP 1e-2 HEADER
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox expint1.fee > expint1.dat
$
\f[R]
.fi
.PP
\ 
.SS \f[C]expint2\f[R]
.PP
Computes the second exponential integral function of the
argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
expint2(x)  
\f[R]
.fi
.SS \f[C]expint3\f[R]
.PP
Computes the third exponential integral function of the
argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
expint3(x)  
\f[R]
.fi
.SS \f[C]expintn\f[R]
.PP
Computes the \f[I]n\f[R]-th exponential integral function of the
argument\ \f[I]x\f[R].
If\ \f[I]n\f[R] is zero or one and\ \f[I]x\f[R] is zero, a NaN error is
issued.
.IP
.nf
\f[C]
expintn(n,x)  
\f[R]
.fi
.SS \f[C]floor\f[R]
.PP
Returns the largest integral value not greater than the
argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
floor(x)  
\f[R]
.fi
.SS \f[C]heaviside\f[R]
.PP
Computes the zero-centered Heaviside step function of the
argument\ \f[I]x\f[R].
If the optional second argument \f[I]\[*d]\f[R] is provided, the
discontinuous step at\ \f[I]x\f[R]\[u2004]=\[u2004]0 is replaced by a
ramp starting at\ \f[I]x\f[R]\[u2004]=\[u2004]0 and finishing
at\ \f[I]x\f[R]\[u2004]=\[u2004]\f[I]\[*d]\f[R].
.IP
.nf
\f[C]
heaviside(x, [delta])  
\f[R]
.fi
.SS Example #1, heaviside.fee
.IP
.nf
\f[C]
end_time = 1

PRINT t heaviside(t-0.5,0.25)

# exercise: what happens if the second argument is negative?
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox heaviside.fee > heaviside.dat
$
\f[R]
.fi
.PP
\ 
.SS \f[C]if\f[R]
.PP
Performs a conditional testing of the first argument \f[I]a\f[R], and
returns either the second optional argument \f[I]b\f[R] if \f[I]a\f[R]
is different from zero or the third optional argument \f[I]c\f[R] if
\f[I]a\f[R] evaluates to zero.
The comparison of the condition \f[I]a\f[R] with zero is performed
within the precision given by the optional fourth argument
\f[I]\[+e]\f[R].
If the second argument \f[I]c\f[R] is not given and \f[I]a\f[R] is not
zero, the function returns one.
If the third argument \f[I]c\f[R] is not given and \f[I]a\f[R] is zero,
the function returns zero.
The default precision is \f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[mi]9^.
Even though \f[C]if\f[R] is a logical operation, all the arguments and
the returned value are double-precision floating point numbers.
.IP
.nf
\f[C]
if(a, [b], [c], [eps])  
\f[R]
.fi
.SS \f[C]integral_dt\f[R]
.PP
Computes the time integral of the expression given in the
argument\ \f[I]x\f[R] during a transient problem with the trapezoidal
rule using the value of the signal in the previous time step and the
current value.
At \f[I]t\f[R]\[u2004]=\[u2004]0 the integral is initialized to zero.
Unlike the functional \f[C]integral\f[R], the full dependence of these
variables with time does not need to be known beforehand, i.e.\ the
expression \f[C]x\f[R] might involve variables read from a shared-memory
object at each time step.
.IP
.nf
\f[C]
integral_dt(x)  
\f[R]
.fi
.SS Example #1, integral_dt.fee
.IP
.nf
\f[C]
end_time = 2*pi
dt = end_time/100

y = sin(t) + random_gauss(0,0.05,0)

PRINT t y integral_dt(y)

# exercise: compute also  the instantaneous 
# mean value of the signal y(t)
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox integral_dt.fee > integral_dt.dat
$
$
\f[R]
.fi
.PP
\ 
.SS \f[C]integral_euler_dt\f[R]
.PP
Idem as \f[C]integral_dt\f[R] but uses the backward Euler rule to update
the instantaenous integral value.
This function is provided in case this particular way of approximating
time integrals is needed, for instance to compare FeenoX solutions with
other computer codes.
In general, it is recommended to use \f[C]integral_dt\f[R].
.IP
.nf
\f[C]
integral_euler_dt(x)  
\f[R]
.fi
.SS \f[C]is_even\f[R]
.PP
Returns one if the argument\ \f[I]x\f[R] rounded to the nearest integer
is even.
.IP
.nf
\f[C]
is_even(x)  
\f[R]
.fi
.SS \f[C]is_in_interval\f[R]
.PP
Returns true if the argument\ \f[I]x\f[R] is in the
interval\ [\f[I]a\f[R],\[u2006]\f[I]b\f[R]),
i.e.\ including\ \f[I]a\f[R] but excluding\ \f[I]b\f[R].
.IP
.nf
\f[C]
is_in_interval(x, a, b)  
\f[R]
.fi
.SS \f[C]is_odd\f[R]
.PP
Returns one if the argument\ \f[I]x\f[R] rounded to the nearest integer
is odd.
.IP
.nf
\f[C]
is_odd(x)  
\f[R]
.fi
.SS \f[C]j0\f[R]
.PP
Computes the regular cylindrical Bessel function of zeroth order
evaluated at the argument\ \f[I]x\f[R].
.IP
.nf
\f[C]
j0(x)  
\f[R]
.fi
.SS Example #1, j0.fee
.IP
.nf
\f[C]
VAR nu
nu0 = root(j0(nu), nu, 0, 3)
PRINT \[dq]J0\[aq]s first zero is\[dq] nu0 SEP \[dq] \[dq]
PRINT \[dq]Indeed, J0(nu0) is equal to\[dq] j0(nu0) SEP \[dq] \[dq]
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox j0.fee
J0\[aq]s first zero is 2.40483
Indeed, J0(nu0) is equal to 2.32985e-10
$
\f[R]
.fi
.SS \f[C]lag\f[R]
.PP
Filters the first argument\ \f[I]x\f[R](\f[I]t\f[R]) with a first-order
lag of characteristic time \f[I]\[*t]\f[R], i.e.\ this function applies
the transfer function\ $G(s) = \[rs]frac{1}{1 + s\[rs]tau}$ to the
time-dependent signal\ \f[I]x\f[R](\f[I]t\f[R]) to obtain a filtered
signal\ \f[I]y\f[R](\f[I]t\f[R]), by assuming that it is constant during
the time
interval\ [\f[I]t\f[R]\[mi]\f[I]\[*D]\f[R]\f[I]t\f[R],\f[I]t\f[R]] and
using the analytical solution of the differential equation for that case
at\ \f[I]t\f[R]\[u2004]=\[u2004]\f[I]\[*D]\f[R]\f[I]t\f[R] with the
initial
condition\ \f[I]y\f[R](0)\[u2004]=\[u2004]\f[I]y\f[R](\f[I]t\f[R]\[mi]\f[I]\[*D]\f[R]\f[I]t\f[R]).
.IP
.nf
\f[C]
lag(x, tau)  
\f[R]
.fi
.SS \f[C]lag_bilinear\f[R]
.PP
Filters the first argument\ \f[I]x\f[R](\f[I]t\f[R]) with a first-order
lag of characteristic time \f[I]\[*t]\f[R] to the time-dependent
signal\ \f[I]x\f[R](\f[I]t\f[R]) by using the bilinear transformation
formula.
.IP
.nf
\f[C]
lag_bilinear(x, tau)  
\f[R]
.fi
.SS \f[C]lag_euler\f[R]
.PP
Filters the first argument\ \f[I]x\f[R](\f[I]t\f[R]) with a first-order
lag of characteristic time \f[I]\[*t]\f[R] to the time-dependent
signal\ \f[I]x\f[R](\f[I]t\f[R]) by using the Euler forward rule.
.IP
.nf
\f[C]
lag_euler(x, tau)  
\f[R]
.fi
.SS \f[C]last\f[R]
.PP
Returns the value the variable\ \f[I]x\f[R] had in the previous time
step.
This function is equivalent to the\ \f[I]Z\f[R]-transform operator
\[lq]delay\[rq] denoted by\ \f[I]z\f[R]^\[mi]1^[\f[I]x\f[R]].
For\ \f[I]t\f[R]\[u2004]=\[u2004]0 the function returns the actual value
of\ \f[I]x\f[R].
The optional flag\ \f[I]p\f[R] should be set to one if the reference to
\f[C]last\f[R] is done in an assignment over a variable that already
appears inside expression\ \f[I]x\f[R] such as \f[C]x = last(x)\f[R].
See example number 2.
.IP
.nf
\f[C]
last(x,[p])  
\f[R]
.fi
.SS Example #1, last1.fee
.IP
.nf
\f[C]
static_steps = 5
end_time = 1
dt = 0.1

IF in_static
  PRINT step_static last(step_static) last(last(step_static))
ENDIF
IF done_static
  PRINT t last(t) last(last(1-t))
ENDIF  
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox last1.fee
1	1	1
2	1	1
3	2	1
4	3	2
5	4	3
0	0	1
0.1	0	1
0.2	0.1	1
0.3	0.2	0.9
0.4	0.3	0.8
0.5	0.4	0.7
0.6	0.5	0.6
0.7	0.6	0.5
0.8	0.7	0.4
0.9	0.8	0.3
1	0.9	0.2
$
\f[R]
.fi
.SS Example #2, last2.fee
.IP
.nf
\f[C]
end_time = 1
dt = 0.1

y = y + 1
z  = last(z,1) + 1
z\[aq] = last(z\[aq])  + 1

PRINT t %g y z z\[aq]
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox last2.fee
0	1	1	1
0.1	2	2	1
0.2	3	3	2
0.3	4	4	2
0.4	5	5	3
0.5	6	6	3
0.6	7	7	4
0.7	8	8	4
0.8	9	9	5
0.9	10	10	5
1	11	11	6
$
\f[R]
.fi
.SS \f[C]limit\f[R]
.PP
Limits the first argument\ \f[I]x\f[R] to the interval
[\f[I]a\f[R],\f[I]b\f[R]].
The second argument \f[I]a\f[R] should be less than the third argument
\f[I]b\f[R].
.IP
.nf
\f[C]
limit(x, a, b)  
\f[R]
.fi
.SS \f[C]limit_dt\f[R]
.PP
Limits the value of the first argument\ \f[I]x\f[R](\f[I]t\f[R]) so to
that its time derivative is bounded to the interval
[\f[I]a\f[R],\f[I]b\f[R]].
The second argument \f[I]a\f[R] should be less than the third argument
\f[I]b\f[R].
.IP
.nf
\f[C]
limit_dt(x, a, b)  
\f[R]
.fi
.SS \f[C]log\f[R]
.PP
Computes the natural logarithm of the argument\ \f[I]x\f[R].
If\ \f[I]x\f[R] is zero or negative, a NaN error is issued.
.IP
.nf
\f[C]
log(x)  
\f[R]
.fi
.SS Example #1, log1.fee
.IP
.nf
\f[C]
end_time = 1
dt = 1/50

x = d_dt(log(1+t))
y = 1/(1+t)

PRINT t x y y-x 

# exercise: why does this example give a bigger error than the exp.fee example?
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox log1.fee > log1.dat
/p
$
\f[R]
.fi
.PP
\ 
.SS Example #2, log2.fee
.IP
.nf
\f[C]
VAR t\[aq]
x(t) := derivative(log(1+t\[aq]), t\[aq], t)
y(t) := 1/(1+t)

PRINT_FUNCTION x y y(t)-x(t) MIN 0 MAX 1 NSTEPS 50

# exercise: why does this example give a smaller error than the exp.fee example?
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox log2.fee > log2.dat
$
\f[R]
.fi
.PP
\ 
.SS \f[C]mark_max\f[R]
.PP
Returns the integer index \f[I]i\f[R] of the maximum of the
arguments\ \f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be provided.
.IP
.nf
\f[C]
mark_max(x1, x2, [...], [x10])  
\f[R]
.fi
.SS \f[C]mark_min\f[R]
.PP
Returns the integer index \f[I]i\f[R] of the minimum of the
arguments\ \f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be provided.
.IP
.nf
\f[C]
mark_max(x1, x2, [...], [x10])  
\f[R]
.fi
.SS \f[C]max\f[R]
.PP
Returns the maximum of the arguments\ \f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be given.
.IP
.nf
\f[C]
max(x1, x2, [...], [x10])  
\f[R]
.fi
.SS \f[C]memory\f[R]
.PP
Returns the maximum memory (resident set size) used by FeenoX, in
Gigabytes.
.IP
.nf
\f[C]
memory()  
\f[R]
.fi
.SS \f[C]min\f[R]
.PP
Returns the minimum of the arguments\ \f[I]x\f[R]~\f[I]i\f[R]~ provided.
Currently only maximum of ten arguments can be given.
.IP
.nf
\f[C]
min(x1, x2, [...], [x10])  
\f[R]
.fi
.SS \f[C]mod\f[R]
.PP
Returns the remainder of the division between the first
argument\ \f[I]a\f[R] and the second one\ \f[I]b\f[R].
Both arguments may be non-integral.
.IP
.nf
\f[C]
mod(a, b)  
\f[R]
.fi
.SS \f[C]not\f[R]
.PP
Returns one if the first argument\ \f[I]x\f[R] is zero and zero
otherwise.
The second optional argument \f[I]\[+e]\f[R] gives the precision of the
\[lq]zero\[rq] evaluation.
If not given, default is \f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[mi]9^.
.IP
.nf
\f[C]
not(x, [eps])  
\f[R]
.fi
.SS \f[C]random\f[R]
.PP
Returns a random real number uniformly distributed between the first
real argument\ \f[I]x\f[R]~1~ and the second one\ \f[I]x\f[R]~2~.
If the third integer argument \f[I]s\f[R] is given, it is used as the
seed and thus repetitive sequences can be obtained.
If no seed is provided, the current time (in seconds) plus the internal
address of the expression is used.
Therefore, two successive calls to the function without seed (hopefully)
do not give the same result.
This function uses a second-order multiple recursive generator described
by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6.
.IP
.nf
\f[C]
random(x1, x2, [s])  
\f[R]
.fi
.SS \f[C]random_gauss\f[R]
.PP
Returns a random real number with a Gaussian distribution with a mean
equal to the first argument\ \f[I]x\f[R]~1~ and a standard deviation
equatl to the second one\ \f[I]x\f[R]~2~.
If the third integer argument \f[I]s\f[R] is given, it is used as the
seed and thus repetitive sequences can be obtained.
If no seed is provided, the current time (in seconds) plus the internal
address of the expression is used.
Therefore, two successive calls to the function without seed (hopefully)
do not give the same result.
This function uses a second-order multiple recursive generator described
by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6.
.IP
.nf
\f[C]
random_gauss(x1, x2, [s])  
\f[R]
.fi
.SS \f[C]round\f[R]
.PP
Rounds the argument\ \f[I]x\f[R] to the nearest integer.
Halfway cases are rounded away from zero.
.IP
.nf
\f[C]
round(x)  
\f[R]
.fi
.SS \f[C]sawtooth_wave\f[R]
.PP
Computes a sawtooth wave between zero and one with a period equal to
one.
As with the sine wave, a sawtooh wave can be generated by passing as the
argument\ \f[I]x\f[R] a linear function of time such
as\ \f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R],
where\ \f[I]\[*w]\f[R] controls the frequency of the wave and
\f[I]\[*f]\f[R] controls its phase.
.IP
.nf
\f[C]
sawtooth_wave(x)  
\f[R]
.fi
.SS Example #1, sawtooth_wave.fee
.IP
.nf
\f[C]
end_time = 10
dt = 1e-2

r = 2*sawtooth_wave(0.2*t + 0.5) - 1
y = lag(r, 0.5)

PRINT t r y
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox sawtooth_wave.fee > sawtooth_wave.dat
df
$
\f[R]
.fi
.PP
\ 
.SS \f[C]sgn\f[R]
.PP
Returns minus one, zero or plus one depending on the sign of the first
argument\ \f[I]x\f[R].
The second optional argument \f[I]\[+e]\f[R] gives the precision of the
\[lq]zero\[rq] evaluation.
If not given, default is \f[I]\[+e]\f[R]\[u2004]=\[u2004]10^\[mi]9^.
.IP
.nf
\f[C]
sgn(x, [eps])  
\f[R]
.fi
.SS \f[C]sin\f[R]
.PP
Computes the sine of the argument\ \f[I]x\f[R], where\ \f[I]x\f[R] is in
radians.
A sine wave can be generated by passing as the argument\ \f[I]x\f[R] a
linear function of time such
as\ \f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R],
where\ \f[I]\[*w]\f[R] controls the frequency of the wave
and\ \f[I]\[*f]\f[R] controls its phase.
.IP
.nf
\f[C]
sin(x)  
\f[R]
.fi
.SS Example #1, sin.fee
.IP
.nf
\f[C]
PRINT sin(1)
PRINT sqrt(1-cos(1)\[ha]2)
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox sin.fee
0.841471
0.841471
$
\f[R]
.fi
.SS \f[C]sinh\f[R]
.PP
Computes the hyperbolic sine of the argument\ \f[I]x\f[R],
where\ \f[I]x\f[R] is in radians.
.IP
.nf
\f[C]
sinh(x)  
\f[R]
.fi
.SS \f[C]sqrt\f[R]
.PP
Computes the positive square root of the argument\ \f[I]x\f[R].
If\ \f[I]x\f[R] is negative, a NaN error is issued.
.IP
.nf
\f[C]
sqrt(x)  
\f[R]
.fi
.SS \f[C]square_wave\f[R]
.PP
Computes a square function between zero and one with a period equal to
one.
The output is one for 0\[u2004]<\[u2004]\f[I]x\f[R]\[u2004]<\[u2004]1/2
and zero for 1/2\[u2004]\[<=]\[u2004]\f[I]x\f[R]\[u2004]<\[u2004]1.
As with the sine wave, a square wave can be generated by passing as the
argument\ \f[I]x\f[R] a linear function of time such
as\ \f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R],
where\ \f[I]\[*w]\f[R] controls the frequency of the wave
and\ \f[I]\[*f]\f[R] controls its phase.
.IP
.nf
\f[C]
square_wave(x)  
\f[R]
.fi
.SS Example #1, square_wave.fee
.IP
.nf
\f[C]
end_time = 10
dt = 1e-2

r = 2*square_wave(0.2*t - 0.1) - 1
y = lag(r, 0.5)

PRINT t r y
\f[R]
.fi
.IP
.nf
\f[C]
$ feenox square_wave.fee > square_wave.dat
	
$
\f[R]
.fi
.PP
\ 
.SS \f[C]tan\f[R]
.PP
Computes the tangent of the argument\ \f[I]x\f[R], where\ \f[I]x\f[R] is
in radians.
.IP
.nf
\f[C]
tan(x)  
\f[R]
.fi
.SS \f[C]tanh\f[R]
.PP
Computes the hyperbolic tangent of the argument\ \f[I]x\f[R],
where\ \f[I]x\f[R] is in radians.
.IP
.nf
\f[C]
tanh(x)  
\f[R]
.fi
.SS \f[C]threshold_max\f[R]
.PP
Returns one if the first argument\ \f[I]x\f[R] is greater than the
threshold given by the second argument \f[I]a\f[R], and zero otherwise.
If the optional third argument \f[I]b\f[R] is provided, an hysteresis of
width \f[I]b\f[R] is needed in order to reset the function value.
Default is no hysteresis, i.e.\ \f[I]b\f[R]\[u2004]=\[u2004]0.
.IP
.nf
\f[C]
threshold_max(x, a, [b])  
\f[R]
.fi
.SS \f[C]threshold_min\f[R]
.PP
Returns one if the first argument\ \f[I]x\f[R] is less than the
threshold given by the second argument \f[I]a\f[R], and zero otherwise.
If the optional third argument \f[I]b\f[R] is provided, an hysteresis of
width \f[I]b\f[R] is needed in order to reset the function value.
Default is no hysteresis, i.e.\ \f[I]b\f[R]\[u2004]=\[u2004]0.
.IP
.nf
\f[C]
threshold_min(x, a, [b])  
\f[R]
.fi
.SS \f[C]triangular_wave\f[R]
.PP
Computes a triangular wave between zero and one with a period equal to
one.
As with the sine wave, a triangular wave can be generated by passing as
the argument\ \f[I]x\f[R] a linear function of time such
as\ \f[I]\[*w]\f[R]\f[I]t\f[R]\[u2005]+\[u2005]\f[I]\[*f]\f[R],
where\ \f[I]\[*w]\f[R] controls the frequency of the wave
and\ \f[I]\[*f]\f[R] controls its phase.
.IP
.nf
\f[C]
triangular_wave(x)  
\f[R]
.fi
.SS \f[C]wall_time\f[R]
.PP
Returns the time ellapsed since the invocation of FeenoX, in seconds.
.IP
.nf
\f[C]
wall_time()  
\f[R]
.fi
.SH BUILT-IN FUNCTIONALS
.PP
TBD.
.SH BUILT-IN VECTOR FUNCTIONS
.PP
TBD.
.SH NOTES
.PP
TBD.
.SH BUGS
.PP
Report on GitHub https://github.com/seamplex/feenox or at
jeremy\[at]seamplex.com
.SH SEE ALSO
.PP
\f[B]gmsh\f[R]\f[C](1)\f[R], \f[B]mpirun\f[R]\f[C](1)\f[R],
\f[B]paraview\f[R]\f[C](1)\f[R]
.PP
The FeenoX web page contains links to the full source code, binary
versions, updates, examples, verification & validation cases and full
documentation: https://www.seamplex.com/feenox.
.SH AUTHORS
Jeremy Theler jeremy\[at]seamplex.com.
