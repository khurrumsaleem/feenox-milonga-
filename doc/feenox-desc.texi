\input texinfo
@documentencoding UTF-8

@setfilename feenox-desc.info
@c @include version.texi
@set UPDATED 
@set VERSION 

@copying
This manual is for feenox-desc (version @value{VERSION}, @value{UPDATED}),
which is .

Copyright @copyright{} 2016-2021 Jeremy Theler.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title FeenoX description
@subtitle A free no-fee no-X uniX-like finite-element(ish) tool, 
@author Jeremy Theler
@end titlepage

@contents

@node Top
@top FeenoX description

@menu
* Overview::
* Introduction::
* Running feenox::
* Examples::
* Tutorial::
* Description::
* FeenoX & the UNIX Philospohy::
@end menu

@node Overview
@chapter Overview
@anchor{#overview}
FeenoX is a computational tool that can solve engineering problems which
are usually casted as differential-algebraic equations (DAEs) or partial
differential equations (PDEs). It is to finite elements programs and
libraries what Markdown is to Word and TeX, respectively. In particular,
it can solve

@itemize
@item
dynamical systems defined by a set of user-provided DAEs (such as plant
control dynamics for example)
@item
mechanical elasticity
@item
heat conduction
@item
structural modal analysis
@item
neutron diffusion
@item
neutron transport
@end itemize

FeenoX reads a plain-text input file which contains the problem
definition and writes 100%-user defined results in ASCII (through
@code{PRINT} or other user-defined output instructions within the input
file). For PDE problems, it needs a reference to at least one
@uref{http://gmsh.info/,Gmsh} mesh file for the discretization of the
domain. It can write post-processing views in either @code{.msh} or
@code{.vtk} formats.

Keep in mind that FeenoX is just a back end reading a set of input files
and writing a set of output files following the design philosophy of
UNIX (separation, composition, representation, economy, extensibility,
etc). Think of it as a transfer function (or a filter in
computer-science jargon) between input files and output files:

@smallformat
@verbatim
                             +------------+
 mesh (*.msh)  }             |            |             { terminal
 data (*.dat)  } input ----> |   FeenoX   |----> output { data files
 input (*.fee) }             |            |             { post (vtk/msh)
                             +------------+
@end verbatim
@end smallformat

Following the UNIX programming philosophy, there are no graphical
interfaces attached to the FeenoX core, although a wide variety of pre
and post-processors can be used with FeenoX. To illustrate the
transfer-function approach, consider the following input file that
solves Laplace's equation on a square with some space-dependent boundary
conditions

@math{
\begin{cases}
\phi(x,y) = +y & \text{for $x=-1$ (left)} \\
\phi(x,y) = -y & \text{for $x=+1$ (right)} \\
\nabla \phi \cdot \hat{\vec{n}} = \sin\left(\frac{\pi}{2} x\right) & \text{for $y=-1$ (bottom)} \\
\nabla \phi \cdot \hat{\vec{n}} =0 & \text{for $y=+1$ (top)} \\
\end{cases}
}

@smallformat
@verbatim
PROBLEM laplace 2d
READ_MESH square-centered.msh # [-1:+1]x[-1:+1]

# boundary conditions
BC left    phi=+y
BC right   phi=-y
BC bottom  dphidn=sin(pi/2*x)
BC top     dphidn=0

SOLVE_PROBLEM

# same output in .msh and in .vtk formats
WRITE_MESH laplace-square.msh phi VECTOR dphidx dphidy 0
WRITE_MESH laplace-square.vtk phi VECTOR dphidx dphidy 0
@end verbatim
@end smallformat

The @code{.msh} file can be post-processed with
@uref{http://gmsh.info/,Gmsh}, and the @code{.vtk} file can be
post-processed with @uref{https://www.paraview.org/,Paraview}. See
@url{https://www.caeplex.com} for a mobile-friendly web-based interface
for solving finite elements in the cloud directly from the browser.

@float
@image{laplace-square-gmsh,,,Laplace's equation solved with FeenoX and
post-processed with Gmsh,png}
@caption{Laplace's equation solved with FeenoX and post-processed with
Gmsh}
@end float

@float
@image{laplace-square-paraview,,,Laplace's equation solved with FeenoX
and post-processed with Paraview,png}
@caption{Laplace's equation solved with FeenoX and post-processed with
Paraview}
@end float

@node Introduction
@chapter Introduction
@anchor{#introduction}
@uref{https://www.seamplex.com/feenox,FeenoX} is to finite-element
software (like Code Aster) and libraries (like MoFEM) what Markdown is
to word processors (like Word) and typesetting systems (like TeX),
respectively.

It can be seen either as

@itemize
@item
a syntactically-sweetened way of asking the computer to solve
engineering-related mathematical problems, and/or
@item
a finite-element(ish) tool with a particular design basis.
@end itemize

Note that some of the problems solved with FeenoX might not actually
rely on the finite element method, but on general mathematical models
and even on the finite volumes method. That is why we say it is a
finite-element(ish) tool.

@quotation
@itemize
@item
@uref{https://www.seamplex.com/feenox/examples,FeenoX annotated
examples}
@item
FeenoX Overview Presentation, August 2021
@itemize
@item
@uref{https://youtu.be/-RJ5qn7E9uE,Recording (audio in Spanish, slides
in English)}
@item
@uref{https://www.seamplex.com/feenox/doc/2021-feenox.pdf,Slides in PDF}
@item
@uref{https://github.com/gtheler/2021-presentation,Markdown examples
sources}
@end itemize

@end itemize

@end quotation
One of the main features of this allegedly particular design basis is
that @strong{simple problems ought to have simple inputs} (@emph{rule of
simplicity}) or, quoting Alan Kay, ``simple things should be simple,
complex things should be possible.'' For instance, to solve
one-dimensional heat conduction over the domain @math{x\in[0,1]} (which
is indeed one of the most simple engineering problems we can find) the
following input file is enough:

@smallformat
@verbatim
PROBLEM thermal DIMENSIONS 1     # tell FeenoX what we want to solve 
READ_MESH slab.msh               # read mesh in Gmsh's v4.1 format
k = 1                            # set uniform conductivity
BC left  T=0                     # set fixed temperatures as BCs
BC right T=1                     # "left" and "right" are defined in the mesh
SOLVE_PROBLEM                    # tell FeenoX we are ready to solve the problem
PRINT T(0.5)                     # ask for the temperature at x=0.5
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox thermal-1d-dirichlet-constant-k.fee 
0.5
$ 
@end verbatim
@end smallformat

The mesh is assumed to have been already created with
@uref{http://gmsh.info/,Gmsh} (or any other pre-processing tool and
converted to @code{.msh} format with
@uref{https://github.com/nschloe/meshio,Meshio} for example). This
assumption follows the @emph{rule of composition} and prevents the
actual input file to be polluted with mesh-dependent data (such as node
coordinates and/or nodal loads) so as to keep it simple and make it
@uref{https://git-scm.com/,Git}-friendly (@emph{rule of generation}).
The only link between the mesh and the FeenoX input file is through
physical groups (in the case above @code{left} and @code{right}) used to
set boundary conditions and/or material properties.

Another design-basis decision is that @strong{similar problems ought to
have similar inputs} (@emph{rule of least surprise}). So in order to
have a space-dependent conductivity, we only have to replace one line in
the input above: instead of defining a scalar@ @math{k} we define a
function of@ @math{x} (we also update the output to show the analytical
solution as well):

@smallformat
@verbatim
PROBLEM thermal DIMENSIONS 1
READ_MESH slab.msh
k(x) = 1+x                       # space-dependent conductivity
BC left  T=0
BC right T=1
SOLVE_PROBLEM
PRINT T(1/2) log(1+1/2)/log(2)   # print numerical and analytical solutions
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox thermal-1d-dirichlet-space-k.fee 
0.584959	0.584963
$
@end verbatim
@end smallformat

FeenoX has an @strong{everything is an expression} design principle,
meaning that any numerical input can be an algebraic expression
(e.g.@ @code{T(1/2)} is the same as @code{T(0.5)}). If we want to have a
temperature-dependent conductivity (which renders the problem
non-linear) we can take advantage of the fact that @math{T(x)} is
available not only as an argument to @code{PRINT} but also for the
definition of algebraic functions:

@smallformat
@verbatim
PROBLEM thermal DIMENSIONS 1
READ_MESH slab.msh
k(x) = 1+T(x)                    # temperature-dependent conductivity
BC left  T=0
BC right T=1
SOLVE_PROBLEM
PRINT T(1/2) sqrt(1+(3*0.5))-1   # print numerical and analytical solutions
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox thermal-1d-dirichlet-temperature-k.fee 
0.581139	0.581139
$
@end verbatim
@end smallformat

For example, let us consider the famous chaotic
@uref{http://en.wikipedia.org/wiki/Lorenz_system,Lorenz' dynamical
system}. Here is one way of getting an image of the butterfly-shaped
attractor using FeenoX to compute it and
@uref{http://www.gnuplot.info/,gnuplot} to draw it. Solve

@math{
\begin{cases}
\dot{x} &= \sigma \cdot (y - x)  \\
\dot{y} &= x \cdot (r - z) - y   \\
\dot{z} &= x y - b z             \\
\end{cases}
}

for @math{0 < t < 40} with initial conditions

@math{
\begin{cases}
x(0) = -11  \\
y(0) = -16  \\
z(0) = 22.5 \\
\end{cases}
}

and @math{\sigma=10}, @math{r=28} and @math{b=8/3}, which are the
classical parameters that generate the butterfly as presented by Edward
Lorenz back in his seminal 1963 paper
@uref{http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2,Deterministic
non-periodic flow}.

The following ASCII input file ressembles the parameters, inital
conditions and differential equations of the problem as naturally as
possible:

@smallformat
@verbatim
PHASE_SPACE x y z     # Lorenz attractor’s phase space is x-y-z
end_time = 40         # we go from t=0 to 40 non-dimensional units

sigma = 10            # the original parameters from the 1963 paper
r = 28
b = 8/3

x_0 = -11             # initial conditions
y_0 = -16
z_0 = 22.5

# the dynamical system's equations written as naturally as possible
x_dot = sigma*(y - x)
y_dot = x*(r - z) - y
z_dot = x*y - b*z

PRINT t x y z        # four-column plain-ASCII output
@end verbatim
@end smallformat

@float
@image{lorenz,,,The Lorenz attractor solved with FeenoX and drawn with
Gnuplot,svg}
@caption{The Lorenz attractor solved with FeenoX and drawn with Gnuplot}
@end float

Indeed, when executing FeenoX with this input file, we get four ASCII
columns (@math{t}, @math{x}, @math{y} and @math{z}) which we can then
redirect to a file and plot it with a standard tool such as Gnuplot.
Note the importance of relying on plain ASCII text formats both for
input and output, as recommended by the UNIX philosophy and the
@emph{rule of composition}: other programs can easily create inputs for
FeenoX and other programs can easily understand FeenoX' outputs. This is
essentially how UNIX filters and pipes work.

Let us solve the linear elasticity benchmark problem
@uref{https://www.nafems.org/publications/resource_center/p18/,NAFEMS@ LE10}
``Thick plate pressure.'' Assuming a proper mesh has already been
created in Gmsh, note how well the FeenoX input file matches the problem
statement:

@smallformat
@verbatim
# NAFEMS Benchmark LE-10: thick plate pressure
PROBLEM mechanical DIMENSIONS 3
READ_MESH nafems-le10.msh   # mesh in millimeters

# LOADING: uniform normal pressure on the upper surface
BC upper    p=1      # 1 Mpa

# BOUNDARY CONDITIONS:
BC DCD'C'   v=0      # Face DCD'C' zero y-displacement
BC ABA'B'   u=0      # Face ABA'B' zero x-displacement
BC BCB'C'   u=0 v=0  # Face BCB'C' x and y displ. fixed
BC midplane w=0      #  z displacements fixed along mid-plane

# MATERIAL PROPERTIES: isotropic single-material properties
E = 210e3   # Young modulus in MPa
nu = 0.3    # Poisson's ratio

SOLVE_PROBLEM   # solve!

# print the direct stress y at D (and nothing more)
PRINT "sigma_y @ D = " sigmay(2000,0,300) "MPa"
@end verbatim
@end smallformat

The problem asks for the normal stress in the@ @math{y} direction
@math{\sigma_y} at point@ ``D,'' which is what FeenoX writes (and
nothing else, @emph{rule of economy}):

@smallformat
@verbatim
$ feenox nafems-le10.fee 
sigma_y @ D =   -5.38016        MPa
$ 
@end verbatim
@end smallformat

Also note that since there is only one material there is no need to do
an explicit link between material properties and physical volumes in the
mesh (@emph{rule of simplicity}). And since the properties are uniform
and isotropic, a single global scalar for@ @math{E} and a global single
scalar for@ @math{\nu} are enough.

@float
@image{nafems-le10-problem-input,,,The NAFEMS LE10 problem statement and
the corresponding FeenoX input,svg}
@caption{The NAFEMS LE10 problem statement and the corresponding FeenoX
input}
@end float

@float
@image{nafems-le10,,,Normal stress @math{\sigma_y} refined around
point@ @math{D} over 5,000x-warped displacements for LE10 created with
Paraview,png}
@caption{Normal stress @math{\sigma_y} refined around point@ @math{D}
over 5,000x-warped displacements for LE10 created with Paraview}
@end float

For the sake of visual completeness, post-processing data with the
scalar distribution of @math{\sigma_y} and the vector field of
displacements @math{[u,v,w]} can be created by adding one line to the
input file:

@smallformat
@verbatim
WRITE_MESH nafems-le10.vtk sigmay VECTOR u v w
@end verbatim
@end smallformat

This VTK file can then be post-processed to create interactive 3D views,
still screenshots, browser and mobile-friendly webGL models, etc. In
particular, using @uref{https://www.paraview.org,Paraview} one can get a
colorful bitmapped PNG (the displacements are far more interesting than
the stresses in this problem).

Please note the following two points about both cases above:

@enumerate 
@item
The input files are very similar to the statements of each problem in
plain English words (@emph{rule of clarity}). Those with some experience
may want to compare them to the inputs decks (sic) needed for other
common FEA programs.
@item
By design, 100% of FeenoX' output is controlled by the user. Had there
not been any @code{PRINT} or @code{WRITE_MESH} instructions, the output
would have been empty, following the @emph{rule of silence}. This is a
significant change with respect to traditional engineering codes that
date back from times when one CPU hour was worth dozens (or even
hundreds) of engineering hours. At that time, cognizant engineers had to
dig into thousands of lines of data to search for a single individual
result. Nowadays, following the @emph{rule of economy}, it is actually
far easier to ask the code to write only what is needed in the
particular format that suits the user.
@end enumerate

In other words, FeenoX is a computational tool to solve

@itemize
@item
dynamical systems written as sets of ODEs/DAEs, or
@item
steady or quasi-static thermo-mechanical problems, or
@item
steady or transient heat conduction problems, or
@item
modal analysis problems, or
@item
neutron diffusion or transport problems, or
@item
community-contributed problems
@end itemize

in such a way that the input is a near-English text file that defines
the problem to be solved. Some basic rules are

@itemize
@item
FeenoX is just a @strong{solver} working as a @emph{transfer function}
between input and output files. Following the @emph{rules of separation,
parsimony and diversity}, @strong{there is no embedded graphical
interface} but means of using generic pre and post processing tools---in
particular, @uref{http://gmsh.info/,Gmsh} and
@uref{https://www.paraview.org/,Paraview} respectively. See also
@uref{www.caeplex.com,CAEplex}.

@item
The input files should be
@uref{https://en.wikipedia.org/wiki/Syntactic_sugar,syntactically
sugared} so as to be as self-describing as possible.

@item
@strong{Simple} problems ought to need @strong{simple} input files.

@item
Similar problems ought to need similar input files.

@item
@strong{Everything is an expression}. Whenever a number is expected, an
algebraic expression can be entered as well. Variables, vectors,
matrices and functions are supported. Here is how to replace the
boundary condition on the right side of the slab above with a radiation
condition:

@smallformat
@verbatim
sigma = 1       # non-dimensional stefan-boltzmann constant
e = 0.8         # emissivity 
Tinf=1          # non-dimensional reference temperature
BC right q=sigma*e*(Tinf^4-T(x)^4)
@end verbatim
@end smallformat

@end itemize

@itemize
@item
FeenoX should run natively in the cloud and be able to massively scale
in parallel. See the @uref{doc/sds.md,Software Requirements
Specification} and the @uref{doc/sds.md,Software Development
Specification} for details.
@end itemize

Since it is free
(@uref{https://www.gnu.org/philosophy/free-sw.en.html,as in freedom})
and open source, contributions to add features (and to fix bugs) are
welcome. In particular, each kind of problem supported by FeenoX
(thermal, mechanical, modal, etc.) has a subdirectory of source files
which can be used as a template to add new problems, as implied in the
``community-contributed problems'' bullet above (@emph{rules of
modularity and extensibility}). See the @uref{doc,documentation} for
details about how to contribute.

@node Running feenox
@chapter Running @code{feenox}
@anchor{#running-feenox}

@menu
* Invocation::
* Compilation::
@end menu

@node Invocation
@section Invocation
@anchor{#invocation}
The format for running the @code{feenox} program is:

@smallformat
@verbatim
feenox [options] inputfile [optional_extra_arguments] ...
@end verbatim
@end smallformat

The @code{feenox} executable supports the following options:

@table @asis
@item @code{-h}, @code{--help}

display usage and commmand-line help and exit

@item @code{-v}, @code{--version}

display brief version information and exit

@item @code{-V}, @code{--versions}

display detailed version information

@end table

Instructions will be read from standard input if ``-'' is passed as
inputfile, i.e.

@smallformat
@verbatim
$ echo 'PRINT 2+2' | feenox -
4
@end verbatim
@end smallformat

PETSc and SLEPc options can be passed in @code{[options]} as well, with
the difference that two hyphens have to be used instead of only once.
For example, to pass the PETSc option @code{-ksp_view} the actual FeenoX
invocation should be

@smallformat
@verbatim
$ feenox --ksp_view input.fee
@end verbatim
@end smallformat

The optional @code{[replacement arguments]} part of the command line
mean that each argument after the input file that does not start with an
hyphen will be expanded verbatim in the input file in each occurrence of
@code{$1}, @code{$2}, etc. For example

@smallformat
@verbatim
$ echo 'PRINT $1+$2' | feenox - 3 4
7
@end verbatim
@end smallformat

@node Compilation
@section Compilation
@anchor{#compilation}
These detailed compilation instructions are aimed at @code{amd64}
Debian-based GNU/Linux distributions. The compilation procedure follows
POSIX, so it should work in other operating systems and architectures as
well. Distributions not using @code{apt} for packages (i.e.@ @code{yum})
should change the package installation commands (and possibly the
package names). The instructions should also work for in MacOS, although
the @code{apt-get} commands should be replaced by @code{brew} or
similar. Same for Windows under @uref{https://www.cygwin.com/,Cygwin},
the packages should be installed through the Cygwin installer. WSL was
not tested, but should work as well.

@menu
* Quickstart::
* Detailed configuration and compilation::
* Advanced settings::
@end menu

@node Quickstart
@subsection Quickstart
@anchor{#quickstart}
Note that the quickest way to get started is to get an already-compiled
statically-linked binary executable. Follow these instructions if that
option is not suitable for your workflow.

On a GNU/Linux box (preferably Debian-based), follow these quick steps.
See next section for detailed explanations.

To compile the Git repository, proceed as follows. This procedure does
need @code{git} and @code{autoconf} but new versions can be pulled and
recompiled easily.

@enumerate 
@item
Install mandatory dependencies

@smallformat
@verbatim
sudo apt-get install gcc make git automake autoconf libgsl-dev
@end verbatim
@end smallformat

If you cannot install @code{libgsl-dev} but still have @code{git} and
the build toolchain, you can have the @code{configure} script to
download and compile it for you. See point@ 4 below.

@item
Install optional dependencies (of course these are @emph{optional} but
recommended)

@smallformat
@verbatim
sudo apt-get install libsundials-dev petsc-dev slepc-dev
@end verbatim
@end smallformat

@item
Clone Github repository

@smallformat
@verbatim
git clone https://github.com/seamplex/feenox
@end verbatim
@end smallformat

@item
Boostrap, configure, compile & make

@smallformat
@verbatim
cd feenox
./autogen.sh
./configure
make -j4
@end verbatim
@end smallformat

If you cannot (or do not want) to use @code{libgsl-dev} from a package
repository, call @code{configure} with @code{--enable-download-gsl}:

@smallformat
@verbatim
./configure --enable-download-gsl
@end verbatim
@end smallformat

If you do not have Internet access, get the tarball manually, copy it to
the same directory as @code{configure} and run again.

@item
Run test suite (optional)

@smallformat
@verbatim
make check
@end verbatim
@end smallformat

@item
Install the binary system wide (optional)

@smallformat
@verbatim
sudo make install
@end verbatim
@end smallformat

@end enumerate

To stay up to date, pull and then autogen, configure and make (and
optionally install):

@smallformat
@verbatim
git pull
./autogen.sh; ./configure; make -j4
sudo make install
@end verbatim
@end smallformat

@node Detailed configuration and compilation
@subsection Detailed configuration and compilation
@anchor{#detailed-configuration-and-compilation}
The main target and development environment is Debian@ GNU/Linux,
although it should be possible to compile FeenoX in any free GNU/Linux
variant (and even the in non-free MacOS and Windows). As per the
@uref{SRS.md,SRS}, all dependencies have to be available on mainstream
GNU/Linux distributions. But they can also be compiled from source in
case the package repositories are not available or customized
compilation flags are needed (i.e.@ optimization or debugging settings).

All the dependencies are free and open source software. PETSc/SLEPc also
depend on other mathematical libraries to perform particular operations
such as linear algebra. These extra dependencies can be either free
(such as LAPACK) or non-free (such as MKL), but there is always at least
one combination of a working setup that involves only free and open
source software which is compatible with FeenoX licensing terms
(GPLv3+). See the documentation of each package for licensing details.

@menu
* Mandatory dependencies::
* Optional dependencies::
* FeenoX source code::
* Configuration::
* Source code compilation::
* Test suite::
* Installation::
@end menu

@node Mandatory dependencies
@subsubsection Mandatory dependencies
@anchor{#mandatory-dependencies}
FeenoX has one mandatory dependency for run-time execution and the
standard build toolchain for compilation. It is written in C99 so only a
C compiler is needed, although @code{make} is also required. Free and
open source compilers are favored. The usual C compiler is @code{gcc}
but @code{clang} can also be used. Nevertheless, the non-free @code{icc}
has also been tested.

Note that there is no need to have a Fortran nor a C++ compiler to build
FeenoX. They might be needed to build other dependencies (such as
PETSc), but not to compile FeenoX with all the dependencies installed
from package repositories. In case the build toolchain is not already
installed, do so with

@smallformat
@verbatim
sudo apt-get install gcc make
@end verbatim
@end smallformat

If the source is to be fetched from the Git repository then of course
@code{git} is needed but also @code{autoconf} and @code{automake} since
the @code{configure} script is not stored in the Git repository but the
@code{autogen.sh} script that bootstraps the tree and creates it. So if
instead of compiling a source tarball one wants to clone from GitHub,
these packages are also mandatory:

@smallformat
@verbatim
sudo apt-get install git automake autoconf
@end verbatim
@end smallformat

Again, chances are that any existing GNU/Linux box has all these tools
already installed.
The GNU Scientific Library
The only run-time dependency is
@uref{https://www.gnu.org/software/gsl/,GNU GSL} (not to be confused
with @uref{https://github.com/microsoft/GSL,Microsoft GSL}). It can be
installed with

@smallformat
@verbatim
sudo apt-get install libgsl-dev
@end verbatim
@end smallformat

In case this package is not available or you do not have enough
permissions to install system-wide packages, there are two options.

@enumerate 
@item
Pass the option @code{--enable-download-gsl} to the @code{configure}
script below.
@item
Manually download, compile and install
@uref{https://www.gnu.org/software/gsl/,GNU GSL}
@end enumerate

If the @code{configure} script cannot find both the headers and the
actual library, it will refuse to proceed. Note that the FeenoX binaries
already contain a static version of the GSL so it is not needed to have
it installed in order to run the statically-linked binaries.

@node Optional dependencies
@subsubsection Optional dependencies
@anchor{#optional-dependencies}
FeenoX has three optional run-time dependencies. It can be compiled
without any of these but functionality will be reduced:

@itemize
@item
@uref{https://computing.llnl.gov/projects/sundials,SUNDIALS} provides
support for solving systems of ordinary differential equations (ODEs) or
differential-algebraic equations (DAEs). This dependency is needed when
running inputs with the @code{PHASE_SPACE} keyword.

@item
@uref{https://petsc.org/,PETSc} provides support for solving partial
differential equations (PDEs). This dependency is needed when running
inputs with the @code{PROBLEM} keyword.

@item
@uref{https://slepc.upv.es/,SLEPc} provides support for solving
eigen-value problems in partial differential equations (PDEs). This
dependency is needed for inputs with @code{PROBLEM} types with
eigen-value formulations such as @code{modal} and
@code{neutron_transport}.

@end itemize

In absence of all these, FeenoX can still be used to

@itemize
@item
solve general mathematical problems such as the ones to compute the
Fibonacci sequence,
@item
operate on functions, either algebraically or point-wise interpolated,
@item
read, operate over and write meshes,
@item
etc.
@end itemize

These optional dependencies have to be installed separately. There is no
option to have @code{configure} to download them as with
@code{--enable-download-gsl}.
SUNDIALS
@uref{https://computing.llnl.gov/projects/sundials,SUNDIALS} is a SUite
of Nonlinear and DIfferential/ALgebraic equation Solvers. It is used by
FeenoX to solve dynamical systems casted as DAEs with the keyword
@code{PHASE_SPACE}, like the Lorenz system.

Install either by doing

@smallformat
@verbatim
sudo apt-get install libsundials-dev
@end verbatim
@end smallformat

or by following the instructions in the documentation.
PETSc
@uref{https://petsc.org/,PETSc}, the Portable, Extensible Toolkit for
Scientific Computation, pronounced PET-see (/ˈpɛt-siː/), is a suite of
data structures and routines for the scalable (parallel) solution of
scientific applications modeled by partial differential equations. It is
used by FeenoX to solve PDEs with the keyword @code{PROBLEM}, like
thermal conduction on a slab.

Install either by doing

@smallformat
@verbatim
sudo apt-get install petsc-dev
@end verbatim
@end smallformat

or by following the instructions in the documentation.

Note that

@itemize
@item
Configuring and compiling PETSc from scratch might be difficult the
first time. It has a lot of dependencies and options. Read the official
@uref{https://petsc.org/release/install/,documentation} for a detailed
explanation.
@item
There is a huge difference in efficiency between using PETSc compiled
with debugging symbols and with optimization flags. Make sure to
configure @code{--with-debugging=0} for FeenoX production runs and leave
the debugging symbols (which is the default) for development only.
@item
FeenoX needs PETSc to be configured with real double-precision scalars.
It will compile but will complain at run-time when using complex and/or
single or quad-precision scalars.
@item
FeenoX honors the @code{PETSC_DIR} and @code{PETSC_ARCH} environment
variables when executing @code{configure}. If these two do not exist or
are empty, it will try to use the default system-wide locations
(i.e.@ the @code{petsc-dev} package).
@end itemize

SLEPc
@uref{https://slepc.upv.es/,SLEPc}, the Scalable Library for Eigenvalue
Problem Computations, is a software library for the solution of large
scale sparse eigenvalue problems on parallel computers. It is used by
FeenoX to solve PDEs with the keyword @code{PROBLEM} that need
eigen-value computations, such as modal analysis of a cantilevered beam.

Install either by doing

@smallformat
@verbatim
sudo apt-get install slepc-dev
@end verbatim
@end smallformat

or by following the instructions in the documentation.

Note that

@itemize
@item
SLEPc is an extension of PETSc so the latter has to be already installed
and configured.
@item
FeenoX honors the @code{SLEPC_DIR} environment variable when executing
@code{configure}. If it does not exist or is empty it will try to use
the default system-wide locations (i.e.@ the @code{slepc-dev} package).
@item
If PETSc was configured with @code{--download-slepc} then the
@code{SLEPC_DIR} variable has to be set to the directory inside
@code{PETSC_DIR} where SLEPc was cloned and compiled.
@end itemize

@node FeenoX source code
@subsubsection FeenoX source code
@anchor{#feenox-source-code}
There are two ways of getting FeenoX' source code:

@enumerate 
@item
Cloning the GitHub repository at
@url{https://github.com/seamplex/feenox}
@item
Downloading a source tarball from
@url{https://seamplex.com/feenox/dist/src/}
@end enumerate

Git repository
The main Git repository is hosted on GitHub at
@url{https://github.com/seamplex/feenox}. It is public so it can be
cloned either through HTTPS or SSH without needing any particular
credentials. It can also be forked freely. See the
@uref{programming.md,Programming Guide} for details about pull requests
and/or write access to the main repository.

Ideally, the @code{main} branch should have a usable snapshot. All other
branches might contain code that might not compile or might not run or
might not be tested. If you find a commit in the main branch that does
not pass the tests, please report it in the issue tracker ASAP.

After cloning the repository

@smallformat
@verbatim
git clone https://github.com/seamplex/feenox
@end verbatim
@end smallformat

the @code{autogen.sh} script has to be called to bootstrap the working
tree, since the @code{configure} script is not stored in the repository
but created from @code{configure.ac} (which is in the repository) by
@code{autogen}.

Similarly, after updating the working tree with

@smallformat
@verbatim
git pull
@end verbatim
@end smallformat

it is recommended to re-run the @code{autogen.sh} script. It will do a
@code{make clean} and re-compute the version string.
Source tarballs
When downloading a source tarball, there is no need to run
@code{autogen.sh} since the @code{configure} script is already included
in the tarball. This method cannot update the working tree. For each new
FeenoX release, the whole tarball has to be downloaded again.

@node Configuration
@subsubsection Configuration
@anchor{#configuration}
To create a proper @code{Makefile} for the particular architecture,
dependencies and compilation options, the script @code{configure} has to
be executed. This procedure follows the
@uref{https://www.gnu.org/prep/standards/,GNU Coding Standards}.

@smallformat
@verbatim
./configure
@end verbatim
@end smallformat

Without any particular options, @code{configure} will check if the
mandatory @uref{https://www.gnu.org/software/gsl/,GNU Scientific
Library} is available (both its headers and run-time library). If it is
not, then the option @code{--enable-download-gsl} can be used. This
option will try to use @code{wget} (which should be installed) to
download a source tarball, uncompress is, configure and compile it. If
these steps are successful, this GSL will be statically linked into the
resulting FeenoX executable. If there is no internet connection, the
@code{configure} script will say that the download failed. In that case,
get the indicated tarball file manually , copy it into the current
directory and re-run @code{./configure}.

The script will also check for the availability of optional
dependencies. At the end of the execution, a summary of what was found
(or not) is printed in the standard output:

@smallformat
@verbatim
$ ./configure
[...]
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS IDA            yes
  PETSc                   yes /usr/lib/petsc 
  SLEPc                   no
[...]  
@end verbatim
@end smallformat

If for some reason one of the optional dependencies is available but
FeenoX should not use it, then pass @code{--without-sundials},
@code{--without-petsc} and/or @code{--without-slepc} as arguments. For
example

@smallformat
@verbatim
$ ./configure --without-sundials --without-petsc
[...]
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS                no
  PETSc                   no
  SLEPc                   no
[...]  
@end verbatim
@end smallformat

If configure complains about contradicting values from the cached ones,
run @code{autogen.sh} again before @code{configure} or uncompress the
source tarball in a fresh location.

To see all the available options run

@smallformat
@verbatim
./configure --help
@end verbatim
@end smallformat

@node Source code compilation
@subsubsection Source code compilation
@anchor{#source-code-compilation}
After the successful execution of @code{configure}, a @code{Makefile} is
created. To compile FeenoX, just execute

@smallformat
@verbatim
make
@end verbatim
@end smallformat

Compilation should take a dozen of seconds. It can be even sped up by
using the @code{-j} option

@smallformat
@verbatim
make -j8
@end verbatim
@end smallformat

The binary executable will be located in the @code{src} directory but a
copy will be made in the base directory as well. Test it by running
without any arguments

@smallformat
@verbatim
$ ./feenox
FeenoX v0.1.24-g6cfe063 
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

usage: ./feenox [options] inputfile [replacement arguments]

  -h, --help         display usage and commmand-line help and exit
  -v, --version      display brief version information and exit
  -V, --versions     display detailed version information
  -s, --sumarize     list all symbols in the input file and exit

Instructions will be read from standard input if “-” is passed as
inputfile, i.e.

    $ echo "PRINT 2+2" | feenox -
    4

Report bugs at https://github.com/seamplex/feenox or to jeremy@seamplex.com
Feenox home page: https://www.seamplex.com/feenox/
$
@end verbatim
@end smallformat

The @code{-v} (or @code{--version}) option shows the version and a
copyright notice:

@smallformat
@verbatim
$ ./feenox -v
FeenoX v0.1.24-g6cfe063
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

Copyright (C) 2009--2021 jeremy theler
GNU General Public License v3+, https://www.gnu.org/licenses/gpl.html. 
FeenoX is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
$
@end verbatim
@end smallformat

The @code{-V} (or @code{--versions}) option shows the dates of the last
commits, the compiler options and the versions of the linked libraries:

@smallformat
@verbatim
$ ./feenox -V
FeenoX v0.1.24-g6cfe063
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

Last commit date   : Sun Aug 29 11:34:04 2021 -0300
Build date         : Sun Aug 29 11:44:50 2021 -0300
Build architecture : linux-gnu x86_64
Compiler           : gcc (Ubuntu 10.3.0-1ubuntu1) 10.3.0
Compiler flags     : -O3
Builder            : gtheler@chalmers
GSL version        : 2.6
SUNDIALS version   : 4.1.0
PETSc version      : Petsc Release Version 3.14.5, Mar 03, 2021 
PETSc arch         : 
PETSc options      : --build=x86_64-linux-gnu --prefix=/usr --includedir=${prefix}/include --mandir=${prefix}/share/man --infodir=${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --with-option-checking=0 --with-silent-rules=0 --libdir=${prefix}/lib/x86_64-linux-gnu --runstatedir=/run --with-maintainer-mode=0 --with-dependency-tracking=0 --with-debugging=0 --shared-library-extension=_real --with-shared-libraries --with-pic=1 --with-cc=mpicc --with-cxx=mpicxx --with-fc=mpif90 --with-cxx-dialect=C++11 --with-opencl=1 --with-blas-lib=-lblas --with-lapack-lib=-llapack --with-scalapack=1 --with-scalapack-lib=-lscalapack-openmpi --with-ptscotch=1 --with-ptscotch-include=/usr/include/scotch --with-ptscotch-lib="-lptesmumps -lptscotch -lptscotcherr" --with-fftw=1 --with-fftw-include="[]" --with-fftw-lib="-lfftw3 -lfftw3_mpi" --with-superlu_dist=1 --with-superlu_dist-include=/usr/include/superlu-dist --with-superlu_dist-lib=-lsuperlu_dist --with-hdf5-include=/usr/include/hdf5/openmpi --with-hdf5-lib="-L/usr/lib/x86_64-linux-gnu/hdf5/openmpi -L/usr/lib/x86_64-linux-gnu/openmpi/lib -lhdf5 -lmpi" --CXX_LINKER_FLAGS=-Wl,--no-as-needed --with-hypre=1 --with-hypre-include=/usr/include/hypre --with-hypre-lib=-lHYPRE_core --with-mumps=1 --with-mumps-include="[]" --with-mumps-lib="-ldmumps -lzmumps -lsmumps -lcmumps -lmumps_common -lpord" --with-suitesparse=1 --with-suitesparse-include=/usr/include/suitesparse --with-suitesparse-lib="-lumfpack -lamd -lcholmod -lklu" --with-superlu=1 --with-superlu-include=/usr/include/superlu --with-superlu-lib=-lsuperlu --prefix=/usr/lib/petscdir/petsc3.14/x86_64-linux-gnu-real --PETSC_ARCH=x86_64-linux-gnu-real CFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -fPIC" CXXFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -fPIC" FCFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -fPIC -ffree-line-length-0" FFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -fPIC -ffree-line-length-0" CPPFLAGS="-Wdate-time -D_FORTIFY_SOURCE=2" LDFLAGS="-Wl,-Bsymbolic-functions -flto=auto -Wl,-z,relro -fPIC" MAKEFLAGS=w
SLEPc version      : SLEPc Release Version 3.14.2, Feb 01, 2021
$
@end verbatim
@end smallformat

@node Test suite
@subsubsection Test suite
@anchor{#test-suite}
To be explained.

@node Installation
@subsubsection Installation
@anchor{#installation}
To be explained.

@node Advanced settings
@subsection Advanced settings
@anchor{#advanced-settings}

@menu
* Compiling with debug symbols::
* Using a different compiler::
* Compiling PETSc::
@end menu

@node Compiling with debug symbols
@subsubsection Compiling with debug symbols
@anchor{#compiling-with-debug-symbols}
By default the C flags are @code{-O3}, without debugging. To add the
@code{-g} flag, just use @code{CFLAGS} when configuring:

@smallformat
@verbatim
./configure CFLAGS="-g -O0"
@end verbatim
@end smallformat

@node Using a different compiler
@subsubsection Using a different compiler
@anchor{#using-a-different-compiler}
Without PETSc, FeenoX uses the @code{CC} environment variable to set the
compiler. So configure like

@smallformat
@verbatim
./configure CC=clang
@end verbatim
@end smallformat

When PETSc is detected FeenoX uses the @code{mpicc} executable, which is
a wrapper to an actual C compiler with extra flags needed to find the
headers and the MPI library. To change the wrapped compiler, you should
set @code{MPICH_CC} or @code{OMPI_CC}, depending if you are using MPICH
or OpenMPI. For example, to force MPICH to use @code{clang} do

@smallformat
@verbatim
./configure MPICH_CC=clang CC=clang
@end verbatim
@end smallformat

To know which is the default MPI implementation, just run
@code{configure} without arguments and pay attention to the ``Compiler''
line in the ``Summary of dependencies'' section. For example, for
OpenMPI a typical summary would be

@smallformat
@verbatim
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS                yes
  PETSc                   yes /usr/lib/petsc 
  SLEPc                   yes /usr/lib/slepc
  Compiler                gcc -I/usr/lib/x86_64-linux-gnu/openmpi/include/openmpi -I/usr/lib/x86_64-linux-gnu/openmpi/include -pthread -L/usr/lib/x86_64-linux-gnu/openmpi/lib -lmpi
@end verbatim
@end smallformat

For MPICH:

@smallformat
@verbatim
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS                yes
  PETSc                   yes /home/gtheler/libs/petsc-3.15.0 arch-linux2-c-debug
  SLEPc                   yes /home/gtheler/libs/slepc-3.15.1
  Compiler                gcc -Wl,-z,relro -I/usr/include/x86_64-linux-gnu/mpich -L/usr/lib/x86_64-linux-gnu -lmpich
@end verbatim
@end smallformat

Other non-free implementations like Intel@ MPI might work but were not
tested. However, it should be noted that the MPI implementation used to
compile FeenoX has to match the one used to compile PETSc. Therefore, if
you compiled PETSc on your own, it is up to you to ensure MPI
compatibility. If you are using PETSc as provided by your distribution's
repositories, you will have to find out which one was used (it is
usually OpenMPI) and use the same one when compiling FeenoX.

The FeenoX executable will show the configured compiler and flags when
invoked with the @code{--versions} option:

@smallformat
@verbatim
$ feenox --versions
FeenoX v0.1.47-g868dbb7-dirty 
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

Last commit date   : Mon Sep 6 16:39:53 2021 -0300
Build date         : Tue Sep 07 14:29:42 2021 -0300
Build architecture : linux-gnu x86_64
Compiler           : gcc (Debian 10.2.1-6) 10.2.1 20210110
Compiler flags     : -O3
Builder            : gtheler@tom
GSL version        : 2.6
SUNDIALS version   : 5.7.0
PETSc version      : Petsc Release Version 3.15.0, Mar 30, 2021 
PETSc arch         : arch-linux2-c-debug
PETSc options      : --download-eigen --download-hdf5 --download-hypre --download-metis --download-mumps --download-parmetis --download-pragmatic --download-scalapack --with-x=0
SLEPc version      : SLEPc Release Version 3.15.1, May 28, 2021
$
@end verbatim
@end smallformat

Note that the reported values are the ones used in @code{configure} and
not in @code{make}. Thus, the recommended way to set flags is in
@code{configure} and not in @code{make}.

@node Compiling PETSc
@subsubsection Compiling PETSc
@anchor{#compiling-petsc}
To be explained.

@node Examples
@chapter Examples
@anchor{#examples}
See @url{https://www.seamplex.com/feenox/examples}

@node Tutorial
@chapter Tutorial
@anchor{#tutorial}
See @url{https://www.seamplex.com/feenox/tutorials}

@node Description
@chapter Description
@anchor{#description}
FeenoX solves a problem defined in an plain-text input file and writes
user-defined outputs to the standard output and/or files, either also
plain-text or with a particular format for further post-processing. The
syntax of this input file is designed to be as self-describing as
possible, using English keywords that explains FeenoX what problem it
has to solve in a way is understandable by both humans and computers.
Keywords can work either as

@enumerate 
@item
Definitions, for instance ”define function@ @math{f(x)} and read its
data from file @code{f.dat}”), or as
@item
Instructions, such as ``write the stress at point @math{D} into the
standard output''.
@end enumerate

A person can tell if a keyword is a definition or an instruction because
the former are nouns (@code{FUNCTION}) and the latter verbs
(@code{PRINT}). The equal sign @code{=} is a special keyword that is
neither a verb nor a noun, and its meaning changes depending on what is
on the left hand side of the assignment.

@enumerate a
@item
If there is a function, then it is a definition: define an algebraic
function to be equal to the expression on the right-hand side, e.g.:

@smallformat
@verbatim
f(x,y) = exp(-x^2)*cos(pi*y)
@end verbatim
@end smallformat

@item
If there is a variable, vector or matrix, it is an instruction: evaluate
the expression on the right-hand side and assign it to the varible or
vector (or matrix) element indicated in the left-hand side. Strictly
speaking, if the variable has not already been defined (and implicit
declaration is allowed), then the variable is also defined as well, e.g:

@smallformat
@verbatim
VAR a
VECTOR b[3]
a = sqrt(2)
b[i] = a*i^2
@end verbatim
@end smallformat

There is no need to explicitly define the scalar variable @code{a} with
@code{VAR} since the first assigment also defines it implicitly (if this
is allowed by the keyword @code{IMPLICIT}).

@end enumerate

An input file can define its own variables as needed, such as
@code{my_var} or @code{flag}. But there are some reserved names that are
special in the sense that they either

@enumerate 
@item
can be set to modify the behavior of FeenoX, such as @code{max_dt} or
@code{dae_tol}
@item
can be read to get the internal status or results back from FeenoX, such
as @code{nodes} or @code{keff}
@item
can be either set or read, such as @code{dt} or @code{done}
@end enumerate

The problem being solved can be static or transient, depending on
whether the special variable @code{end_time} is zero (default) or not.
If it is zero and @code{static_steps} is equal to one (default), the
instructions in the input file are executed once and then FeenoX quits.
For example

@smallformat
@verbatim
VAR x
PRINT %.7f func_min(cos(x)+1,x,0,6)
@end verbatim
@end smallformat

If @code{static_steps} is larger than one, the special variable
@code{step_static} is increased and they are repeated the number of time
indicated by @code{static_steps}:

@smallformat
@verbatim
static_steps = 10
f(n) = n^2 - n + 41
PRINT f(step_static^2-1)
@end verbatim
@end smallformat

If the special variable @code{end_time} is set to a non-zero value,
after computing the static part a transient problem is solved. There are
three kinds of transient problems:

@enumerate 
@item
Plain ``standalone'' transients
@item
Differential-Algebraic equations (DAE) transients
@item
Partial Differential equations (PDE) transients
@end enumerate

In the first case, after all the instruction in the input file were
executed, the special variable @code{t} is increased by the value of
@code{dt} and then the instructions are executed all over again, until
@code{t} reaches @code{end_time}:

@smallformat
@verbatim
end_time = 2*pi
dt = 1/10

y = lag(heaviside(t-1), 1)
z = random_gauss(0, sqrt(2)/10)

PRINT t sin(t) cos(t) y z HEADER
@end verbatim
@end smallformat

In the second case, the keyword @code{PHASE_SPACE} sets up DAE system.
Then, one initial condition and one differential-algebraic equation has
to be given for each element in the phase space. The instructions before
the DAE block executed, then the DAE timestep is advanced and finally
the instructions after DAE block are executed (there cannot be any
instruction between the first and the last DAE):

@smallformat
@verbatim
PHASE_SPACE x
end_time = 1
x_0 = 1
x_dot = -x
PRINT t x exp(-t) HEADER
@end verbatim
@end smallformat

The timestep is chosen by the SUNDIALS library in order to keep an
estimate of the residual error below @code{dae_tol} (default is
@math{10^{-6}}), although @code{min_dt} and @code{max_dt} can be used to
control it. See the section of the [Differential-Algebraic Equations
subsystem] for more information.

In the third cae, the type of PDE being solved is given by the keyword
@code{PROBLEM}. Some types of PDEs do support transient problems (such
as @code{thermal}) but some others do not (such as @code{modal}). See
the detailed explanation of each problem type for details. Now the
transient problem is handled by the TS framework of the PETSc library.
In general transient PDEs involve a mesh, material properties, inital
conditions, transient boundary conditions, etc. And they create a lot of
data since results mean spatial and temporal distributions of one or
more scalar fields:

@smallformat
@verbatim
# example of a 1D heat transient problem
# from https://www.mcs.anl.gov/petsc/petsc-current/src/ts/tutorials/ex3.c.html
# a non-dimensional slab 0 < x < 1 is kept at T(0) = T(1) = 0
# there is an initial non-trivial T(x)
# the steady-state is T(x) = 0
PROBLEM thermal 1d
READ_MESH slab60.msh

end_time = 1e-1

# initial condition
T_0(x) := sin(6*pi*x) + 3*sin(2*pi*x)
# analytical solution
T_a(x,t) := exp(-36*pi^2*t)*sin(6*pi*x) + 3*exp(-4*pi^2*t)*sin(2*pi*x)

# unitary non-dimensional properties
k = 1
rho = 1
cp = 1

# boundary conditions
BC left  T=0
BC right T=0

SOLVE_PROBLEM

PRINT %e t dt T(0.1) T_a(0.1,t) T(0.7) T_a(0.7,t)
WRITE_MESH temp-slab.msh T

IF done
 PRINT "\# open temp-anim-slab.geo in Gmsh to see the result!"
ENDIF
@end verbatim
@end smallformat

PETSc's TS also honors the @code{min_dt} and @code{max_dt} variables,
but the time step is controled by the allowed relative error with the
special variable @code{ts_rtol}. Again, see the section of the [Partial
Differential Equations subsystem] for more information.

@menu
* Algebraic expressions::
* Initial conditions::
* Expansions of command line arguments::
@end menu

@node Algebraic expressions
@section Algebraic expressions
@anchor{#algebraic-expressions}
To be done.

@itemize
@item
Everything is an expression.
@end itemize

@node Initial conditions
@section Initial conditions
@anchor{#initial-conditions}

@node Expansions of command line arguments
@section Expansions of command line arguments
@anchor{#expansions-of-command-line-arguments}

@node FeenoX & the UNIX Philospohy
@chapter FeenoX & the UNIX Philospohy
@anchor{#feenox-the-unix-philospohy}

@menu
* Rule of Modularity::
* Rule of Clarity::
* Rule of Composition::
* Rule of Separation::
* Rule of Simplicity::
* Rule of Parsimony::
* Rule of Transparency::
* Rule of Robustness::
* Rule of Representation::
* Rule of Least Surprise::
* Rule of Silence::
* Rule of Repair::
* Rule of Economy::
* Rule of Generation::
* Rule of Optimization::
* Rule of Diversity::
* Rule of Extensibility::
@end menu

@node Rule of Modularity
@section Rule of Modularity
@anchor{#rule-of-modularity}
@quotation
Developers should build a program out of simple parts connected by well
defined interfaces, so problems are local, and parts of the program can
be replaced in future versions to support new features. This rule aims
to save time on debugging code that is complex, long, and unreadable.
@end quotation
@itemize
@item
FeenoX uses third-party high-quality libraries
@itemize
@item
GNU Scientific Library
@item
SUNDIALS
@item
PETSc
@item
SLEPc
@end itemize

@end itemize

@node Rule of Clarity
@section Rule of Clarity
@anchor{#rule-of-clarity}
@quotation
Developers should write programs as if the most important communication
is to the developer who will read and maintain the program, rather than
the computer. This rule aims to make code as readable and comprehensible
as possible for whoever works on the code in the future.
@end quotation
@itemize
@item
Example two squares in thermal contact.
@item
LE10 & LE11: a one-to-one correspondence between the problem text and
the FeenoX input.
@end itemize

@node Rule of Composition
@section Rule of Composition
@anchor{#rule-of-composition}
@quotation
Developers should write programs that can communicate easily with other
programs. This rule aims to allow developers to break down projects into
small, simple programs rather than overly complex monolithic programs.
@end quotation
@itemize
@item
FeenoX uses meshes created by a separate mesher (i.e.@ Gmsh).
@item
FeenoX writes data that has to be plotted or post-processed by other
tools (Gnuplot, Gmsh, Paraview, etc.).
@item
ASCII output is 100% controlled by the user so it can be tailored to
suit any other programs' input needs such as AWK filters to create LaTeX
tables.
@end itemize

@node Rule of Separation
@section Rule of Separation
@anchor{#rule-of-separation}
@quotation
Developers should separate the mechanisms of the programs from the
policies of the programs; one method is to divide a program into a
front-end interface and a back-end engine with which that interface
communicates. This rule aims to prevent bug introduction by allowing
policies to be changed with minimum likelihood of destabilizing
operational mechanisms.
@end quotation
@itemize
@item
FeenoX does not include a GUI, but it is GUI-friendly.
@end itemize

@node Rule of Simplicity
@section Rule of Simplicity
@anchor{#rule-of-simplicity}
@quotation
Developers should design for simplicity by looking for ways to break up
program systems into small, straightforward cooperating pieces. This
rule aims to discourage developers' affection for writing ``intricate
and beautiful complexities'' that are in reality bug prone programs.
@end quotation
@itemize
@item
Simple problems need simple input.
@item
Similar problems need similar inputs.
@item
English-like self-evident input files matching as close as possible the
problem text.
@item
If there is a single material there is no need to link volumes to
properties.
@end itemize

@node Rule of Parsimony
@section Rule of Parsimony
@anchor{#rule-of-parsimony}
@quotation
Developers should avoid writing big programs. This rule aims to prevent
overinvestment of development time in failed or suboptimal approaches
caused by the owners of the program's reluctance to throw away visibly
large pieces of work. Smaller programs are not only easier to write,
optimize, and maintain; they are easier to delete when deprecated.
@end quotation
@itemize
@item
Parametric and/or optimization runs have to be driven from an outer
script (Bash, Python, etc.)
@end itemize

@node Rule of Transparency
@section Rule of Transparency
@anchor{#rule-of-transparency}
@quotation
Developers should design for visibility and discoverability by writing
in a way that their thought process can lucidly be seen by future
developers working on the project and using input and output formats
that make it easy to identify valid input and correct output. This rule
aims to reduce debugging time and extend the lifespan of programs.
@end quotation
@itemize
@item
Written in C99
@end itemize

@node Rule of Robustness
@section Rule of Robustness
@anchor{#rule-of-robustness}
@quotation
Developers should design robust programs by designing for transparency
and discoverability, because code that is easy to understand is easier
to stress test for unexpected conditions that may not be foreseeable in
complex programs. This rule aims to help developers build robust,
reliable products.
@end quotation

@node Rule of Representation
@section Rule of Representation
@anchor{#rule-of-representation}
@quotation
Developers should choose to make data more complicated rather than the
procedural logic of the program when faced with the choice, because it
is easier for humans to understand complex data compared with complex
logic. This rule aims to make programs more readable for any developer
working on the project, which allows the program to be maintained.
@end quotation

@node Rule of Least Surprise
@section Rule of Least Surprise
@anchor{#rule-of-least-surprise}
@quotation
Developers should design programs that build on top of the potential
users' expected knowledge; for example, `+' in a calculator program
should always mean `addition'. This rule aims to encourage developers to
build intuitive products that are easy to use.
@end quotation
@itemize
@item
If one needs a problem where the conductivity depends on@ @math{x} as
@math{k(x)=1+x} then the input is

@smallformat
@verbatim
k(x) = 1+x
@end verbatim
@end smallformat

@item
If a problem needs a temperature distribution given by an algebraic
expression @math{T(x,y,z)=\sqrt{x^2+y^2}+z} then do

@smallformat
@verbatim
T(x,y,z) = sqrt(x^2+y^2) + z
@end verbatim
@end smallformat

@end itemize

@node Rule of Silence
@section Rule of Silence
@anchor{#rule-of-silence}
@quotation
Developers should design programs so that they do not print unnecessary
output. This rule aims to allow other programs and developers to pick
out the information they need from a program's output without having to
parse verbosity.
@end quotation
@itemize
@item
No @code{PRINT} no output.
@end itemize

@node Rule of Repair
@section Rule of Repair
@anchor{#rule-of-repair}
@quotation
Developers should design programs that fail in a manner that is easy to
localize and diagnose or in other words ``fail noisily''. This rule aims
to prevent incorrect output from a program from becoming an input and
corrupting the output of other code undetected.
@end quotation
Input errors are detected before the computation is started and run-time
errors (i.e.@ a division by zero) con be user controled, they can be
fatal or ignored.

@node Rule of Economy
@section Rule of Economy
@anchor{#rule-of-economy}
@quotation
Developers should value developer time over machine time, because
machine cycles today are relatively inexpensive compared to prices in
the 1970s. This rule aims to reduce development costs of projects.
@end quotation
@itemize
@item
Output is 100% user-defined so the desired results is directly obtained
instead of needing further digging into tons of undesired data.The
approach of ``compute and write everything you can in one single run''
made sense in 1970 where CPU time was more expensive than human time,
but not anymore.
@item
Example: LE10 & LE11.
@end itemize

@node Rule of Generation
@section Rule of Generation
@anchor{#rule-of-generation}
@quotation
Developers should avoid writing code by hand and instead write abstract
high-level programs that generate code. This rule aims to reduce human
errors and save time.
@end quotation
@itemize
@item
Inputs are M4-friendly.
@item
Parametric runs can be done from scripts through command line arguments
expansion.
@item
Documentation is created out of simple Markdown sources and assembled as
needed.
@end itemize

@node Rule of Optimization
@section Rule of Optimization
@anchor{#rule-of-optimization}
@quotation
Developers should prototype software before polishing it. This rule aims
to prevent developers from spending too much time for marginal gains.
@end quotation
@itemize
@item
Premature optimization is the root of all evil
@item
We are still building. We will optimize later.
@itemize
@item
Code optimization: TODO
@item
Parallelization: TODO
@item
Comparison with other tools: TODO
@end itemize

@end itemize

@node Rule of Diversity
@section Rule of Diversity
@anchor{#rule-of-diversity}
@quotation
Developers should design their programs to be flexible and open. This
rule aims to make programs flexible, allowing them to be used in ways
other than those their developers intended.
@end quotation
@itemize
@item
Either Gmsh or Paraview can be used to post-process results.
@item
Other formats can be added.
@end itemize

@node Rule of Extensibility
@section Rule of Extensibility
@anchor{#rule-of-extensibility}
@quotation
Developers should design for the future by making their protocols
extensible, allowing for easy plugins without modification to the
program's architecture by other developers, noting the version of the
program, and more. This rule aims to extend the lifespan and enhance the
utility of the code the developer writes.
@end quotation
@itemize
@item
FeenoX is GPLv3+. The `+' is for the future.
@item
Each PDE has a separate source directory. Any of them can be used as a
template for new PDEs, especially @code{laplace} for elliptic operators.
@end itemize

@bye
