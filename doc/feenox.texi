\input texinfo
@documentencoding UTF-8

@setfilename feenox.info
@c @include version.texi
@set UPDATED 
@set VERSION 

@copying
This manual is for feenox (version @value{VERSION}, @value{UPDATED}),
which is a completely free-as-in-freedom finite-element
thermo-mechancial solver desinged and implemented following the UNIX
principles.

Copyright @copyright{} 2016-2021 Jeremy Theler.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title FeenoX manual
@subtitle A free no-fee no-X uniX-like finite-element(ish) computational
engineering tool, 
@author Jeremy Theler
@end titlepage

@contents

@node Top
@top FeenoX manual

@menu
* Overview::
* Introduction::
* Running feenox::
* Examples::
* Tutorial::
* Description::
* Reference::
* FeenoX & the UNIX Philospohy::
* History::
@end menu

@node Overview
@chapter Overview
@anchor{#overview}
FeenoX is a computational tool that can solve engineering problems which
are usually casted as differential-algebraic equations (DAEs) or partial
differential equations (PDEs). It is to finite elements programs and
libraries what Markdown is to Word and TeX, respectively. In particular,
it can solve

@itemize
@item
dynamical systems defined by a set of user-provided DAEs (such as plant
control dynamics for example)
@item
mechanical elasticity
@item
heat conduction
@item
structural modal analysis
@item
neutron diffusion
@item
neutron transport
@end itemize

FeenoX reads a plain-text input file which contains the problem
definition and writes 100%-user defined results in ASCII (through
@code{PRINT} or other user-defined output instructions within the input
file). For PDE problems, it needs a reference to at least one
@uref{http://gmsh.info/,Gmsh} mesh file for the discretization of the
domain. It can write post-processing views in either @code{.msh} or
@code{.vtk} formats.

Keep in mind that FeenoX is just a back end reading a set of input files
and writing a set of output files following the design philosophy of
UNIX (separation, composition, representation, economy, extensibility,
etc). Think of it as a transfer function between input files and output
files:

@smallformat
@verbatim
                             +------------+
 mesh (*.msh)  }             |            |             { terminal
 data (*.dat)  } input ----> |   FeenoX   |----> output { data files
 input (*.fee) }             |            |             { post (vtk/msh)
                             +------------+
@end verbatim
@end smallformat

Following the UNIX programming philosophy, there are no graphical
interfaces attached to the FeenoX core, although a wide variety of pre
and post-processors can be used with FeenoX. See for example
@url{https://www.caeplex.com} for a web-based interface.

@node Introduction
@chapter Introduction
@anchor{#introduction}
@uref{https://www.seamplex.com/feenox,FeenoX} is to finite-element
software and libraries what Markdown is to word processors and
typesetting systems. It can be seen as

@itemize
@item
a syntactically-sweetened way of asking the computer to solve
engineering-related mathematical problems, and/or
@item
a finite-element(ish) tool with a particular design basis
@end itemize

Note that some of the problems solved with FeenoX might not actually
rely on the finite element method, but on general mathematical models
and even on the finite volumes method. That is why we say it is a
finite-element(ish) tool.

@quotation
@itemize
@item
FeenoX Overview Presentation, August 2021
@itemize
@item
@uref{https://youtu.be/-RJ5qn7E9uE,Recording (audio in Spanish, slides
in English)}
@item
@uref{https://www.seamplex.com/feenox/doc/2021-feenox.pdf,Slides in PDF}
@item
@uref{https://github.com/gtheler/2021-presentation,Markdown examples
sources}
@end itemize

@end itemize

@end quotation
One of the main features of this allegedly particular design basis is
that @strong{simple problems ought to have simple inputs} (@emph{rule of
simplicity}). For instance, to solve one-dimensional heat conduction
over the domain @math{x\in[0,1]} (which is indeed one of the most simple
engineering problems we can find) the following input file is enough:

@smallformat
@verbatim
READ_MESH slab.msh               # read mesh in Gmsh's v4.1 format
PROBLEM thermal DIMENSIONS 1     # tell FeenoX what we want to solve 
k = 1                            # set uniform conductivity
BC left  T=0                     # set fixed temperatures as BCs
BC right T=1                     # "left" and "right" are defined in the mesh
SOLVE_PROBLEM                    # tell FeenoX we are ready to solve the problem
PRINT T(0.5)                     # ask for the temperature at x=0.5
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox thermal-1d-dirichlet-constant-k.fee 
0.5
$ 
@end verbatim
@end smallformat

The mesh is assumed to have been already created with
@uref{http://gmsh.info/,Gmsh} (or any other pre-processing tool and
converted to @code{.msh} format with
@uref{https://github.com/nschloe/meshio,Meshio} for example). This
assumption follows the @emph{rule of composition} and prevents the
actual input file to be polluted with mesh-dependent data (such as node
coordinates and/or nodal loads) so as to keep it simple and make it
@uref{https://git-scm.com/,Git}-friendly (@emph{rule of generation}).
The only link between the mesh and the FeenoX input file is through
physical groups (in the case above @code{left} and @code{right}) used to
set boundary conditions and/or material properties.

Another design-basis decision is that @strong{similar problems ought to
have similar inputs} (@emph{rule of least surprise}). So in order to
have a space-dependent conductivity, we only have to replace one line in
the input above: instead of defining a scalar @math{k} we define a
function of @math{x} (we also update the output to show the analytical
solution as well):

@smallformat
@verbatim
READ_MESH slab.msh
PROBLEM thermal DIMENSIONS 1
k(x) = 1+x                       # space-dependent conductivity
BC left  T=0
BC right T=1
SOLVE_PROBLEM
PRINT T(1/2) log(1+1/2)/log(2)   # print numerical and analytical solutions
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox thermal-1d-dirichlet-space-k.fee 
0.584959	0.584963
$
@end verbatim
@end smallformat

FeenoX has an @strong{everything is an expression} design principle,
meaning that any numerical input can be an algebraic expression
(e.g.@ @code{T(1/2)} is the same as @code{T(0.5)}). If we want to have a
temperature-dependent conductivity (which renders the problem
non-linear) we can take advantage of the fact that @math{T(x)} is
available not only as an argument to @code{PRINT} but also for the
definition of algebraic functions:

@smallformat
@verbatim
READ_MESH slab.msh
PROBLEM thermal DIMENSIONS 1
k(x) = 1+T(x)                    # temperature-dependent conductivity
BC left  T=0
BC right T=1
SOLVE_PROBLEM
PRINT T(1/2) sqrt(1+(3*0.5))-1   # print numerical and analytical solutions
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox thermal-1d-dirichlet-temperature-k.fee 
0.581139	0.581139
$
@end verbatim
@end smallformat

For example, we can solve the
@uref{https://www.nafems.org/publications/resource_center/p18/,NAFEMS@ LE11}
``Solid cylinder/Taper/Sphere-Temperature'' benchmark like

@smallformat
@verbatim
READ_MESH nafems-le11.msh DIMENSIONS 3
PROBLEM mechanical

# linear temperature gradient in the radial and axial direction
T(x,y,z) = sqrt(x^2 + y^2) + z

# Boundary conditions
BC xz     symmetry  # same as v=0 but "symmetry" follows the statement
BC yz     symmetry  # ide with u=0
BC xy     w=0
BC HIH'I' w=0

# material properties (isotropic & uniform so we can use scalar constants)
E = 210e3*1e6       # mesh is in meters, so E=210e3 MPa -> Pa
nu = 0.3            # dimensionless
alpha = 2.3e-4      # in 1/ºC as in the problem

SOLVE_PROBLEM
WRITE_MESH nafems-le11.vtk VECTOR u v w   T sigma1 sigma2 sigma3 sigma sigmaz
PRINT "sigma_z(A) = " sigmaz(0,1,0)/1e6 "MPa"
@end verbatim
@end smallformat

Another example would be the famous chaotic
@uref{http://en.wikipedia.org/wiki/Lorenz_system,Lorenz' dynamical
system}---the one of the butterfly---whose differential equations are

@math{\dot{x} = \sigma \cdot (y - x)}
@math{\dot{y} = x \cdot (r - z) - y}
@math{\dot{z} = x \cdot y - b \cdot z}
where @math{\sigma=10}, @math{b=8/3} and @math{r=28} are the classical
parameters that generate the butterfly as presented by Edward Lorenz
back in his seminal 1963 paper
@uref{http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2,Deterministic
non-periodic flow}. We can solve it with FeenoX by writing the equations
in the input file as naturally as possible, as illustrated in the input
file that follows:

@smallformat
@verbatim
PHASE_SPACE x y z     # Lorenz attractor’s phase space is x-y-z
end_time = 40         # we go from t=0 to 40 non-dimensional units

sigma = 10            # the original parameters from the 1963 paper
r = 28
b = 8/3

x_0 = -11             # initial conditions
y_0 = -16
z_0 = 22.5

# the dynamical system's equations written as naturally as possible
x_dot = sigma*(y - x)
y_dot = x*(r - z) - y
z_dot = x*y - b*z

PRINT t x y z        # four-column plain-ASCII output
@end verbatim
@end smallformat

Please note the following two points about both cases above:

@enumerate 
@item
The input files are very similar to the statements of each problem in
plain English words (@emph{rule of clarity}). Take some time to read the
@uref{doc/design/nafems-le11/nafems-le11.png,problem statement of the
NAFEMS@ LE11 benchmark} and the FeenoX input to see how well the latter
matches the former. Same for the Lorenz' chaotic system. Those with some
experience may want to compare them to the inputs decks (sic) needed for
other common FEA programs.
@item
By design, 100% of FeenoX' output is controlled by the user. Had there
not been any @code{PRINT} or @code{WRITE_MESH} instructions, the output
would have been empty, following the @emph{rule of silence}. This is a
significant change with respect to traditional engineering codes that
date back from times when one CPU hour was worth dozens (or even
hundreds) of engineering hours. At that time, cognizant engineers had to
dig into thousands of lines of data to search for a single individual
result. Nowadays, following the @emph{rule of economy}, it is actually
far easier to ask the code to write only what is needed in the
particular format that suits the user.
@end enumerate

In other words, FeenoX is a computational tool to solve

@itemize
@item
dynamical systems written as sets of ODEs/DAEs, or
@item
steady or quasi-static thermo-mechanical problems, or
@item
steady or transient heat conduction problems, or
@item
modal analysis problems,
@item
neutron diffusion or transport problems
@item
community-contributed problems
@end itemize

in such a way that the input is a near-English text file that defines
the problem to be solved. Some basic rules are

@itemize
@item
FeenoX is just a @strong{solver} working as a @emph{transfer function}
between input and output files. Following the @emph{rules of separation,
parsimony and diversity}, @strong{there is no embedded graphical
interface} but means of using generic pre and post processing tools---in
particular, @uref{http://gmsh.info/,Gmsh} and
@uref{https://www.paraview.org/,Paraview} respectively. See also
@uref{www.caeplex.com,CAEplex}.
@end itemize

@itemize
@item
The input files should be
@uref{https://en.wikipedia.org/wiki/Syntactic_sugar,syntactically
sugared} so as to be as self-describing as possible.

@item
Simple problems ought to need simple input files.

@item
Similar problems ought to need similar input files.

@item
Everything is an expression. Whenever a number is expected, an algebraic
expression can be entered as well. Variables, vectors, matrices and
functions are supported. Here is how to replace the boundary condition
on the right side of the slab above with a radiation condition:

@smallformat
@verbatim
sigma = 1       # non-dimensional stefan-boltzmann constant
e = 0.8         # emissivity 
Tinf=1          # non-dimensional reference temperature
BC right q=sigma*e*(Tinf^4-T(x)^4)
@end verbatim
@end smallformat

@end itemize

@itemize
@item
FeenoX should run natively in the cloud and be able to massively scale
in parallel. See the @uref{doc/sds.md,Software Requirements
Specification} and the @uref{doc/sds.md,Software Development
Specification} for details.
@end itemize

Since it is free
(@uref{https://www.gnu.org/philosophy/free-sw.en.html,as in freedom})
and open source, contributions to add features (and to fix bugs) are
welcome. In particular, each kind of problem supported by FeenoX
(thermal, mechanical, modal, etc.) has a subdirectory of source files
which can be used as a template to add new problems, as implied in the
``community-contributed problems'' bullet above (@emph{rules of
modularity and extensibility}). See the @uref{doc,documentation} for
details about how to contribute.

@node Running feenox
@chapter Running @code{feenox}
@anchor{#running-feenox}

@menu
* Invocation::
* Compilation::
@end menu

@node Invocation
@section Invocation
@anchor{#invocation}
The format for running the @code{feenox} program is:

@smallformat
@verbatim
feenox [options] inputfile [optional_extra_arguments] ...
@end verbatim
@end smallformat

The @code{feenox} executable supports the following options:

@table @asis
@item @code{-h}, @code{--help}

display usage and commmand-line help and exit

@item @code{-v}, @code{--version}

display brief version information and exit

@item @code{-V}, @code{--versions}

display detailed version information

@end table

Instructions will be read from standard input if ``-'' is passed as
inputfile, i.e.

@smallformat
@verbatim
$ echo 'PRINT 2+2' | feenox -
4
@end verbatim
@end smallformat

PETSc and SLEPc options can be passed in @code{[options]} as well, with
the difference that two hyphens have to be used instead of only once.
For example, to pass the PETSc option @code{-ksp_view} the actual FeenoX
invocation should be

@smallformat
@verbatim
$ feenox --ksp_view input.fee
@end verbatim
@end smallformat

The optional @code{[replacement arguments]} part of the command line
mean that each argument after the input file that does not start with an
hyphen will be expanded verbatim in the input file in each occurrence of
@code{$1}, @code{$2}, etc. For example

@smallformat
@verbatim
$ echo 'PRINT $1+$2' | feenox - 3 4
7
@end verbatim
@end smallformat

@node Compilation
@section Compilation
@anchor{#compilation}
These detailed compilation instructions are aimed at @code{amd64}
Debian-based GNU/Linux distributions. The compilation procedure follows
POSIX, so it should work in other operating systems and architectures as
well. Distributions not using @code{apt} for packages (i.e.@ @code{yum})
should change the package installation commands (and possibly the
package names). The instructions should also work for in MacOS, although
the @code{apt-get} commands should be replaced by @code{brew} or
similar. Same for Windows under @uref{https://www.cygwin.com/,Cygwin},
the packages should be installed through the Cygwin installer. WSL was
not tested, but should work as well.

@menu
* Quickstart::
* Detailed configuration and compilation::
* Advanced settings::
@end menu

@node Quickstart
@subsection Quickstart
@anchor{#quickstart}
Note that the quickest way to get started is to get an already-compiled
statically-linked binary executable. Follow these instructions if that
option is not suitable for your workflow.

On a GNU/Linux box (preferably Debian-based), follow these quick steps.
See next section for detailed explanations.

@enumerate 
@item
Install mandatory dependencies

@smallformat
@verbatim
sudo apt-get install gcc make git automake autoconf libgsl-dev
@end verbatim
@end smallformat

If you cannot install @code{libgsl-dev} but still have @code{git} and
the build toolchain, you can have the @code{configure} script to
download and compile it for you. See point@ 4 below.

@item
Install optional dependencies (of course these are @emph{optional} but
recommended)

@smallformat
@verbatim
sudo apt-get install libsundials-dev petsc-dev slepc-dev
@end verbatim
@end smallformat

@item
Clone Github repository

@smallformat
@verbatim
git clone https://github.com/seamplex/feenox
@end verbatim
@end smallformat

@item
Boostrap, configure, compile & make

@smallformat
@verbatim
cd feenox
./autogen.sh
./configure
make
@end verbatim
@end smallformat

If you cannot (or do not want) to use @code{libgsl-dev} from a package
repository, call @code{configure} with @code{--enable-download-gsl}:

@smallformat
@verbatim
./configure --enable-download-gsl
@end verbatim
@end smallformat

If you do not have Internet access, get the tarball manually, copy it to
the same directory as @code{configure} and run again.

@item
Run test suite (optional)

@smallformat
@verbatim
make check
@end verbatim
@end smallformat

@item
Install the binary system wide (optional)

@smallformat
@verbatim
sudo make install
@end verbatim
@end smallformat

@end enumerate

@node Detailed configuration and compilation
@subsection Detailed configuration and compilation
@anchor{#detailed-configuration-and-compilation}
The main target and development environment is Debian@ GNU/Linux,
although it should be possible to compile FeenoX in any free GNU/Linux
variant (and even the in non-free MacOS and Windows). As per the
@uref{SRS.md,SRS}, all dependencies have to be available on mainstream
GNU/Linux distributions. But they can also be compiled from source in
case the package repositories are not available or customized
compilation flags are needed (i.e.@ optimization or debugging settings).

All the dependencies are free and open source software. PETSc/SLEPc also
depend on other mathematical libraries to perform particular operations
such as linear algebra. These extra dependencies can be either free
(such as LAPACK) or non-free (such as MKL), but there is always at least
one combination of a working setup that involves only free and open
source software which is compatible with FeenoX licensing terms
(GPLv3+). See the documentation of each package for licensing details.

@menu
* Mandatory dependencies::
* Optional dependencies::
* FeenoX source code::
* Configuration::
* Compilation::
* Test suite::
* Install::
@end menu

@node Mandatory dependencies
@subsubsection Mandatory dependencies
@anchor{#mandatory-dependencies}
FeenoX has one mandatory dependency for run-time execution and the
standard build toolchain for compilation. It is written in C99 so only a
C compiler is needed, although @code{make} is also required. Free and
open source compilers are favored. The usual C compiler is @code{gcc}
but @code{clang} can also be used. Nevertheless, the non-free @code{icc}
has also been tested.

Note that there is no need to have a Fortran nor a C++ compiler to build
FeenoX. They might be needed to build other dependencies (such as
PETSc), but not to compile FeenoX with all the dependencies installed
from package repositories. In case the build toolchain is not already
installed, do so with

@smallformat
@verbatim
sudo apt-get install gcc make
@end verbatim
@end smallformat

If the source is to be fetched from the Git repository then of course
@code{git} is needed but also @code{autoconf} and @code{automake} since
the @code{configure} script is not stored in the Git repository but the
@code{autogen.sh} script that bootstraps the tree and creates it. So if
instead of compiling a source tarball one wants to clone from GitHub,
these packages are also mandatory:

@smallformat
@verbatim
sudo apt-get install git automake autoconf
@end verbatim
@end smallformat

Again, chances are that any existing GNU/Linux box has all these tools
already installed.
The GNU Scientific Library
The only run-time dependency is
@uref{https://www.gnu.org/software/gsl/,GNU GSL} (not to be confused
with @uref{https://github.com/microsoft/GSL,Microsoft GSL}). It can be
installed with

@smallformat
@verbatim
sudo apt-get install libgsl-dev
@end verbatim
@end smallformat

In case this package is not available or you do not have enough
permissions to install system-wide packages, there are two options.

@enumerate 
@item
Pass the option @code{--enable-download-gsl} to the @code{configure}
script below.
@item
Manually download, compile and install
@uref{https://www.gnu.org/software/gsl/,GNU GSL}
@end enumerate

If the @code{configure} script cannot find both the headers and the
actual library, it will refuse to proceed. Note that the FeenoX binaries
already contain a static version of the GSL so it is not needed to have
it installed in order to run the statically-linked binaries.

@node Optional dependencies
@subsubsection Optional dependencies
@anchor{#optional-dependencies}
FeenoX has three optional run-time dependencies. It can be compiled
without any of these but functionality will be reduced:

@itemize
@item
@uref{https://computing.llnl.gov/projects/sundials,SUNDIALS} provides
support for solving systems of ordinary differential equations (ODEs) or
differential-algebraic equations (DAEs). This dependency is needed when
running inputs with the @code{PHASE_SPACE} keyword.

@item
@uref{https://petsc.org/,PETSc} provides support for solving partial
differential equations (PDEs). This dependency is needed when running
inputs with the @code{PROBLEM} keyword.

@item
@uref{https://slepc.upv.es/,SLEPc} provides support for solving
eigen-value problems in partial differential equations (PDEs). This
dependency is needed for inputs with @code{PROBLEM} types with
eigen-value formulations such as @code{modal} and
@code{neutron_transport}.

@end itemize

In absence of all these, FeenoX can still be used to

@itemize
@item
solve general mathematical problems such as the ones to compute the
Fibonacci sequence,
@item
operate on functions, either algebraically or point-wise interpolated,
@item
read, operate over and write meshes,
@item
etc.
@end itemize

These optional dependencies have to be installed separately. There is no
option to have @code{configure} to download them as with
@code{--enable-download-gsl}.
SUNDIALS
@uref{https://computing.llnl.gov/projects/sundials,SUNDIALS} is a SUite
of Nonlinear and DIfferential/ALgebraic equation Solvers. It is used by
FeenoX to solve dynamical systems casted as DAEs with the keyword
`PHASE_SPACE, like the Lorenz system.

Install either by doing

@smallformat
@verbatim
sudo apt-get install libsundials-dev
@end verbatim
@end smallformat

@tex
\noindent 
@end tex or by following the instructions in the documentation.
PETSc
@uref{https://petsc.org/,PETSc}, the Portable, Extensible Toolkit for
Scientific Computation, pronounced PET-see (/ˈpɛt-siː/), is a suite of
data structures and routines for the scalable (parallel) solution of
scientific applications modeled by partial differential equations. It is
used by FeenoX to solve PDEs with the keyword @code{PROBLEM}, like
thermal conduction on a slab.

Install either by doing

@smallformat
@verbatim
sudo apt-get install petsc-dev
@end verbatim
@end smallformat

@tex
\noindent 
@end tex or by following the instructions in the documentation.

Note that

@itemize
@item
Configuring and compiling PETSc from scratch might be difficult the
first time. It has a lot of dependencies and options. Read the official
@uref{https://petsc.org/release/install/,documentation} for a detailed
explanation.
@item
There is a huge difference in efficiency between using PETSc compiled
with debugging symbols and with optimization flags. Make sure to
configure @code{--with-debugging=0} for FeenoX production runs and leave
the debugging symbols (which is the default) for development only.
@item
FeenoX needs PETSc to be configured with real double-precision scalars.
It will compile but will complain at run-time when using complex and/or
single or quad-precision scalars.
@item
FeenoX honors the @code{PETSC_DIR} and @code{PETSC_ARCH} environment
variables when executing @code{configure}. If these two do not exist or
are empty, it will try to use the default system-wide locations
(i.e.@ the @code{petsc-dev} package).
@end itemize

SLEPc
@uref{https://slepc.upv.es/,SLEPc}, the Scalable Library for Eigenvalue
Problem Computations, is a software library for the solution of large
scale sparse eigenvalue problems on parallel computers. It is used by
FeenoX to solve PDEs with the keyword @code{PROBLEM} that need
eigen-value computations, such as modal analysis of a cantilevered beam.

Install either by doing

@smallformat
@verbatim
sudo apt-get install slepc-dev
@end verbatim
@end smallformat

@tex
\noindent 
@end tex or by following the instructions in the documentation.

Note that

@itemize
@item
SLEPc is an extension of PETSc so the latter has to be already installed
and configured.
@item
FeenoX honors the @code{SLEPC_DIR} environment variable when executing
@code{configure}. If it does not exist or is empty it will try to use
the default system-wide locations (i.e.@ the @code{slepc-dev} package).
@item
If PETSc was configured with @code{--download-slepc} then the
@code{SLEPC_DIR} variable has to be set to the directory inside
@code{PETSC_DIR} where SLEPc was cloned and compiled.
@end itemize

@node FeenoX source code
@subsubsection FeenoX source code
@anchor{#feenox-source-code}
There are two ways of getting FeenoX' source code:

@enumerate 
@item
Cloning the GitHub repository at
@url{https://github.com/seamplex/feenox}
@item
Downloading a source tarball from
@url{https://seamplex.com/feenox/dist/src/}
@end enumerate

Git repository
The main Git repository is hosted on GitHub at
@url{https://github.com/seamplex/feenox}. It is public so it can be
cloned either through HTTPS or SSH without needing any particular
credentials. It can also be forked freely. See the
@uref{programming.md,Programming Guide} for details about pull requests
and/or write access to the main repository.

Ideally, the @code{main} branch should have a usable snapshot. All other
branches might contain code that might not compile or might not run or
might not be tested. If you find a commit in the main branch that does
not pass the tests, please report it in the issue tracker ASAP.

After cloning the repository

@smallformat
@verbatim
git clone https://github.com/seamplex/feenox
@end verbatim
@end smallformat

@tex
\noindent
@end tex the @code{autogen.sh} script has to be called to bootstrap the
working tree, since the @code{configure} script is not stored in the
repository but created from @code{configure.ac} (which is in the
repository) by @code{autogen}.

Similarly, after updating the working tree with

@smallformat
@verbatim
git pull
@end verbatim
@end smallformat

@tex
\noindent
@end tex it is recommended to re-run the @code{autogen.sh} script. It
will do a @code{make clean} and re-compute the version string.
Source tarballs
When downloading a source tarball, there is no need to run
@code{autogen.sh} since the @code{configure} script is already included
in the tarball. This method cannot update the working tree. For each new
FeenoX release, the whole tarball has to be downloaded again.

@node Configuration
@subsubsection Configuration
@anchor{#configuration}
To create a proper @code{Makefile} for the particular architecture,
dependencies and compilation options, the script @code{configure} has to
be executed. This procedure follows the
@uref{https://www.gnu.org/prep/standards/,GNU Coding Standards}.

@smallformat
@verbatim
./configure
@end verbatim
@end smallformat

Without any particular options, @code{configure} will check if the
mandatory @uref{https://www.gnu.org/software/gsl/,GNU Scientific
Library} is available (both its headers and run-time library). If it is
not, then the option @code{--enable-download-gsl} can be used. This
option will try to use @code{wget} (which should be installed) to
download a source tarball, uncompress is, configure and compile it. If
these steps are successful, this GSL will be statically linked into the
resulting FeenoX executable. If there is no internet connection, the
@code{configure} script will say that the download failed. In that case,
get the indicated tarball file manually , copy it into the current
directory and re-run @code{./configure}.

The script will also check for the availability of optional
dependencies. At the end of the execution, a summary of what was found
(or not) is printed in the standard output:

@smallformat
@verbatim
$ ./configure
[...]
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS IDA            yes
  PETSc                   yes /usr/lib/petsc 
  SLEPc                   no
[...]  
@end verbatim
@end smallformat

If for some reason one of the optional dependencies is available but
FeenoX should not use it, then pass @code{--without-sundials},
@code{--without-petsc} and/or @code{--without-slepc} as arguments. For
example

@smallformat
@verbatim
$ ./configure --without-sundials --without-petsc
[...]
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS                no
  PETSc                   no
  SLEPc                   no
[...]  
@end verbatim
@end smallformat

If configure complains about contradicting values from the cached ones,
run @code{autogen.sh} again before @code{configure} or uncompress the
source tarball in a fresh location.

To see all the available options run

@smallformat
@verbatim
./configure --help
@end verbatim
@end smallformat

@node Compilation
@subsubsection Compilation
@anchor{#compilation}
After the successful execution of @code{configure}, a @code{Makefile} is
created. To compile FeenoX, just execute

@smallformat
@verbatim
make
@end verbatim
@end smallformat

Compilation should take a dozen of seconds. It can be even sped up by
using the @code{-j} option

@smallformat
@verbatim
make -j8
@end verbatim
@end smallformat

The binary executable will be located in the @code{src} directory but a
copy will be made in the base directory as well. Test it by running
without any arguments

@smallformat
@verbatim
$ ./feenox
FeenoX v0.1.24-g6cfe063 
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

usage: ./feenox [options] inputfile [replacement arguments]

  -h, --help         display usage and commmand-line help and exit
  -v, --version      display brief version information and exit
  -V, --versions     display detailed version information
  -s, --sumarize     list all symbols in the input file and exit

Instructions will be read from standard input if “-” is passed as
inputfile, i.e.

    $ echo "PRINT 2+2" | feenox -
    4

Report bugs at https://github.com/seamplex/feenox or to jeremy@seamplex.com
Feenox home page: https://www.seamplex.com/feenox/
$
@end verbatim
@end smallformat

The @code{-v} (or @code{--version}) option shows the version and a
copyright notice:

@smallformat
@verbatim
$ ./feenox -v
FeenoX v0.1.24-g6cfe063
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

Copyright (C) 2009--2021 jeremy theler
GNU General Public License v3+, https://www.gnu.org/licenses/gpl.html. 
FeenoX is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
$
@end verbatim
@end smallformat

The @code{-V} (or @code{--versions}) option shows the dates of the last
commits, the compiler options and the versions of the linked libraries:

@smallformat
@verbatim
$ ./feenox -V
FeenoX v0.1.24-g6cfe063
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

Last commit date   : Sun Aug 29 11:34:04 2021 -0300
Build date         : Sun Aug 29 11:44:50 2021 -0300
Build architecture : linux-gnu x86_64
Compiler           : gcc (Ubuntu 10.3.0-1ubuntu1) 10.3.0
Compiler flags     : -O3
Builder            : gtheler@chalmers
GSL version        : 2.6
SUNDIALS version   : 4.1.0
PETSc version      : Petsc Release Version 3.14.5, Mar 03, 2021 
PETSc arch         : 
PETSc options      : --build=x86_64-linux-gnu --prefix=/usr --includedir=${prefix}/include --mandir=${prefix}/share/man --infodir=${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --with-option-checking=0 --with-silent-rules=0 --libdir=${prefix}/lib/x86_64-linux-gnu --runstatedir=/run --with-maintainer-mode=0 --with-dependency-tracking=0 --with-debugging=0 --shared-library-extension=_real --with-shared-libraries --with-pic=1 --with-cc=mpicc --with-cxx=mpicxx --with-fc=mpif90 --with-cxx-dialect=C++11 --with-opencl=1 --with-blas-lib=-lblas --with-lapack-lib=-llapack --with-scalapack=1 --with-scalapack-lib=-lscalapack-openmpi --with-ptscotch=1 --with-ptscotch-include=/usr/include/scotch --with-ptscotch-lib="-lptesmumps -lptscotch -lptscotcherr" --with-fftw=1 --with-fftw-include="[]" --with-fftw-lib="-lfftw3 -lfftw3_mpi" --with-superlu_dist=1 --with-superlu_dist-include=/usr/include/superlu-dist --with-superlu_dist-lib=-lsuperlu_dist --with-hdf5-include=/usr/include/hdf5/openmpi --with-hdf5-lib="-L/usr/lib/x86_64-linux-gnu/hdf5/openmpi -L/usr/lib/x86_64-linux-gnu/openmpi/lib -lhdf5 -lmpi" --CXX_LINKER_FLAGS=-Wl,--no-as-needed --with-hypre=1 --with-hypre-include=/usr/include/hypre --with-hypre-lib=-lHYPRE_core --with-mumps=1 --with-mumps-include="[]" --with-mumps-lib="-ldmumps -lzmumps -lsmumps -lcmumps -lmumps_common -lpord" --with-suitesparse=1 --with-suitesparse-include=/usr/include/suitesparse --with-suitesparse-lib="-lumfpack -lamd -lcholmod -lklu" --with-superlu=1 --with-superlu-include=/usr/include/superlu --with-superlu-lib=-lsuperlu --prefix=/usr/lib/petscdir/petsc3.14/x86_64-linux-gnu-real --PETSC_ARCH=x86_64-linux-gnu-real CFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -fPIC" CXXFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -fPIC" FCFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -fPIC -ffree-line-length-0" FFLAGS="-g -O2 -ffile-prefix-map=/build/petsc-pVufYp/petsc-3.14.5+dfsg1=. -flto=auto -ffat-lto-objects -fstack-protector-strong -fPIC -ffree-line-length-0" CPPFLAGS="-Wdate-time -D_FORTIFY_SOURCE=2" LDFLAGS="-Wl,-Bsymbolic-functions -flto=auto -Wl,-z,relro -fPIC" MAKEFLAGS=w
SLEPc version      : SLEPc Release Version 3.14.2, Feb 01, 2021
$
@end verbatim
@end smallformat

@node Test suite
@subsubsection Test suite
@anchor{#test-suite}
To be explained.

@node Install
@subsubsection Install
@anchor{#install}
To be explained.

@node Advanced settings
@subsection Advanced settings
@anchor{#advanced-settings}

@menu
* Compiling with debug symbols::
* Using a different compiler::
* Compiling PETSc::
@end menu

@node Compiling with debug symbols
@subsubsection Compiling with debug symbols
@anchor{#compiling-with-debug-symbols}
By default the C flags are @code{-O3}, without debugging. To add the
@code{-g} flag, just use @code{CFLAGS} when configuring:

@smallformat
@verbatim
./configure CFLAGS="-g -O0"
@end verbatim
@end smallformat

@node Using a different compiler
@subsubsection Using a different compiler
@anchor{#using-a-different-compiler}
Without PETSc, FeenoX uses the @code{CC} environment variable to set the
compiler. So configure like

@smallformat
@verbatim
./configure CC=clang
@end verbatim
@end smallformat

When PETSc is detected FeenoX uses the @code{mpicc} executable, which is
a wrapper to an actual C compiler with extra flags needed to find the
headers and the MPI library. To change the wrapped compiler, you should
set @code{MPICH_CC} or @code{OMPI_CC}, depending if you are using MPICH
or OpenMPI. For example, to force MPICH to use @code{clang} do

@smallformat
@verbatim
./configure MPICH_CC=clang CC=clang
@end verbatim
@end smallformat

To know which is the default MPI implementation, just run
@code{configure} without arguments and pay attention to the ``Compiler''
line in the ``Summary of dependencies'' section. For example, for
OpenMPI a typical summary would be

@smallformat
@verbatim
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS                yes
  PETSc                   yes /usr/lib/petsc 
  SLEPc                   yes /usr/lib/slepc
  Compiler                gcc -I/usr/lib/x86_64-linux-gnu/openmpi/include/openmpi -I/usr/lib/x86_64-linux-gnu/openmpi/include -pthread -L/usr/lib/x86_64-linux-gnu/openmpi/lib -lmpi
@end verbatim
@end smallformat

For MPICH:

@smallformat
@verbatim
## ----------------------- ##
## Summary of dependencies ##
## ----------------------- ##
  GNU Scientific Library  from system
  SUNDIALS                yes
  PETSc                   yes /home/gtheler/libs/petsc-3.15.0 arch-linux2-c-debug
  SLEPc                   yes /home/gtheler/libs/slepc-3.15.1
  Compiler                gcc -Wl,-z,relro -I/usr/include/x86_64-linux-gnu/mpich -L/usr/lib/x86_64-linux-gnu -lmpich
@end verbatim
@end smallformat

Other non-free implementations like Intel@ MPI might work but were not
tested. However, it should be noted that the MPI implementation used to
compile FeenoX has to match the one used to compile PETSc. Therefore, if
you compiled PETSc on your own, it is up to you to ensure MPI
compatibility. If you are using PETSc as provided by your distribution's
repositories, you will have to find out which one was used (it is
usually OpenMPI) and use the same one when compiling FeenoX.

The FeenoX executable will show the configured compiler and flags when
invoked with the @code{--versions} option:

@smallformat
@verbatim
$ feenox --versions
FeenoX v0.1.47-g868dbb7-dirty 
a free no-fee no-X uniX-like finite-element(ish) computational engineering tool

Last commit date   : Mon Sep 6 16:39:53 2021 -0300
Build date         : Tue Sep 07 14:29:42 2021 -0300
Build architecture : linux-gnu x86_64
Compiler           : gcc (Debian 10.2.1-6) 10.2.1 20210110
Compiler flags     : -O3
Builder            : gtheler@tom
GSL version        : 2.6
SUNDIALS version   : 5.7.0
PETSc version      : Petsc Release Version 3.15.0, Mar 30, 2021 
PETSc arch         : arch-linux2-c-debug
PETSc options      : --download-eigen --download-hdf5 --download-hypre --download-metis --download-mumps --download-parmetis --download-pragmatic --download-scalapack --with-x=0
SLEPc version      : SLEPc Release Version 3.15.1, May 28, 2021
$
@end verbatim
@end smallformat

Note that the reported values are the ones used in @code{configure} and
not in @code{make}. Thus, the recommended way to set flags is in
@code{configure} and not in @code{make}.

@node Compiling PETSc
@subsubsection Compiling PETSc
@anchor{#compiling-petsc}
To be explained.

@node Examples
@chapter Examples
@anchor{#examples}
To be done.

@node Tutorial
@chapter Tutorial
@anchor{#tutorial}
To be done.

@node Description
@chapter Description
@anchor{#description}
FeenoX solves a problem defined in an plain-text input file and writes
user-defined outputs to the standard output and/or files, either also
plain-text or with a particular format for further post-processing. The
syntax of this input file is designed to be as self-describing as
possible, using English keywords that explains FeenoX what problem it
has to solve in a way is understandable by both humans and computers.
Keywords can work either as

@enumerate 
@item
Definitions, for instance ”define function@ @math{f(x)} and read its
data from file @code{f.dat}”), or as
@item
Instructions, such as ``write the stress at point @math{D} into the
standard output''.
@end enumerate

A person can tell if a keyword is a definition or an instruction because
the former are nouns (@code{FUNCTION}) and the latter verbs
(@code{PRINT}). The equal sign @code{=} is a special keyword that is
neither a verb nor a noun, and its meaning changes depending on what is
on the left hand side of the assignment.

@enumerate a
@item
If there is a function, then it is a definition: define an algebraic
function to be equal to the expression on the right-hand side, e.g.:

@smallformat
@verbatim
f(x,y) = exp(-x^2)*cos(pi*y)
@end verbatim
@end smallformat

@item
If there is a variable, vector or matrix, it is an instruction: evaluate
the expression on the right-hand side and assign it to the varible or
vector (or matrix) element indicated in the left-hand side. Strictly
speaking, if the variable has not already been defined (and implicit
declaration is allowed), then the variable is also defined as well, e.g:

@smallformat
@verbatim
VAR a
VECTOR b[3]
a = sqrt(2)
b[i] = a*i^2
@end verbatim
@end smallformat

There is no need to explicitly define the scalar variable @code{a} with
@code{VAR} since the first assigment also defines it implicitly (if this
is allowed by the keyword @code{IMPLICIT}).

@end enumerate

An input file can define its own variables as needed, such as
@code{my_var} or @code{flag}. But there are some reserved names that are
special in the sense that they either

@enumerate 
@item
can be set to modify the behavior of FeenoX, such as @code{max_dt} or
@code{dae_tol}
@item
can be read to get the internal status or results back from FeenoX, such
as @code{nodes} or @code{keff}
@item
can be either set or read, such as @code{dt} or @code{done}
@end enumerate

The problem being solved can be static or transient, depending on
whether the special variable @code{end_time} is zero (default) or not.
If it is zero and @code{static_steps} is equal to one (default), the
instructions in the input file are executed once and then FeenoX quits.
For example

@smallformat
@verbatim
VAR x
PRINT %.7f func_min(cos(x)+1,x,0,6)
@end verbatim
@end smallformat

If @code{static_steps} is larger than one, the special variable
@code{step_static} is increased and they are repeated the number of time
indicated by @code{static_steps}:

@smallformat
@verbatim
static_steps = 10
f(n) = n^2 - n + 41
PRINT f(step_static^2-1)
@end verbatim
@end smallformat

If the special variable @code{end_time} is set to a non-zero value,
after computing the static part a transient problem is solved. There are
three kinds of transient problems:

@enumerate 
@item
Plain ``standalone'' transients
@item
Differential-Algebraic equations (DAE) transients
@item
Partial Differential equations (PDE) transients
@end enumerate

In the first case, after all the instruction in the input file were
executed, the special variable @code{t} is increased by the value of
@code{dt} and then the instructions are executed all over again, until
@code{t} reaches @code{end_time}:

@smallformat
@verbatim
end_time = 2*pi
dt = 1/10

y = lag(heaviside(t-1), 1)
z = random_gauss(0, sqrt(2)/10)

PRINT t sin(t) cos(t) y z HEADER
@end verbatim
@end smallformat

In the second case, the keyword @code{PHASE_SPACE} sets up DAE system.
Then, one initial condition and one differential-algebraic equation has
to be given for each element in the phase space. The instructions before
the DAE block executed, then the DAE timestep is advanced and finally
the instructions after DAE block are executed (there cannot be any
instruction between the first and the last DAE):

@smallformat
@verbatim
PHASE_SPACE x
end_time = 1
x_0 = 1
x_dot = -x
PRINT t x exp(-t) HEADER
@end verbatim
@end smallformat

The timestep is chosen by the SUNDIALS library in order to keep an
estimate of the residual error below @code{dae_tol} (default is
@math{10^{-6}}), although @code{min_dt} and @code{max_dt} can be used to
control it. See the section of the
@ref{#differential-algebraic-equations-subsystem,Differential-Algebraic
Equations subsystem} for more information.

In the third cae, the type of PDE being solved is given by the keyword
@code{PROBLEM}. Some types of PDEs do support transient problems (such
as @code{thermal}) but some others do not (such as @code{modal}). See
the detailed explanation of each problem type for details. Now the
transient problem is handled by the TS framework of the PETSc library.
In general transient PDEs involve a mesh, material properties, inital
conditions, transient boundary conditions, etc. And they create a lot of
data since results mean spatial and temporal distributions of one or
more scalar fields:

@smallformat
@verbatim
# example of a 1D heat transient problem
# from https://www.mcs.anl.gov/petsc/petsc-current/src/ts/tutorials/ex3.c.html
# a non-dimensional slab 0 < x < 1 is kept at T(0) = T(1) = 0
# there is an initial non-trivial T(x)
# the steady-state is T(x) = 0
PROBLEM thermal 1d
READ_MESH slab60.msh

end_time = 1e-1

# initial condition
T_0(x) := sin(6*pi*x) + 3*sin(2*pi*x)
# analytical solution
T_a(x,t) := exp(-36*pi^2*t)*sin(6*pi*x) + 3*exp(-4*pi^2*t)*sin(2*pi*x)

# unitary non-dimensional properties
k = 1
rho = 1
cp = 1

# boundary conditions
BC left  T=0
BC right T=0

SOLVE_PROBLEM

PRINT %e t dt T(0.1) T_a(0.1,t) T(0.7) T_a(0.7,t)
WRITE_MESH temp-slab.msh T

IF done
 PRINT "\# open temp-anim-slab.geo in Gmsh to see the result!"
ENDIF
@end verbatim
@end smallformat

PETSc's TS also honors the @code{min_dt} and @code{max_dt} variables,
but the time step is controled by the allowed relative error with the
special variable @code{ts_rtol}. Again, see the section of the
@ref{#partial-differential-equations-subsytem,Partial Differential
Equations subsytem} for more information.

@menu
* Algebraic expressions::
* Initial conditions::
* Expansions of command line arguments::
@end menu

@node Algebraic expressions
@section Algebraic expressions
@anchor{#algebraic-expressions}
To be done.

@itemize
@item
Everything is an expression.
@end itemize

@node Initial conditions
@section Initial conditions
@anchor{#initial-conditions}

@node Expansions of command line arguments
@section Expansions of command line arguments
@anchor{#expansions-of-command-line-arguments}

@node Reference
@chapter Reference
@anchor{#reference}
This chapter contains a detailed reference of keywords, variables,
functions and functionals available in FeenoX. These are used
essentially to define the problem that FeenoX needs to solve and to
define what the output should be. It should be noted that this chapter
is to be used, indeed, as a @emph{reference} and not as a tutorial.

@menu
* Differential-Algebraic Equations subsystem::
* Partial Differential Equations subsytem::
* Laplace's equation::
* The heat conduction equation::
* General & “standalone” mathematics::
* Functions::
* Functionals::
* Vector functions::
@end menu

@node Differential-Algebraic Equations subsystem
@section Differential-Algebraic Equations subsystem
@anchor{#differential-algebraic-equations-subsystem}

@menu
* Keywords::
* Variables::
@end menu

@node Keywords
@subsection Keywords
@anchor{#keywords}

@menu
* INITIAL_CONDITIONS::
* PHASE_SPACE::
* TIME_PATH::
@end menu

@node INITIAL_CONDITIONS
@subsubsection @code{INITIAL_CONDITIONS}
@anchor{#initial_conditions}
Define how initial conditions of DAE problems are computed.

@smallformat
@verbatim
INITIAL_CONDITIONS { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }  
@end verbatim
@end smallformat

In DAE problems, initial conditions may be either:

@itemize
@item
equal to the provided expressions (@code{AS_PROVIDED})
@item
the derivatives computed from the provided phase-space variables
(@code{FROM_VARIABLES})
@item
the phase-space variables computed from the provided derivatives
(@code{FROM_DERIVATIVES})
@end itemize

In the first case, it is up to the user to fulfill the DAE system
at@ @math{t = 0}. If the residuals are not small enough, a convergence
error will occur. The @code{FROM_VARIABLES} option means calling IDA's
@code{IDACalcIC} routine with the parameter @code{IDA_YA_YDP_INIT}. The
@code{FROM_DERIVATIVES} option means calling IDA's @code{IDACalcIC}
routine with the parameter IDA_Y_INIT. Wasora should be able to
automatically detect which variables in phase-space are differential and
which are purely algebraic. However, the [@code{DIFFERENTIAL}] keyword
may be used to explicitly define them. See the (SUNDIALS
documentation)[https://computation.llnl.gov/casc/sundials/documentation/ida_guide.pdf]
for further information.

@node PHASE_SPACE
@subsubsection @code{PHASE_SPACE}
@anchor{#phase_space}
Asks FeenoX to solve a set of algebraic-differntial equations and define
the variables, vectors and/or matrices that span the phase space.

@smallformat
@verbatim
PHASE_SPACE  
@end verbatim
@end smallformat

@node TIME_PATH
@subsubsection @code{TIME_PATH}
@anchor{#time_path}
Force time-dependent problems to pass through specific instants of time.

@smallformat
@verbatim
TIME_PATH <expr_1> [ <expr_2>  [ ... <expr_n> ] ]  
@end verbatim
@end smallformat

The time step @code{dt} will be reduced whenever the distance between
the current time @code{t} and the next expression in the list is greater
than @code{dt} so as to force @code{t} to coincide with the expressions
given. The list of expresssions should evaluate to a sorted list of
values for all times.

@node Variables
@subsection Variables
@anchor{#variables}

@menu
* dae_rtol::
@end menu

@node dae_rtol
@subsubsection @code{dae_rtol}
@anchor{#dae_rtol}
Maximum allowed relative error for the solution of DAE systems.

Default value is is @math{1 \times 10^{-6}}. If a fine per-variable
error control is needed, special vector @code{abs_error} should be used.

@node Partial Differential Equations subsytem
@section Partial Differential Equations subsytem
@anchor{#partial-differential-equations-subsytem}

@menu
* Keywords::
* Variables::
@end menu

@node Keywords
@subsection Keywords
@anchor{#keywords-1}

@menu
* BC::
* DUMP::
* FIND_EXTREMA::
* INTEGRATE::
* MATERIAL::
* PHASE_SPACE::
* PHYSICAL_GROUP::
* PROBLEM::
* READ_MESH::
* SOLVE_PROBLEM::
* WRITE_MESH::
@end menu

@node BC
@subsubsection @code{BC}
@anchor{#bc}
Define a boundary condition to be applied to faces, edges and/or
vertices.

@smallformat
@verbatim
BC <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1>  PHYSICAL_GROUP <name_2> ... ] [ <bc_data1> <bc_data2> ... ]  
@end verbatim
@end smallformat

If the name of the boundary condition matches a physical group in the
mesh, it is automatically linked to that physical group. If there are
many meshes, the mesh this keyword refers to has to be given with
@code{MESH}. If the boundary condition applies to more than one physical
group in the mesh, they can be added using as many @code{PHYSICAL_GROUP}
keywords as needed. Each @code{<bc_data>} argument is a single string
whose meaning depends on the type of problem being solved. For instance
@code{T=150*sin(x/pi)} prescribes the temperature to depend on space as
the provided expression in a thermal problem and @code{fixed} fixes the
displacements in all the directions in a mechanical or modal problem.
See the particular section on boundary conditions for further details.

@node DUMP
@subsubsection @code{DUMP}
@anchor{#dump}
Dump raw PETSc objects used to solve PDEs into files.

@smallformat
@verbatim
DUMP [ FORMAT { binary | ascii | octave } ] [ K |   K_bc |   b |   b_bc |   M |   M_bc |  
@end verbatim
@end smallformat

@node FIND_EXTREMA
@subsubsection @code{FIND_EXTREMA}
@anchor{#find_extrema}
Find and/or compute the absolute extrema of a function or expression
over a mesh (or a subset of it).

@smallformat
@verbatim
FIND_EXTREMA { <expression> | <function> } [ OVER <physical_group> ] [ MESH <mesh_identifier> ] [ NODES | CELLS | GAUSS ]
 [ MIN <variable> ] [ MAX <variable> ] [ X_MIN <variable> ] [ X_MAX <variable> ] [ Y_MIN <variable> ] [ Y_MAX <variable> ] [ Z_MIN <variable> ] [ Z_MAX <variable> ] [ I_MIN <variable> ] [ I_MAX <variable> ]  
@end verbatim
@end smallformat

Either an expression or a function of space @math{x}, @math{y} and/or
@math{z} should be given. By default the search is performed over the
highest-dimensional elements of the mesh, i.e.@ over the whole volume,
area or length for three, two and one-dimensional meshes, respectively.
If the search is to be carried out over just a physical group, it has to
be given in @code{OVER}. If there are more than one mesh defined, an
explicit one has to be given with @code{MESH}. If neither @code{NODES},
@code{CELLS} or @code{GAUSS} is given then the search is performed over
the three of them. With @code{NODES} only the function or expression is
evalauted at the mesh nodes. With @code{CELLS} only the function or
expression is evalauted at the element centers. With @code{GAUSS} only
the function or expression is evalauted at the Gauss points. The value
of the absolute minimum (maximum) is stored in the variable indicated by
@code{MIN} (@code{MAX}). If the variable does not exist, it is created.
The value of the @math{x}-@math{y}-@math{z}@ coordinate of the absolute
minimum (maximum) is stored in the variable indicated by
@code{X_MIN}-@code{Y_MIN}-@code{Z_MIN}
(@code{X_MAX}-@code{Y_MAX}-@code{Z_MAX}). If the variable does not
exist, it is created. The index (either node or cell) where the absolute
minimum (maximum) is found is stored in the variable indicated by
@code{I_MIN} (@code{I_MAX}).

@node INTEGRATE
@subsubsection @code{INTEGRATE}
@anchor{#integrate}
Spatially integrate a function or expression over a mesh (or a subset of
it).

@smallformat
@verbatim
INTEGRATE { <expression> | <function> } [ OVER <physical_group> ] [ MESH <mesh_identifier> ] [ NODES | CELLS ]
 RESULT <variable>
  
@end verbatim
@end smallformat

Either an expression or a function of space @math{x}, @math{y} and/or
@math{z} should be given. If the integrand is a function, do not include
the arguments, i.e.@ instead of @code{f(x,y,z)} just write @code{f}. The
results should be the same but efficiency will be different (faster for
pure functions). By default the integration is performed over the
highest-dimensional elements of the mesh, i.e.@ over the whole volume,
area or length for three, two and one-dimensional meshes, respectively.
If the integration is to be carried out over just a physical group, it
has to be given in @code{OVER}. If there are more than one mesh defined,
an explicit one has to be given with @code{MESH}. Either @code{NODES} or
@code{CELLS} define how the integration is to be performed. With
@code{NODES} the integration is performed using the Gauss points and
weights associated to each element type. With @code{CELLS} the integral
is computed as the sum of the product of the integrand at the center of
each cell (element) and the cell's volume. Do expect differences in the
results and efficiency between these two approaches depending on the
nature of the integrand. The scalar result of the integration is stored
in the variable given by the mandatory keyword @code{RESULT}. If the
variable does not exist, it is created.

@node MATERIAL
@subsubsection @code{MATERIAL}
@anchor{#material}
Define a material its and properties to be used in volumes.

@smallformat
@verbatim
MATERIAL <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1>  [ PHYSICAL_GROUP <name_2> [ ... ] ] ] [ <property_name_1>=<expr_1> [ <property_name_2>=<expr_2> [ ... ] ] ]  
@end verbatim
@end smallformat

If the name of the material matches a physical group in the mesh, it is
automatically linked to that physical group. If there are many meshes,
the mesh this keyword refers to has to be given with @code{MESH}. If the
material applies to more than one physical group in the mesh, they can
be added using as many @code{PHYSICAL_GROUP} keywords as needed. The
names of the properties in principle can be arbitrary, but each problem
type needs a minimum set of properties defined with particular names.
For example, steady-state thermal problems need at least the
conductivity which should be named@ @code{k}. If the problem is
transient, it will also need heat capacity@ @code{rhocp} or
diffusivity@ @code{alpha}. Mechanical problems need Young
modulus@ @code{E} and Poisson's ratio@ @code{nu}. Modal also needs
density@ @code{rho}. Check the particular documentation for each problem
type. Besides these mandatory properties, any other one can be defined.
For instance, if one mandatory property dependend on the concentration
of boron in the material, a new per-material property can be added named
@code{boron} and then the function @code{boron(x,y,z)} can be used in
the expression that defines the mandatory property.

@node PHASE_SPACE
@subsubsection @code{PHASE_SPACE}
@anchor{#phase_space}

@smallformat
@verbatim
PHASE_SPACE <vars> ... <vectors> ... <matrices> ...   
@end verbatim
@end smallformat

@node PHYSICAL_GROUP
@subsubsection @code{PHYSICAL_GROUP}
@anchor{#physical_group}
Explicitly defines a physical group of elements on a mesh.

@smallformat
@verbatim
PHYSICAL_GROUP <name> [ MESH <name> ] [ DIMENSION <expr> ] [ ID <expr> ]
 [ MATERIAL <name> | | BC <name> [ BC ... ] ]
  
@end verbatim
@end smallformat

This keyword should seldom be needed. Most of the times, a combination
of @code{MATERIAL} and @code{BC} ought to be enough for most purposes.
The name of the @code{PHYSICAL_GROUP} keyword should match the name of
the physical group defined within the input file. If there is no
physical group with the provided name in the mesh, this instruction has
no effect. If there are many meshes, an explicit mesh can be given with
@code{MESH}. Otherwise, the physical group is defined on the main mesh.
An explicit dimension of the physical group can be provided with
@code{DIMENSION}. An explicit id can be given with @code{ID}. Both
dimension and id should match the values in the mesh. For volumetric
elements, physical groups can be linked to materials using
@code{MATERIAL}. Note that if a material is created with the same name
as a physical group in the mesh, they will be linked automatically, so
there is no need to use @code{PHYSCAL_GROUP} for this. The
@code{MATERIAL} keyword in @code{PHYSICAL_GROUP} is used to link a
physical group in a mesh file and a material in the feenox input file
with different names. Likewise, for non-volumetric elements, physical
groups can be linked to boundary using @code{BC}. As in the preceeding
case, if a boundary condition is created with the same name as a
physical group in the mesh, they will be linked automatically, so there
is no need to use @code{PHYSCAL_GROUP} for this. The @code{BC} keyword
in @code{PHYSICAL_GROUP} is used to link a physical group in a mesh file
and a boundary condition in the feenox input file with different names.
Note that while there can be only one @code{MATERIAL} associated to a
physical group, there can be many @code{BC}s associated to a physical
group.

@node PROBLEM
@subsubsection @code{PROBLEM}
@anchor{#problem}
Ask FeenoX to solve a partial-differential equation problem.

@smallformat
@verbatim
PROBLEM [ mechanical | thermal | modal | neutron_diffusion ]
 
 [ 1D |   2D |   3D |   DIMENSIONS <expr> ] [ MESH <identifier> ] 
 
[ AXISYMMETRIC { x | y } | [ PROGRESS ]
 [ TRANSIENT | QUASISTATIC]
 [ LINEAR | NON_LINEAR ] [ MODES <expr> ] 
 [ PRECONDITIONER { gamg | mumps | lu | hypre | sor | bjacobi | cholesky | ... } ]
 [ LINEAR_SOLVER { gmres | mumps | bcgs | bicg | richardson | chebyshev | ... } ]
 [ NONLINEAR_SOLVER { newtonls | newtontr | nrichardson | ngmres | qn | ngs | ... } ]
 [ TRANSIENT_SOLVER { bdf | beuler | arkimex | rosw | glee | ... } ]
 [ TIME_ADAPTATION { basic | none | dsp | cfl | glee | ... } ]
 [ EIGEN_SOLVER { krylovschur | lanczos | arnoldi | power | gd | ... } ]
 [ SPECTRAL_TRANSFORMATION { shift | sinvert | cayley | ... } ]
 [ EIGEN_FORMULATION { omega | lambda } ]
  
@end verbatim
@end smallformat

@itemize
@item
@code{laplace} (or @code{poisson}) solves the Laplace (or Poisson)
equation.
@item
@code{mechanical} (or @code{elastic}) solves the mechanical elastic
problem. If the mesh is two-dimensional, and not @code{AXISYMMETRIC},
either @code{plane_stress} or @code{plane_strain} has to be set instead.
@item
@code{thermal} (or @code{heat} ) solves the heat conduction problem.
@item
@code{modal} computes the natural mechanical frequencies and oscillation
modes.
@item
@code{neutron_diffusion} multi-group core-level neutron diffusion with a
FEM formulation
@end itemize

If you are a programmer and want to contribute with another problem
type, please do so! Check out [FeenoX repository](https: for licensing
information, programming guides and code of conduct.

The number of spatial dimensions of the problem needs to be given either
as @code{1d}, @code{2d}, @code{3d} or with the keyword
@code{DIMENSIONS}. Alternatively, one can define a @code{MESH} with an
explicit @code{DIMENSIONS} keyword before @code{PROBLEM}. If there are
more than one @code{MESH}es define, the one over which the problem is to
be solved can be defined by giving the explicit mesh name with
@code{MESH}. By default, the first mesh to be defined in the input file
is the one over which the problem is solved. If the @code{AXISYMMETRIC}
keyword is given, the mesh is expected to be two-dimensional in the
@math{x}-@math{y} plane and the problem is assumed to be axi-symmetric
around the given axis. If the keyword @code{PROGRESS} is given, three
ASCII lines will show in the terminal the progress of the ensamble of
the stiffness matrix (or matrices), the solution of the system of
equations and the computation of gradients (stresses). If the special
variable @code{end_time} is zero, FeenoX solves a static
problem---although the variable @code{static_steps} is still honored. If
@code{end_time} is non-zero, FeenoX solves a transient or quasistatic
problem. This can be controlled by @code{TRANSIENT} or
@code{QUASISTATIC}. By default FeenoX tries to detect wheter the
computation should be linear or non-linear. An explicit mode can be set
with either @code{LINEAR} on @code{NON_LINEAR}. The number of modes to
be computed when solving eigenvalue problems is given by @code{MODES}.
The default value is problem dependent. The preconditioner (@code{PC}),
linear (@code{KSP}), non-linear (@code{SNES}) and time-stepper
(@code{TS}) solver types be any of those available in PETSc (first
option is the default):

@itemize
@item
List of @code{PRECONDITIONER}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCType.html}.

@item
List of @code{LINEAR_SOLVER}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html}.

@item
List of @code{NONLINEAR_SOLVER}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESType.html}.

@item
List of @code{TRANSIENT_SOLVER}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSType.html}.

@item
List of @code{TIME_ADAPTATION}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSAdaptType.html}.

@item
List of @code{EIGEN_SOLVER}s <https:

@item
List of @code{SPECTRAL_TRANSFORMATION}s <https: If the
@code{EIGEN_FORMULATION} is @code{omega} then
@math{K \phi = \omega^2 M \phi}, and @math{M \phi = \lambda K \phi}$ if
it is @code{lambda}.

@end itemize

@node READ_MESH
@subsubsection @code{READ_MESH}
@anchor{#read_mesh}
Read an unstructured mesh and (optionally) functions of space-time from
a file.

@smallformat
@verbatim
READ_MESH { <file_path> | <file_id> } [ DIMENSIONS <num_expr> ]
 [ SCALE <expr> ] [ OFFSET <expr_x> <expr_y> <expr_z> ]
 [ INTEGRATION { full | reduced } ]
 [ MAIN ] [ UPDATE_EACH_STEP ]
 [ READ_FIELD <name_in_mesh> AS <function_name> ] [ READ_FIELD ... ] 
 [ READ_FUNCTION <function_name> ] [READ_FUNCTION ...] 
  
@end verbatim
@end smallformat

Either a file identifier (defined previously with a @code{FILE} keyword)
or a file path should be given. The format is read from the extension,
which should be either

@itemize
@item
@code{.msh}, @code{.msh2} or @code{.msh4}
@uref{http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format,Gmsh ASCII
format}, versions 2.2, 4.0 or 4.1
@item
@code{.vtk}
@uref{https://lorensen.github.io/VTKExamples/site/VTKFileFormats/,ASCII
legacy VTK}
@item
@code{.frd}
@uref{https://web.mit.edu/calculix_v2.7/CalculiX/cgx_2.7/doc/cgx/node4.html,CalculiX's
FRD ASCII output})
@end itemize

Note than only MSH is suitable for defining PDE domains, as it is the
only one that provides physical groups (a.k.a labels) which are needed
in order to define materials and boundary conditions. The other formats
are primarily supported to read function data contained in the file and
eventually, to operate over these functions (i.e.@ take differences with
other functions contained in other files to compare results). The file
path or file id can be used to refer to a particular mesh when reading
more than one, for instance in a @code{WRITE_MESH} or @code{INTEGRATE}
keyword. If a file path is given such as @code{cool_mesh.msh}, it can be
later referred to as either @code{cool_mesh.msh} or just
@code{cool_mesh}. The spatial dimensions cab be given with
@code{DIMENSION}. If material properties are uniform and given with
variables, the number of dimensions are not needed and will be read from
the file at runtime. But if either properties are given by spatial
functions or if functions are to be read from the mesh with
@code{READ_DATA} or @code{READ_FUNCTION}, then the number of dimensions
ought to be given explicitly because FeenoX needs to know how many
arguments these functions take. If either @code{OFFSET} and/or
@code{SCALE} are given, the node locations are first shifted and then
scaled by the provided values. When defining several meshes and solving
a PDE problem, the mesh used as the PDE domain is the one marked with
@code{MAIN}. If none of the meshes is explicitly marked as main, the
first one is used. If @code{UPDATE_EACH_STEP} is given, then the mesh
data is re-read from the file at each time step. Default is to read the
mesh once, except if the file path changes with time. For each
@code{READ_FIELD} keyword, a point-wise defined function of space named
@code{<function_name>} is defined and filled with the scalar data named
@code{<name_in_mesh>} contained in the mesh file. The
@code{READ_FUNCTION} keyword is a shortcut when the scalar name and the
to-be-defined function are the same. If no mesh is marked as
@code{MAIN}, the first one is the main one.

@node SOLVE_PROBLEM
@subsubsection @code{SOLVE_PROBLEM}
@anchor{#solve_problem}
Explicitly solve the PDE problem.

@smallformat
@verbatim
SOLVE_PROBLEM  
@end verbatim
@end smallformat

Whenever the instruction @code{SOLVE_PROBLEM} is executed, FeenoX solves
the PDE problem. For static problems, that means solving the equations
and filling in the result functions. For transient or quasisstatic
problems, that means advancing one time step.

@node WRITE_MESH
@subsubsection @code{WRITE_MESH}
@anchor{#write_mesh}
Write a mesh and functions of space-time to a file for post-processing.

@smallformat
@verbatim
WRITE_MESH { <file_path> | <file_id> } [ MESH <mesh_identifier> ] [ NO_MESH ] [ FILE_FORMAT { gmsh | vtk } ] [ NO_PHYSICAL_NAMES ]  [ NODE | CELL ] [ SCALAR_FORMAT <printf_specification>] [ VECTOR <field_x> <field_y> <field_z> ] [...] [ <field_1> ] [ <field_2> ] ...  
@end verbatim
@end smallformat

Either a file identifier (defined previously with a @code{FILE} keyword)
or a file path should be given. The format is automatically detected
from the extension. Otherwise, the keyword @code{FILE_FORMAT} can be use
to give the format explicitly. If there are several meshes defined then
which one should be used has to be given explicitly with @code{MESH}. If
the @code{NO_MESH} keyword is given, only the results are written into
the output file. Depending on the output format, this can be used to
avoid repeating data and/or creating partial output files which can the
be latter assembled by post-processing scripts. When targetting the
@code{.msh} output format, if @code{NO_PHYSICAL_NAMES} is given then the
section that sets the actual names of the physical entities is not
written. This can be needed to avoid name clashes when reading multiple
@code{.msh} files. The output is node-based by default. This can be
controlled with both the @code{NODE} and @code{CELL} keywords. All
fields that come after a @code{NODE} (@code{CELL}) keyword will be
written at the node (cells). These keywords can be used several times
and mixed with fields. For example
@code{CELL k(x,y,z) NODE T sqrt(x^2+y^2) CELL 1+z} will write the
conductivity and the expression @math{1+z} as cell-based and the
temperature @math{T(x,y,z)} and the expression @math{\sqrt{x^2+y^2}} as
a node-based fields. Also, the @code{SCALAR_FORMAT} keyword can be used
to define the precision of the ASCII representation of the fields that
follow. Default is @code{%g}. The data to be written has to be given as
a list of fields, i.e.@ distributions (such as @code{k} or @code{E}),
functions of space (such as @code{T}) and/or expressions (such as
@code{x^2+y^2+z^2}). Each field is written as a scalar, unless the
keyword @code{VECTOR} is given. In this case, there should be exactly
three fields following @code{VECTOR}.

@node Variables
@subsection Variables
@anchor{#variables-1}

@node Laplace's equation
@section Laplace's equation
@anchor{#laplaces-equation}
Set @code{PROBLEM} to @code{laplace} to solve Laplace's equation

@math{\nabla^2 \phi = 0}

If @code{end_time} is set, then the transient problem is solved

@math{\alpha\vec{x, \phi} \frac{\partial \phi}{\partial t} + \nabla^2 \phi = 0}

@menu
* Results::
* Properties::
* Boundary Conditions::
* Keywords::
* Variables::
@end menu

@node Results
@subsection Results
@anchor{#results}

@menu
* phi::
@end menu

@node phi
@subsubsection @code{phi}
@anchor{#phi}
The scalar field@ @math{\phi(\vec{x})} whose Laplacian is equal to zero
or to@ @math{f(\vec{x})}.

@node Properties
@subsection Properties
@anchor{#properties}

@menu
* alpha::
* f::
@end menu

@node alpha
@subsubsection @code{alpha}
@anchor{#alpha}
The coefficient of the temporal derivative for the transient equation
@ @math{\alpha \frac{\partial \phi}{\partial t} + \nabla^2 \phi=f(\vec{x})}.
If not given, default is one.

@node f
@subsubsection @code{f}
@anchor{#f}
The right hand side of the equation@ @math{\nabla^2 \phi=f(\vec{x})}. If
not given, default is zero (i.e.@ Laplace).

@node Boundary Conditions
@subsection Boundary Conditions
@anchor{#boundary-conditions}

@menu
* dphidn::
* phi::
* phi'::
@end menu

@node dphidn
@subsubsection @code{dphidn}
@anchor{#dphidn}
Alias for @code{phi'}.

@smallformat
@verbatim
dphidn=<expr>  
@end verbatim
@end smallformat

@node phi
@subsubsection @code{phi}
@anchor{#phi}
Dirichlet essential boundary condition in which the value
of@ @math{\phi} is prescribed.

@smallformat
@verbatim
phi=<expr>  
@end verbatim
@end smallformat

@node phi'
@subsubsection @code{phi'}
@anchor{#phi-1}
Neumann natural boundary condition in which the value of the normal
outward derivative@ @math{\frac{\partial \phi}{\partial n}} is
prescribed.

@smallformat
@verbatim
phi'=<expr>  
@end verbatim
@end smallformat

@node Keywords
@subsection Keywords
@anchor{#keywords-2}

@node Variables
@subsection Variables
@anchor{#variables-2}

@node The heat conduction equation
@section The heat conduction equation
@anchor{#the-heat-conduction-equation}
Set @code{PROBLEM} to @code{thermal} (or @code{heat}) to solve thermal
conduction:

@math{\rho \c_p \frac{\partial T}{\partial t} + \text{div} \left[ k(\vec{x, T} \cdot \text{grad}{T} \right] = q'''(\vec{x}, T)}

If @code{end_time} is zero, only the steady-state problem is solved. If
@math{k}, @math{q'''} or any Neumann boundary condition depends
on@ @math{T}, the problem is set to non-linear automatically.

@menu
* Results::
* Properties::
* Boundary Conditions::
* Keywords::
* Variables::
@end menu

@node Results
@subsection Results
@anchor{#results-1}

@menu
* qx::
* qy::
* qz::
* T::
@end menu

@node qx
@subsubsection @code{qx}
@anchor{#qx}
The heat flux
field@ @math{q_x(\vec{x}) = -k(\vec{x}) \cdot \frac{\partial T}{\partial x}}
in the@ @math{x} direction. This is a secondary unknown of the problem.

@node qy
@subsubsection @code{qy}
@anchor{#qy}
The heat flux
field@ @math{q_y(\vec{x}) = -k(\vec{x}) \cdot \frac{\partial T}{\partial y}}
in the@ @math{x} direction. This is a secondary unknown of the problem.
Only available for two and three-dimensional problems.

@node qz
@subsubsection @code{qz}
@anchor{#qz}
The heat flux
field@ @math{q_z(\vec{x}) = -k(\vec{x}) \cdot \frac{\partial T}{\partial z}}
in the@ @math{x} direction. This is a secondary unknown of the
problem.@*
Only available for three-dimensional problems.

@node T
@subsubsection @code{T}
@anchor{#t}
The temperature field@ @math{T(\vec{x})}. This is the primary unknown of
the problem.

@node Properties
@subsection Properties
@anchor{#properties-1}

@menu
* k::
* q::
* q'''::
@end menu

@node k
@subsubsection @code{k}
@anchor{#k}
The thermal conductivity in units of power per length per degree of
temperature.

@smallformat
@verbatim
k  
@end verbatim
@end smallformat

@node q
@subsubsection @code{q}
@anchor{#q}
Alias for @code{q'''}

@smallformat
@verbatim
q  
@end verbatim
@end smallformat

@node q'''
@subsubsection @code{q'''}
@anchor{#q-1}
The volumetric power dissipated in the material in units of power per
unit of volume. Default is zero (i.e.@ no power).

@smallformat
@verbatim
q'''  
@end verbatim
@end smallformat

@node Boundary Conditions
@subsection Boundary Conditions
@anchor{#boundary-conditions-1}

@node Keywords
@subsection Keywords
@anchor{#keywords-3}

@node Variables
@subsection Variables
@anchor{#variables-3}

@menu
* T_max::
* T_min::
@end menu

@node T_max
@subsubsection @code{T_max}
@anchor{#t_max}
The maximum temperature@ @math{T_\text{max}}.

@node T_min
@subsubsection @code{T_min}
@anchor{#t_min}
The minimum temperature@ @math{T_\text{min}}.

@node General & “standalone” mathematics
@section General & ``standalone'' mathematics
@anchor{#general-standalone-mathematics}

@menu
* Keywords::
* Variables::
@end menu

@node Keywords
@subsection Keywords
@anchor{#keywords-4}

@menu
* ABORT::
* ALIAS::
* CLOSE::
* DEFAULT_ARGUMENT_VALUE::
* FILE::
* FIT::
* FUNCTION::
* IF::
* IMPLICIT::
* INCLUDE::
* MATRIX::
* OPEN::
* PRINT::
* PRINT_FUNCTION::
* PRINT_VECTOR::
* SORT_VECTOR::
* VAR::
* VECTOR::
@end menu

@node ABORT
@subsubsection @code{ABORT}
@anchor{#abort}
Catastrophically abort the execution and quit FeenoX.

@smallformat
@verbatim
ABORT  
@end verbatim
@end smallformat

Whenever the instruction @code{ABORT} is executed, FeenoX quits with a
non-zero error leve. It does not close files nor unlock shared memory
objects. The objective of this instruction is to either debug complex
input files by using only parts of them or to conditionally abort the
execution using @code{IF} clauses.

@node ALIAS
@subsubsection @code{ALIAS}
@anchor{#alias}
Define a scalar alias of an already-defined indentifier.

@smallformat
@verbatim
ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }  
@end verbatim
@end smallformat

The existing object can be a variable, a vector element or a matrix
element. In the first case, the name of the variable should be given as
the existing object. In the second case, to alias the second element of
vector @code{v} to the new name @code{new}, @code{v(2)} should be given
as the existing object. In the third case, to alias second element (2,3)
of matrix @code{M} to the new name @code{new}, @code{M(2,3)} should be
given as the existing object.

@node CLOSE
@subsubsection @code{CLOSE}
@anchor{#close}
Explicitly close a file after input/output.

@smallformat
@verbatim
CLOSE <name>  
@end verbatim
@end smallformat

The given @code{<name>} can be either a fixed-string path or an
already-defined @code{FILE}.

@node DEFAULT_ARGUMENT_VALUE
@subsubsection @code{DEFAULT_ARGUMENT_VALUE}
@anchor{#default_argument_value}
Give a default value for an optional commandline argument.

@smallformat
@verbatim
DEFAULT_ARGUMENT_VALUE <constant> <string>  
@end verbatim
@end smallformat

If a @code{$n} construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional. The
@code{<constant>} should be 1, 2, 3, etc. and @code{<string>} will be
expanded character-by-character where the @code{$n} construction is.
Whether the resulting expression is to be interpreted as a string or as
a numerical expression will depend on the context.

@node FILE
@subsubsection @code{FILE}
@anchor{#file}
Define a file with a particularly formatted name to be used either as
input or as output.

@smallformat
@verbatim
< FILE | OUTPUT_FILE | INPUT_FILE > <name> PATH <format> expr_1 expr_2 ... expr_n [ INPUT | OUTPUT | MODE <fopen_mode> ]  
@end verbatim
@end smallformat

For reading or writing into files with a fixed path, this instruction is
usually not needed as the @code{FILE} keyword of other instructions
(such as @code{PRINT} or @code{MESH}) can take a fixed-string path as an
argument. However, if the file name changes as the execution progresses
(say because one file for each step is needed), then an explicit
@code{FILE} needs to be defined with this keyword and later referenced
by the given name. The path should be given as a @code{printf}-like
format string followed by the expressions which shuold be evaluated in
order to obtain the actual file path. The expressions will always be
floating-point expressions, but the particular integer specifier
@code{%d} is allowed and internally transformed to @code{%.0f}. The file
can be explicitly defined and @code{INPUT}, @code{OUTPUT} or a certain
@code{fopen()} mode can be given (i.e.@ ``a''). If not explicitly given,
the nature of the file will be taken from context, i.e.@ @code{FILE}s in
@code{PRINT} will be @code{OUTPUT} and @code{FILE}s in @code{FUNCTION}
will be @code{INPUT}. This keyword justs defines the @code{FILE}, it
does not open it. The file will be actually openened (and eventually
closed) automatically. In the rare case where the automated opening and
closing does not fit the expected workflow, the file can be explicitly
opened or closed with the instructions @code{FILE_OPEN} and
@code{FILE_CLOSE}.

@node FIT
@subsubsection @code{FIT}
@anchor{#fit}
Find parameters to fit an analytical function to a pointwise-defined
function.

@smallformat
@verbatim
FIT <function_to_be_fitted>  TO <function_with_data> VIA <var_1> <var_2> ... <var_n>
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ RANGE_MIN <expr_1> <expr_2> ... <expr_j> ]
 [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ]
 [ TOL_REL <expr> ] [ TOL_ABS <expr> ] [ MAX_ITER <expr> ]
 [ VERBOSE ]  
@end verbatim
@end smallformat

The function with the data has to be point-wise defined (i.e.@ a
@code{FUNCTION} read from a file, with inline @code{DATA} or defined
over a mesh). The function to be fitted has to be parametrized with at
least one of the variables provided after the @code{USING} keyword. For
example to fit@ @math{f(x,y)=a x^2 + b sqrt(y)} to a pointwise-defined
function@ @math{g(x,y)} one gives @code{FIT f TO g VIA a b}. Only the
names of the functions have to be given, not the arguments. Both
functions have to have the same number of arguments. The initial guess
of the solution is given by the initial value of the variables after the
@code{VIA} keyword. Analytical expressions for the gradient of the
function to be fitted with respect to the parameters to be fitted can be
optionally given with the @code{GRADIENT} keyword. If none is provided,
the gradient will be computed numerically using finite differences. A
range over which the residuals are to be minimized can be given with
@code{RANGE_MIN} and @code{RANGE_MAX}. The expressions give the range of
the arguments of the functions, not of the parameters. For
multidimensional fits, the range is an hypercube. If no range is given,
all the definition points of the function with the data are used for the
fit. Convergence can be controlled by giving the relative and absolute
tolreances with @code{TOL_REL} (default @code{DEFAULT_NLIN_FIT_EPSREL})
and @code{TOL_ABS} (default @code{DEFAULT_NLIN_FIT_EPSABS}), and with
the maximum number of iterations @code{MAX_ITER} (default
DEFAULT_NLIN_FIT_MAX_ITER). If the optional keyword @code{VERBOSE} is
given, some data of the intermediate steps is written in the standard
output.

@node FUNCTION
@subsubsection @code{FUNCTION}
@anchor{#function}
Define a function of one or more variables.

@smallformat
@verbatim
FUNCTION <function_name>(<var_1>[,var2,...,var_n]) { = <expr> | FILE { <file_path> | <file_id> } | VECTORS <vector_1> <vector_2> ... <vector_n> <vector_data> | DATA <num_1> <num_2> ... <num_N> } [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | nearest | shepard | shepard_kd | bilinear } ] [COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ]  
@end verbatim
@end smallformat

The number of variables @math{n} is given by the number of arguments
given between parenthesis after the function name. The arguments are
defined as new variables if they had not been already defined explictly
as scalar variables. If the function is given as an algebraic
expression, the short-hand operator @code{:=} can be used. That is to
say, @code{FUNCTION f(x) = x^2} is equivalent to @code{f(x) := x^2}. If
a @code{FILE} is given, an ASCII file containing at least @math{n+1}
columns is expected. By default, the first @math{n} columns are the
values of the arguments and the last column is the value of the function
at those points. The order of the columns can be changed with the
keyword @code{COLUMNS}, which expects @math{n+1} expressions
corresponding to the column numbers. If @code{VECTORS} is given, a set
of @math{n+1} vectors of the same size is expected. The first @math{n}
correspond to the arguments and the last one to the function values. The
function can be pointwise-defined inline in the input using @code{DATA}.
This should be the last keyword of the line, followed by
@math{N=k \cdot (n+1)} expresions giving@ @math{k} definition points:
@math{n} arguments and the value of the function. Multiline continuation
using brackets @code{@{} and @code{@}} can be used for a clean data
organization. Interpolation schemes can be given for either one or
multi-dimensional functions with @code{INTERPOLATION}. Available schemes
for @math{n=1} are:

@itemize
@item
linear
@item
polynomial, the grade is equal to the number of data minus one
@item
spline, cubic (needs at least 3 points)
@item
spline_periodic
@item
akima (needs at least 5 points)
@item
akima_periodic (needs at least 5 points)
@item
steffen, always-monotonic splines-like interpolator
@end itemize

Default interpolation scheme for one-dimensional functions is
@code{DEFAULT_INTERPOLATION}.

Available schemes for @math{n>1} are:

@itemize
@item
nearest, @math{f(\vec{x})} is equal to the value of the closest
definition point
@item
shepard,
@uref{https://en.wikipedia.org/wiki/Inverse_distance_weighting,inverse
distance weighted average definition points} (might lead to inefficient
evaluation)
@item
shepard_kd,
@uref{https://en.wikipedia.org/wiki/Inverse_distance_weighting#Modified_Shepard's_method,average
of definition points within a kd-tree} (more efficient evaluation
provided @code{SHEPARD_RADIUS} is set to a proper value)
@item
bilinear, only available if the definition points configure an
structured hypercube-like grid. If @math{n>3}, @code{SIZES} should be
given.
@end itemize

For @math{n>1}, if the euclidean distance between the arguments and the
definition points is smaller than @code{INTERPOLATION_THRESHOLD}, the
definition point is returned and no interpolation is performed. Default
value is square root of @code{DEFAULT_MULTIDIM_INTERPOLATION_THRESHOLD}.
The initial radius of points to take into account in @code{shepard_kd}
is given by @code{SHEPARD_RADIUS}. If no points are found, the radius is
double until at least one definition point is found. The radius is
doubled until at least one point is found. Default is
@code{DEFAULT_SHEPARD_RADIUS}. The exponent of the @code{shepard} method
is given by @code{SHEPARD_EXPONENT}. Default is
@code{DEFAULT_SHEPARD_EXPONENT}.

@node IF
@subsubsection @code{IF}
@anchor{#if}
Execute a set of instructions if a condition is met.

@smallformat
@verbatim
IF expr 
  <block_of_instructions_if_expr_is_true> 
 [ ELSE  
  <block_of_instructions_if_expr_is_false> ] 
 ENDIF  
@end verbatim
@end smallformat

@node IMPLICIT
@subsubsection @code{IMPLICIT}
@anchor{#implicit}
Define whether implicit definition of variables is allowed or not.

@smallformat
@verbatim
IMPLICIT { NONE | ALLOWED }  
@end verbatim
@end smallformat

By default, FeenoX allows variables (but not vectors nor matrices) to be
implicitly declared. To avoid introducing errors due to typos, explicit
declaration of variables can be forced by giving @code{IMPLICIT NONE}.
Whether implicit declaration is allowed or explicit declaration is
required depends on the last @code{IMPLICIT} keyword given, which by
default is @code{ALLOWED}.

@node INCLUDE
@subsubsection @code{INCLUDE}
@anchor{#include}
Include another FeenoX input file.

@smallformat
@verbatim
INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]  
@end verbatim
@end smallformat

Includes the input file located in the string @code{file_path} at the
current location. The effect is the same as copying and pasting the
contents of the included file at the location of the @code{INCLUDE}
keyword. The path can be relative or absolute. Note, however, that when
including files inside @code{IF} blocks that instructions are
conditionally-executed but all definitions (such as function
definitions) are processed at parse-time independently from the
evaluation of the conditional. The included file has to be an actual
file path (i.e.@ it cannot be a FeenoX @code{FILE}) because it needs to
be resolved at parse time. Yet, the name can contain a commandline
replacement argument such as @code{$1} so @code{INCLUDE $1.fee} will
include the file specified after the main input file in the command
line. The optional @code{FROM} and @code{TO} keywords can be used to
include only portions of a file.

@node MATRIX
@subsubsection @code{MATRIX}
@anchor{#matrix}
Define a matrix.

@smallformat
@verbatim
MATRIX <name> ROWS <expr> COLS <expr> [ DATA <expr_1> <expr_2> ... <expr_n> |  
@end verbatim
@end smallformat

A new matrix of the prescribed size is defined. The number of rows and
columns can be an expression which will be evaluated the very first time
the matrix is used and then kept at those constant values. All elements
will be initialized to zero unless @code{DATA} is given (which should be
the last keyword of the line), in which case the expressions will be
evaluated the very first time the matrix is used and row-major-assigned
to each of the elements. If there are less elements than the matrix
size, the remaining values will be zero. If there are more elements than
the matrix size, the values will be ignored.

@node OPEN
@subsubsection @code{OPEN}
@anchor{#open}
Explicitly open a file for input/output.

@smallformat
@verbatim
OPEN <name> [ MODE <fopen_mode> ]  
@end verbatim
@end smallformat

The given @code{<name>} can be either a fixed-string path or an
already-defined @code{FILE}. The mode is only taken into account if the
file is not already defined. Default is write @code{w}.

@node PRINT
@subsubsection @code{PRINT}
@anchor{#print}
Write plain-text and/or formatted data to the standard output or into an
output file.

@smallformat
@verbatim
PRINT [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ] 
 [ FILE { <file_path> | <file_id> } ] [ HEADER ] [ NONEWLINE ] [ SEP <string> ] 
 [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] 
  
@end verbatim
@end smallformat

Each argument @code{object} which is not a keyword of the @code{PRINT}
instruction will be part of the output. Objects can be either a matrix,
a vector or any valid scalar algebraic expression. If the given object
cannot be solved into a valid matrix, vector or expression, it is
treated as a string literal if @code{IMPLICIT} is @code{ALLOWED},
otherwise a parser error is raised. To explicitly interpret an object as
a literal string even if it resolves to a valid numerical expression, it
should be prefixed with the @code{TEXT} keyword such as
@code{PRINT TEXT 1+1} that would print @code{1+1} instead of @code{2}.
Objects and string literals can be mixed and given in any order. Hashes
@code{#} appearing literal in text strings have to be quoted to prevent
the parser to treat them as comments within the FeenoX input file and
thus ignoring the rest of the line, like
@code{PRINT "\# this is a printed comment"}. Whenever an argument starts
with a porcentage sign @code{%}, it is treated as a C
@code{printf}-compatible format specifier and all the objects that
follow it are printed using the given format until a new format
definition is found. The objects are treated as double-precision
floating point numbers, so only floating point formats should be given.
See the @code{printf(3)} man page for further details. The default
format is @code{DEFAULT_PRINT_FORMAT}. Matrices, vectors, scalar
expressions, format modifiers and string literals can be given in any
desired order, and are processed from left to right. Vectors are printed
element-by-element in a single row. See @code{PRINT_VECTOR} to print one
or more vectors with one element per line (i.e.@ vertically). Matrices
are printed element-by-element in a single line using row-major ordering
if mixed with other objects but in the natural row and column fashion if
it is the only given object in the @code{PRINT} instruction. If the
@code{FILE} keyword is not provided, default is to write to
@code{stdout}. If the @code{HEADER} keyword is given, a single line
containing the literal text given for each object is printed at the very
first time the @code{PRINT} instruction is processed, starting with a
hash @code{#} character. If the @code{NONEWLINE} keyword is not
provided, default is to write a newline @code{\n} character after all
the objects are processed. Otherwise, if the last token to be printed is
a numerical value, a separator string will be printed but not the
newline @code{\n} character. If the last token is a string, neither the
separator nor the newline will be printed. The @code{SEP} keyword
expects a string used to separate printed objects. To print objects
without any separation in between give an empty string like
@code{SEP ""}. The default is a tabulator character
`DEFAULT_PRINT_SEPARATOR' character. To print an empty line write
@code{PRINT} without arguments. By default the @code{PRINT} instruction
is evaluated every step. If the @code{SKIP_STEP}
(@code{SKIP_STATIC_STEP}) keyword is given, the instruction is processed
only every the number of transient (static) steps that results in
evaluating the expression, which may not be constant. The
@code{SKIP_HEADER_STEP} keyword works similarly for the optional
@code{HEADER} but by default it is only printed once. The
@code{SKIP_TIME} keyword use time advancements to choose how to skip
printing and may be useful for non-constant time-step problems.

@node PRINT_FUNCTION
@subsubsection @code{PRINT_FUNCTION}
@anchor{#print_function}
Print one or more functions as a table of values of dependent and
independent variables.

@smallformat
@verbatim
PRINT_FUNCTION <function_1> [ { function | expr } ... { function | expr } ] 
 [ FILE { <file_path> | <file_id> } ] [ HEADER ] 
 [ MIN <expr_1> <expr_2> ... <expr_k> ] [ MAX <expr_1> <expr_2> ... <expr_k> ] 
 [ STEP <expr_1> <expr_2> ... <expr_k> ] [ NSTEPs <expr_1> <expr_2> ... <expr_k> ] 
 [ FORMAT <print_format> ] <vector_1> [ { vector | expr } ... { vector | expr } ]  
@end verbatim
@end smallformat

Each argument should be either a function or an expression. The output
of this instruction consists of@ @math{n+k} columns, where@ @math{n} is
the number of arguments of the first function of the list and@ @math{k}
is the number of functions and expressions given. The first@ @math{n}
columns are the arguments (independent variables) and the last@ @math{k}
one has the evaluated functions and expressions. The columns are
separated by a tabulator, which is the format that most plotting tools
understand. Only function names without arguments are expected. All
functions should have the same number of arguments. Expressions can
involve the arguments of the first function. If the @code{FILE} keyword
is not provided, default is to write to @code{stdout}. If @code{HEADER}
is given, the output is prepended with a single line containing the
names of the arguments and the names of the functions, separated by
tabs. The header starts with a hash@ @code{#} that usually acts as a
comment and is ignored by most plotting tools. If there is no explicit
range where to evaluate the functions and the first function is
point-wise defined, they are evalauted at the points of definition of
the first one. The range can be explicitly given as a product
of@ @math{n} ranges@ @math{[x_{i,\min},x_{i,\max}]} for
@math{i=1,\dots,n}. The values @math{x_{i,\min}} and @math{x_{i,\max}}
are given with the @code{MIN} @emph{and} @code{MAX} keywords. The
discretization steps of the ranges are given by either @code{STEP} that
gives@ @math{\delta x} @emph{or} @code{NSTEPS} that gives the number of
steps. If the first function is not point-wise defined, the ranges are
mandatory.

@node PRINT_VECTOR
@subsubsection @code{PRINT_VECTOR}
@anchor{#print_vector}
Print the elements of one or more vectors, one element per line.

@smallformat
@verbatim
PRINT_VECTOR 
 [ FILE { <file_path> | <file_id> } ] [ HEADER ] 
 [ FORMAT <print_format> ]  
@end verbatim
@end smallformat

Each argument should be either a vector or an expression of the
integer@ @code{i}. If the @code{FILE} keyword is not provided, default
is to write to @code{stdout}. If @code{HEADER} is given, the output is
prepended with a single line containing the names of the arguments and
the names of the functions, separated by tabs. The header starts with a
hash@ @code{#} that usually acts as a comment and is ignored by most
plotting tools.

@node SORT_VECTOR
@subsubsection @code{SORT_VECTOR}
@anchor{#sort_vector}
Sort the elements of a vector, optionally making the same rearrangement
in another vector.

@smallformat
@verbatim
SORT_VECTOR <vector> [ ASCENDING | DESCENDING ] [ <other_vector> ]  
@end verbatim
@end smallformat

This instruction sorts the elements of @code{<vector>} into either
ascending or descending numerical order. If @code{<other_vector>} is
given, the same rearrangement is made on it. Default is ascending order.

@node VAR
@subsubsection @code{VAR}
@anchor{#var}
Explicitly define one or more scalar variables.

@smallformat
@verbatim
VAR <name_1> [ <name_2> ] ... [ <name_n> ]  
@end verbatim
@end smallformat

When implicit definition is allowed (see
@ref{#implicit,@code{IMPLICIT}}), scalar variables need not to be
defined before being used if from the context FeenoX can tell that an
scalar variable is needed. For instance, when defining a function like
@code{f(x) = x^2} it is not needed to declare @code{x} explictly as a
scalar variable. But if one wants to define a function like
@code{g(x) = integral(f(x'), x', 0, x)} then the variable @code{x'}
needs to be explicitly defined as @code{VAR x'} before the integral.

@node VECTOR
@subsubsection @code{VECTOR}
@anchor{#vector}
Define a vector.

@smallformat
@verbatim
VECTOR <name> SIZE <expr> [ FUNCTION_DATA <function> ] [ DATA <expr_1> <expr_2> ... <expr_n> |  
@end verbatim
@end smallformat

A new vector of the prescribed size is defined. The size can be an
expression which will be evaluated the very first time the vector is
used and then kept at that constant value. If the keyword
@code{FUNCTION_DATA} is given, the elements of the vector will be
synchronized with the inpedendent values of the function, which should
be point-wise defined. The sizes of both the function and the vector
should match. All elements will be initialized to zero unless
@code{DATA} is given (which should be the last keyword of the line), in
which case the expressions will be evaluated the very first time the
vector is used and assigned to each of the elements. If there are less
elements than the vector size, the remaining values will be zero. If
there are more elements than the vector size, the values will be
ignored.

@node Variables
@subsection Variables
@anchor{#variables-4}

@menu
* done::
* done_static::
* done_transient::
* dt::
* end_time::
* i::
* infinite::
* in_static::
* in_static_first::
* in_static_last::
* in_transient::
* in_transient_first::
* in_transient_last::
* j::
* max_dt::
* min_dt::
* ncores::
* on_gsl_error::
* on_ida_error::
* on_nan::
* pi::
* pid::
* realtime_scale::
* static_steps::
* step_static::
* step_transient::
* t::
* zero::
@end menu

@node done
@subsubsection @code{done}
@anchor{#done}
Flag that indicates whether the overall calculation is over.

This variable is set to true by FeenoX when the computation finished so
it can be checked in an @code{IF} block to do something only in the last
step. But this variable can also be set to true from the input file,
indicating that the current step should also be the last one. For
example, one can set @code{end_time = infinite} and then finish the
computation at @math{t=10} by setting @code{done = t > 10}. This
@code{done} variable can also come from (and sent to) other sources,
like a shared memory object for coupled calculations.

@node done_static
@subsubsection @code{done_static}
@anchor{#done_static}
Flag that indicates whether the static calculation is over or not.

It is set to true (i.e.@ @math{\neq 0}) by feenox if @code{step_static}
@math{\ge} @code{static_steps}. If the user sets it to true, the current
step is marked as the last static step and the static calculation ends
after finishing the step. It can be used in @code{IF} blocks to check if
the static step is finished or not.

@node done_transient
@subsubsection @code{done_transient}
@anchor{#done_transient}
Flag that indicates whether the transient calculation is over or not.

It is set to true (i.e.@ @math{\neq 0}) by feenox if @code{t} @math{\ge}
@code{end_time}. If the user sets it to true, the current step is marked
as the last transient step and the transient calculation ends after
finishing the step. It can be used in @code{IF} blocks to check if the
transient steps are finished or not.

@node dt
@subsubsection @code{dt}
@anchor{#dt}
Actual value of the time step for transient calculations.

When solving DAE systems, this variable is set by feenox. It can be
written by the user for example by importing it from another transient
code by means of shared-memory objects. Care should be taken when
solving DAE systems and overwriting @code{t}. Default value is
DEFAULT_DT, which is a power of two and roundoff errors are thus
reduced.

@node end_time
@subsubsection @code{end_time}
@anchor{#end_time}
Final time of the transient calculation, to be set by the user.

The default value is zero, meaning no transient calculation.

@node i
@subsubsection @code{i}
@anchor{#i}
Dummy index, used mainly in vector and matrix row subindex expressions.

@node infinite
@subsubsection @code{infinite}
@anchor{#infinite}
A very big positive number.

It can be used as @code{end_time = infinite} or to define improper
integrals with infinite limits. Default is
@math{2^{50} \approx 1 \times 10^{15}}.

@node in_static
@subsubsection @code{in_static}
@anchor{#in_static}
Flag that indicates if FeenoX is solving the iterative static
calculation.

This is a read-only variable that is non zero if the static calculation.

@node in_static_first
@subsubsection @code{in_static_first}
@anchor{#in_static_first}
Flag that indicates if feenox is in the first step of the iterative
static calculation.

@node in_static_last
@subsubsection @code{in_static_last}
@anchor{#in_static_last}
Flag that indicates if feenox is in the last step of the iterative
static calculation.

@node in_transient
@subsubsection @code{in_transient}
@anchor{#in_transient}
Flag that indicates if feenox is solving transient calculation.

@node in_transient_first
@subsubsection @code{in_transient_first}
@anchor{#in_transient_first}
Flag that indicates if feenox is in the first step of the transient
calculation.

@node in_transient_last
@subsubsection @code{in_transient_last}
@anchor{#in_transient_last}
Flag that indicates if feenox is in the last step of the transient
calculation.

@node j
@subsubsection @code{j}
@anchor{#j}
Dummy index, used mainly in matrix column subindex expressions.

@node max_dt
@subsubsection @code{max_dt}
@anchor{#max_dt}
Maximum bound for the time step that feenox should take when solving DAE
systems.

@node min_dt
@subsubsection @code{min_dt}
@anchor{#min_dt}
Minimum bound for the time step that feenox should take when solving DAE
systems.

@node ncores
@subsubsection @code{ncores}
@anchor{#ncores}
The number of online available cores, as returned by
@code{sysconf(_SC_NPROCESSORS_ONLN)}.

This value can be used in the @code{MAX_DAUGHTERS} expression of the
@code{PARAMETRIC} keyword (i.e @code{ncores/2}).

@node on_gsl_error
@subsubsection @code{on_gsl_error}
@anchor{#on_gsl_error}
This should be set to a mask that indicates how to proceed if an error
ir raised in any routine of the GNU Scientific Library.

@node on_ida_error
@subsubsection @code{on_ida_error}
@anchor{#on_ida_error}
This should be set to a mask that indicates how to proceed if an error
ir raised in any routine of the SUNDIALS Library.

@node on_nan
@subsubsection @code{on_nan}
@anchor{#on_nan}
This should be set to a mask that indicates how to proceed if
Not-A-Number signal (such as a division by zero) is generated when
evaluating any expression within feenox.

@node pi
@subsubsection @code{pi}
@anchor{#pi}
A double-precision floating point representaion of the number @math{\pi}

It is equal to the @code{M_PI} constant in @code{math.h} .

@node pid
@subsubsection @code{pid}
@anchor{#pid}
The UNIX process id of the FeenoX instance.

@node realtime_scale
@subsubsection @code{realtime_scale}
@anchor{#realtime_scale}
If this variable is not zero, then the transient problem is run trying
to syncrhonize the problem time with realtime, up to a scale given.

For example, if the scale is set to one, then FeenoX will advance the
problem time at the same pace that the real wall time advances. If set
to two, FeenoX time wil advance twice as fast as real time, and so on.
If the calculation time is slower than real time modified by the scale,
this variable has no effect on the overall behavior and execution will
proceed as quick as possible with no delays.

@node static_steps
@subsubsection @code{static_steps}
@anchor{#static_steps}
Number of steps that ought to be taken during the static calculation, to
be set by the user.

The default value is one, meaning only one static step.

@node step_static
@subsubsection @code{step_static}
@anchor{#step_static}
Indicates the current step number of the iterative static calculation.

This is a read-only variable that contains the current step of the
static calculation.

@node step_transient
@subsubsection @code{step_transient}
@anchor{#step_transient}
Indicates the current step number of the transient static calculation.

This is a read-only variable that contains the current step of the
transient calculation.

@node t
@subsubsection @code{t}
@anchor{#t}
Actual value of the time for transient calculations.

This variable is set by FeenoX, but can be written by the user for
example by importing it from another transient code by means of
shared-memory objects. Care should be taken when solving DAE systems and
overwriting @code{t}.

@node zero
@subsubsection @code{zero}
@anchor{#zero}
A very small positive number.

It is taken to avoid roundoff errors when comparing floating point
numbers such as replacing @math{a \leq a_\text{max}} with
@math{a < a_\text{max} +} @code{zero}. Default is
@math{(1/2)^{-50} \approx 9\times 10^{-16}} .

@node Functions
@section Functions
@anchor{#functions}

@menu
* abs::
* acos::
* asin::
* atan::
* atan2::
* ceil::
* clock::
* cos::
* cosh::
* cpu_time::
* d_dt::
* deadband::
* equal::
* exp::
* expint1::
* expint2::
* expint3::
* expintn::
* floor::
* heaviside::
* if::
* integral_dt::
* integral_euler_dt::
* is_even::
* is_in_interval::
* is_odd::
* j0::
* lag::
* lag_bilinear::
* lag_euler::
* last::
* limit::
* limit_dt::
* log::
* mark_max::
* mark_min::
* max::
* memory::
* min::
* mod::
* not::
* random::
* random_gauss::
* round::
* sawtooth_wave::
* sgn::
* sin::
* sinh::
* sqrt::
* square_wave::
* tan::
* tanh::
* threshold_max::
* threshold_min::
* triangular_wave::
* wall_time::
@end menu

@node abs
@subsection @code{abs}
@anchor{#abs}
Returns the absolute value of the argument@ @math{x}.

@smallformat
@verbatim
abs(x)  
@end verbatim
@end smallformat

@math{|x|}
@image{figures/abs,,,abs,svg}@ 

@menu
* Example #1 absfee::
@end menu

@node Example #1 absfee
@subsubsection Example #1, abs.fee
@anchor{#example-1-abs.fee}

@smallformat
@verbatim
PRINT sqrt(abs(-2))

# exercise: remove the absolute value from the sqrt argument
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox abs.fee
1.41421
$
@end verbatim
@end smallformat

@node acos
@subsection @code{acos}
@anchor{#acos}
Computes the arc in radians whose cosine is equal to the
argument@ @math{x}. A NaN error is raised if@ @math{|x|>1}.

@smallformat
@verbatim
acos(x)  
@end verbatim
@end smallformat

@math{\arccos(x)}
@image{figures/acos,,,acos,svg}@ 

@menu
* Example #1 acosfee::
@end menu

@node Example #1 acosfee
@subsubsection Example #1, acos.fee
@anchor{#example-1-acos.fee}

@smallformat
@verbatim
PRINT acos(0)
PRINT acos(1)
PRINT cos(acos(0.5))  acos(cos(0.5))
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox acos.fee
1.5708
0
0.5	0.5
$
@end verbatim
@end smallformat

@node asin
@subsection @code{asin}
@anchor{#asin}
Computes the arc in radians whose sine is equal to the
argument@ @math{x}. A NaN error is raised if@ @math{|x|>1}.

@smallformat
@verbatim
asin(x)  
@end verbatim
@end smallformat

@math{\arcsin(x)}
@image{figures/asin,,,asin,svg}@ 

@menu
* Example #1 asinfee::
@end menu

@node Example #1 asinfee
@subsubsection Example #1, asin.fee
@anchor{#example-1-asin.fee}

@smallformat
@verbatim
PRINT asin(0)
PRINT asin(1)
PRINT sin(asin(0.5))  asin(sin(0.5))
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox asin.fee
0
1.5708
0.5	0.5
$
@end verbatim
@end smallformat

@node atan
@subsection @code{atan}
@anchor{#atan}
Computes, in radians, the arc tangent of the argument@ @math{x}.

@smallformat
@verbatim
atan(x)  
@end verbatim
@end smallformat

@math{\arctan(x)}
@image{figures/atan,,,atan,svg}@ 

@node atan2
@subsection @code{atan2}
@anchor{#atan2}
Computes, in radians, the arc tangent of quotient@ @math{y/x}, using the
signs of the two arguments to determine the quadrant of the result,
which is in the range @math{[-\pi,\pi]}.

@smallformat
@verbatim
atan2(y,x)  
@end verbatim
@end smallformat

@math{\arctan(y/x)}

@menu
* Example #1 atanfee::
* Example #2 atan2fee::
@end menu

@node Example #1 atanfee
@subsubsection Example #1, atan.fee
@anchor{#example-1-atan.fee}

@smallformat
@verbatim
PRINT atan(-0.5)  mod(atan(-0.5),2*pi)-pi
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox atan.fee
-0.463648	2.67795
$
@end verbatim
@end smallformat

@node Example #2 atan2fee
@subsubsection Example #2, atan2.fee
@anchor{#example-2-atan2.fee}

@smallformat
@verbatim
PRINT atan2(1,-2) mod(atan(-0.5),2*pi)-pi
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox atan2.fee
2.67795	2.67795
$
@end verbatim
@end smallformat

@node ceil
@subsection @code{ceil}
@anchor{#ceil}
Returns the smallest integral value not less than the
argument@ @math{x}.

@smallformat
@verbatim
ceil(x)  
@end verbatim
@end smallformat

@math{\lceil x \rceil}
@image{figures/ceil,,,ceil,svg}@ 

@node clock
@subsection @code{clock}
@anchor{#clock}
Returns the value of a certain clock in seconds measured from a certain
(but specific) milestone. The kind of clock and the initial milestone
depend on the optional integer argument@ @math{f}. It defaults to one,
meaning @code{CLOCK_MONOTONIC}. The list and the meanings of the other
available values for@ @math{f} can be checked in the
@code{clock_gettime (2)} system call manual page.

@smallformat
@verbatim
clock([f])  
@end verbatim
@end smallformat

@menu
* Example #1 clockfee::
@end menu

@node Example #1 clockfee
@subsubsection Example #1, clock.fee
@anchor{#example-1-clock.fee}

@smallformat
@verbatim
t1 = clock()
PRINT "doing something in between"
t2 = clock()
PRINT "difference" t2-t1 "[seconds]"
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox clock.fee
doing something in between
difference	0.000149072	[seconds]
$
@end verbatim
@end smallformat

@node cos
@subsection @code{cos}
@anchor{#cos}
Computes the cosine of the argument@ @math{x}, where@ @math{x} is in
radians. A cosine wave can be generated by passing as the
argument@ @math{x} a linear function of time such
as@ @math{\omega t+\phi}, where @math{\omega} controls the frequency of
the wave and @math{\phi} controls its phase.

@smallformat
@verbatim
cos(x)  
@end verbatim
@end smallformat

@math{\cos(x)}
@image{figures/cos,,,cos,svg}@ 

@node cosh
@subsection @code{cosh}
@anchor{#cosh}
Computes the hyperbolic cosine of the argument@ @math{x},
where@ @math{x} is in radians.

@smallformat
@verbatim
cosh(x)  
@end verbatim
@end smallformat

@math{\cosh(x)}
@image{figures/cosh,,,cosh,svg}@ 

@node cpu_time
@subsection @code{cpu_time}
@anchor{#cpu_time}
Returns the CPU time used by FeenoX, in seconds. If the optional
argument @code{f} is not provided or it is zero (default), the sum of
times for both user-space and kernel-space usage is returned. For
@code{f=1} only user time is returned. For @code{f=2} only system time
is returned.

@smallformat
@verbatim
cpu_time([f])  
@end verbatim
@end smallformat

@node d_dt
@subsection @code{d_dt}
@anchor{#d_dt}
Computes the time derivative of the expression given in the
argument@ @math{x} during a transient problem using the difference
between the value of the signal in the previous time step and the actual
value divided by the time step@ @math{\delta t} stored in @code{dt}. The
argument@ @math{x} does not neet to be a variable, it can be an
expression involving one or more variables that change in time. For
@math{t=0}, the return value is zero. Unlike the functional
@code{derivative}, the full dependence of these variables with time does
not need to be known beforehand, i.e.@ the expression @code{x} might
involve variables read from a shared-memory object at each time step.

@smallformat
@verbatim
d_dt(x)  
@end verbatim
@end smallformat

@math{\frac{x(t) - x(t-\Delta t)}{\Delta t} \approx \frac{d}{dt} \Big( x (t) \Big)}

@menu
* Example #1 d_dtfee::
@end menu

@node Example #1 d_dtfee
@subsubsection Example #1, d_dt.fee
@anchor{#example-1-d_dt.fee}

@smallformat
@verbatim
end_time = 5
dt = 1/10
t0 = 0.5
r = heaviside(t-t0)

PRINT t r lag(r,1) d_dt(lag(r,1)) r*exp(-(t-t0)) HEADER

# exercise: plot output for different values of dt
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox d_dt.fee > d_dt.dat
$
@end verbatim
@end smallformat

@image{examples/d_dt,,,d_dt.fee,svg}@ 

@node deadband
@subsection @code{deadband}
@anchor{#deadband}
Filters the first argument@ @math{x} with a deadband centered at zero
with an amplitude given by the second argument @math{a}.

@smallformat
@verbatim
deadband(x, a)  
@end verbatim
@end smallformat

@math{\begin{cases} 0 & \text{if $| x | \leq a$} \\ x + a & \text{if $x < a$} \\ x - a & \text{if $x > a$} \end{cases}}

@node equal
@subsection @code{equal}
@anchor{#equal}
Checks if the two first expressions @math{a} and @math{b} are equal, up
to the tolerance given by the third optional argument @math{\epsilon}.
If either @math{|a|>1} or @math{|b|>1}, the arguments are compared using
GSL's @code{gsl_fcmp}, otherwise the absolute value of their difference
is compared against @math{\epsilon}. This function returns zero if the
arguments are not equal and one otherwise. Default value for
@math{\epsilon = 10^{-9}}.

@smallformat
@verbatim
equal(a, b, [eps])  
@end verbatim
@end smallformat

@math{\begin{cases} 1 & \text{if $a = b$} \\ 0 & \text{if $a \neq b$} \end{cases}}

@node exp
@subsection @code{exp}
@anchor{#exp}
Computes the exponential function the argument@ @math{x}, i.e.@ the base
of the natural logarithm@ @math{e} raised to the@ @math{x}-th power.

@smallformat
@verbatim
exp(x)  
@end verbatim
@end smallformat

@math{e^x}
@image{figures/exp,,,exp,svg}@ 

@menu
* Example #1 expfee::
@end menu

@node Example #1 expfee
@subsubsection Example #1, exp.fee
@anchor{#example-1-exp.fee}

@smallformat
@verbatim
PHASE_SPACE x
end_time = 1
alpha = 1.8
x_0 = 1.2
y(t) := x_0 * exp(-alpha*t)

x_dot .= -alpha*x

PRINT t x y(t) y(t)-x 
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox exp.fee > exp.dat
$
@end verbatim
@end smallformat

@image{examples/exp,,,exp.fee,svg}@ 

@node expint1
@subsection @code{expint1}
@anchor{#expint1}
Computes the first exponential integral function of the
argument@ @math{x}. If@ @math{x} is zero, a NaN error is issued.

@smallformat
@verbatim
expint1(x)  
@end verbatim
@end smallformat

@math{\text{Re} \left[ \int_1^{\infty}\! \frac{\exp(-xt)}{t} \, dt \right]}
@image{figures/expint1,,,expint1,svg}@ 

@menu
* Example #1 expint1fee::
@end menu

@node Example #1 expint1fee
@subsubsection Example #1, expint1.fee
@anchor{#example-1-expint1.fee}

@smallformat
@verbatim
Def(x) := integral(exp(-x*t)/t,t,1,99)
PRINT_FUNCTION Def expint1(x) MIN 1e-2 MAX 2.0 STEP 1e-2 HEADER
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox expint1.fee > expint1.dat
$
@end verbatim
@end smallformat

@image{examples/expint1,,,expint1.fee,svg}@ 

@node expint2
@subsection @code{expint2}
@anchor{#expint2}
Computes the second exponential integral function of the
argument@ @math{x}.

@smallformat
@verbatim
expint2(x)  
@end verbatim
@end smallformat

@math{\text{Re} \left[ \int_1^{\infty}\! \frac{\exp(-xt)}{t^2} \, dt \right]}
@image{figures/expint2,,,expint2,svg}@ 

@node expint3
@subsection @code{expint3}
@anchor{#expint3}
Computes the third exponential integral function of the
argument@ @math{x}.

@smallformat
@verbatim
expint3(x)  
@end verbatim
@end smallformat

@math{\text{Re} \left[ \int_1^{\infty}\! \frac{\exp(-xt)}{t^3} \, dt \right]}
@image{figures/expint3,,,expint3,svg}@ 

@node expintn
@subsection @code{expintn}
@anchor{#expintn}
Computes the @math{n}-th exponential integral function of the
argument@ @math{x}. If@ @math{n} is zero or one and@ @math{x} is zero, a
NaN error is issued.

@smallformat
@verbatim
expintn(n,x)  
@end verbatim
@end smallformat

@math{\text{Re} \left[ \int_1^{\infty}\! \frac{\exp(-xt)}{t^n} \, dt \right]}

@node floor
@subsection @code{floor}
@anchor{#floor}
Returns the largest integral value not greater than the
argument@ @math{x}.

@smallformat
@verbatim
floor(x)  
@end verbatim
@end smallformat

@math{\lfloor x \rfloor}
@image{figures/floor,,,floor,svg}@ 

@node heaviside
@subsection @code{heaviside}
@anchor{#heaviside}
Computes the zero-centered Heaviside step function of the
argument@ @math{x}. If the optional second argument @math{\delta} is
provided, the discontinuous step at@ @math{x=0} is replaced by a ramp
starting at@ @math{x=0} and finishing at@ @math{x=\delta}.

@smallformat
@verbatim
heaviside(x, [delta])  
@end verbatim
@end smallformat

@math{\begin{cases} 0 & \text{if $x < 0$} \\ x / \delta & \text{if $0 < x < \delta$} \\ 1 & \text{if $x > \delta$} \end{cases}}
@image{figures/heaviside,,,heaviside,svg}@ 

@menu
* Example #1 heavisidefee::
@end menu

@node Example #1 heavisidefee
@subsubsection Example #1, heaviside.fee
@anchor{#example-1-heaviside.fee}

@smallformat
@verbatim
end_time = 1

PRINT t heaviside(t-0.5,0.25)

# exercise: what happens if the second argument is negative?
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox heaviside.fee > heaviside.dat
$
@end verbatim
@end smallformat

@image{examples/heaviside,,,heaviside.fee,svg}@ 

@node if
@subsection @code{if}
@anchor{#if}
Performs a conditional testing of the first argument @math{a}, and
returns either the second optional argument @math{b} if @math{a} is
different from zero or the third optional argument @math{c} if @math{a}
evaluates to zero. The comparison of the condition @math{a} with zero is
performed within the precision given by the optional fourth argument
@math{\epsilon}. If the second argument @math{c} is not given and
@math{a} is not zero, the function returns one. If the third argument
@math{c} is not given and @math{a} is zero, the function returns zero.
The default precision is @math{\epsilon = 10^{-9}}. Even though
@code{if} is a logical operation, all the arguments and the returned
value are double-precision floating point numbers.

@smallformat
@verbatim
if(a, [b], [c], [eps])  
@end verbatim
@end smallformat

@math{\begin{cases} b & \text{if $|a|<\epsilon$} \\ c & \text{otherwise} \end{cases}}

@node integral_dt
@subsection @code{integral_dt}
@anchor{#integral_dt}
Computes the time integral of the expression given in the
argument@ @math{x} during a transient problem with the trapezoidal rule
using the value of the signal in the previous time step and the current
value. At @math{t = 0} the integral is initialized to zero. Unlike the
functional @code{integral}, the full dependence of these variables with
time does not need to be known beforehand, i.e.@ the expression @code{x}
might involve variables read from a shared-memory object at each time
step.

@smallformat
@verbatim
integral_dt(x)  
@end verbatim
@end smallformat

@math{z^{-1}\left[ \int_0^{t-\Delta t} x(t') \, dt' \right] +  \frac{x(t) + x(t-\Delta t)}{2} \, \Delta t \approx \int_0^{t} x(t') \, dt'}

@menu
* Example #1 integral_dtfee::
@end menu

@node Example #1 integral_dtfee
@subsubsection Example #1, integral_dt.fee
@anchor{#example-1-integral_dt.fee}

@smallformat
@verbatim
end_time = 2*pi
dt = end_time/100

y = sin(t) + random_gauss(0,0.05,0)

PRINT t y integral_dt(y)

# exercise: compute also  the instantaneous 
# mean value of the signal y(t)
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox integral_dt.fee > integral_dt.dat
$
@end verbatim
@end smallformat

@image{examples/integral_dt,,,integral_dt.fee,svg}@ 

@node integral_euler_dt
@subsection @code{integral_euler_dt}
@anchor{#integral_euler_dt}
Idem as @code{integral_dt} but uses the backward Euler rule to update
the instantaenous integral value. This function is provided in case this
particular way of approximating time integrals is needed, for instance
to compare FeenoX solutions with other computer codes. In general, it is
recommended to use @code{integral_dt}.

@smallformat
@verbatim
integral_euler_dt(x)  
@end verbatim
@end smallformat

@math{z^{-1}\left[ \int_0^{t-\Delta t} x(t') \, dt' \right] +   x(t) \, \Delta t \approx \int_0^{t} x(t') \, dt'}

@node is_even
@subsection @code{is_even}
@anchor{#is_even}
Returns one if the argument@ @math{x} rounded to the nearest integer is
even.

@smallformat
@verbatim
is_even(x)  
@end verbatim
@end smallformat

@math{ \begin{cases}1 &\text{if $x$ is even} \\ 0 &\text{if $x$ is odd} \end{cases}}

@node is_in_interval
@subsection @code{is_in_interval}
@anchor{#is_in_interval}
Returns true if the argument@ @math{x} is in the interval@ @math{[a,b)},
i.e.@ including@ @math{a} but excluding@ @math{b}.

@smallformat
@verbatim
is_in_interval(x, a, b)  
@end verbatim
@end smallformat

@math{\begin{cases} 1 & \text{if $a \leq x < b$} \\ 0 & \text{otherwise} \end{cases}}

@node is_odd
@subsection @code{is_odd}
@anchor{#is_odd}
Returns one if the argument@ @math{x} rounded to the nearest integer is
odd.

@smallformat
@verbatim
is_odd(x)  
@end verbatim
@end smallformat

@math{ \begin{cases}1 &\text{if $x$ is odd} \\ 0 &\text{if $x$ is even} \end{cases}}

@node j0
@subsection @code{j0}
@anchor{#j0}
Computes the regular cylindrical Bessel function of zeroth order
evaluated at the argument@ @math{x}.

@smallformat
@verbatim
j0(x)  
@end verbatim
@end smallformat

@math{J_0(x)}
@image{figures/j0,,,j0,svg}@ 

@menu
* Example #1 j0fee::
@end menu

@node Example #1 j0fee
@subsubsection Example #1, j0.fee
@anchor{#example-1-j0.fee}

@smallformat
@verbatim
VAR nu
nu0 = root(j0(nu), nu, 0, 3)
PRINT "J0's first zero is" nu0 SEP " "
PRINT "Indeed, J0(nu0) is equal to" j0(nu0) SEP " "
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox j0.fee
J0's first zero is 2.40483
Indeed, J0(nu0) is equal to 2.32985e-10
$
@end verbatim
@end smallformat

@node lag
@subsection @code{lag}
@anchor{#lag}
Filters the first argument@ @math{x(t)} with a first-order lag of
characteristic time @math{\tau}, i.e.@ this function applies the
transfer function@ @math{G(s) = \frac{1}{1 + s\tau}} to the
time-dependent signal@ @math{x(t)} to obtain a filtered
signal@ @math{y(t)}, by assuming that it is constant during the time
interval@ @math{[t-\Delta t,t]} and using the analytical solution of the
differential equation for that case at@ @math{t = \Delta t} with the
initial condition@ @math{y(0) = y(t-\Delta t)}.

@smallformat
@verbatim
lag(x, tau)  
@end verbatim
@end smallformat

@math{x(t) - \Big[ x(t) - y(t-\Delta t) \Big] \cdot \exp\left(-\frac{\Delta t}{\tau}\right)}

@node lag_bilinear
@subsection @code{lag_bilinear}
@anchor{#lag_bilinear}
Filters the first argument@ @math{x(t)} with a first-order lag of
characteristic time @math{\tau} to the time-dependent
signal@ @math{x(t)} by using the bilinear transformation formula.

@smallformat
@verbatim
lag_bilinear(x, tau)  
@end verbatim
@end smallformat

@math{x(t-\Delta t) \cdot \left[ 1 - \frac{\Delta t}{2\tau} \right] + \left[ \frac{x(t) + x(t - \Delta t)}{1 + \frac{\Delta t}{2\tau}}\right] \cdot \frac{\Delta t}{2\tau}}

@node lag_euler
@subsection @code{lag_euler}
@anchor{#lag_euler}
Filters the first argument@ @math{x(t)} with a first-order lag of
characteristic time @math{\tau} to the time-dependent
signal@ @math{x(t)} by using the Euler forward rule.

@smallformat
@verbatim
lag_euler(x, tau)  
@end verbatim
@end smallformat

@math{x(t-\Delta t) + \Big[ x(t) - x(t - \Delta t) \Big] \cdot \frac{\Delta t}{\tau}}

@node last
@subsection @code{last}
@anchor{#last}
Returns the value the variable@ @math{x} had in the previous time step.
This function is equivalent to the@ @math{Z}-transform operator
``delay'' denoted by@ @math{z^{-1}\left[ x\right]}. For@ @math{t=0} the
function returns the actual value of@ @math{x}. The optional
flag@ @math{p} should be set to one if the reference to @code{last} is
done in an assignment over a variable that already appears inside
expression@ @math{x} such as @code{x = last(x)}. See example number 2.

@smallformat
@verbatim
last(x,[p])  
@end verbatim
@end smallformat

@math{z^{-1}\left[ x \right] = x(t-\Delta t)}

@menu
* Example #1 last1fee::
* Example #2 last2fee::
@end menu

@node Example #1 last1fee
@subsubsection Example #1, last1.fee
@anchor{#example-1-last1.fee}

@smallformat
@verbatim
static_steps = 5
end_time = 1
dt = 0.1

IF in_static
  PRINT step_static last(step_static) last(last(step_static))
ENDIF
IF done_static
  PRINT t last(t) last(last(1-t))
ENDIF  
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox last1.fee
1	1	1
2	1	1
3	2	1
4	3	2
5	4	3
0	0	1
0.1	0	1
0.2	0.1	1
0.3	0.2	0.9
0.4	0.3	0.8
0.5	0.4	0.7
0.6	0.5	0.6
0.7	0.6	0.5
0.8	0.7	0.4
0.9	0.8	0.3
1	0.9	0.2
$
@end verbatim
@end smallformat

@node Example #2 last2fee
@subsubsection Example #2, last2.fee
@anchor{#example-2-last2.fee}

@smallformat
@verbatim
end_time = 1
dt = 0.1

y = y + 1
z  = last(z,1) + 1
z' = last(z')  + 1

PRINT t %g y z z'
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox last2.fee
0	1	1	1
0.1	2	2	1
0.2	3	3	2
0.3	4	4	2
0.4	5	5	3
0.5	6	6	3
0.6	7	7	4
0.7	8	8	4
0.8	9	9	5
0.9	10	10	5
1	11	11	6
$
@end verbatim
@end smallformat

@node limit
@subsection @code{limit}
@anchor{#limit}
Limits the first argument@ @math{x} to the interval @math{[a,b]}. The
second argument @math{a} should be less than the third argument
@math{b}.

@smallformat
@verbatim
limit(x, a, b)  
@end verbatim
@end smallformat

@math{\begin{cases} a & \text{if $x < a$} \\ x & \text{if $a \leq x \leq b$} \\ b & \text{if $x > b$} \end{cases}}

@node limit_dt
@subsection @code{limit_dt}
@anchor{#limit_dt}
Limits the value of the first argument@ @math{x(t)} so to that its time
derivative is bounded to the interval @math{[a,b]}. The second argument
@math{a} should be less than the third argument @math{b}.

@smallformat
@verbatim
limit_dt(x, a, b)  
@end verbatim
@end smallformat

@math{\begin{cases} x(t) & \text{if $a \leq dx/dt \leq b$} \\ x(t-\Delta t) + a \cdot \Delta t & \text{if $dx/dt < a$} \\ x(t-\Delta t) + b \cdot \Delta t & \text{if $dx/dt > b$} \end{cases}}

@node log
@subsection @code{log}
@anchor{#log}
Computes the natural logarithm of the argument@ @math{x}. If@ @math{x}
is zero or negative, a NaN error is issued.

@smallformat
@verbatim
log(x)  
@end verbatim
@end smallformat

@math{\ln(x)}
@image{figures/log,,,log,svg}@ 

@menu
* Example #1 log1fee::
* Example #2 log2fee::
@end menu

@node Example #1 log1fee
@subsubsection Example #1, log1.fee
@anchor{#example-1-log1.fee}

@smallformat
@verbatim
end_time = 1
dt = 1/50

x = d_dt(log(1+t))
y = 1/(1+t)

PRINT t x y y-x 

# exercise: why does this example give a bigger error than the exp.fee example?
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox log1.fee > log1.dat
$
@end verbatim
@end smallformat

@image{examples/log1,,,log1.fee,svg}@ 

@node Example #2 log2fee
@subsubsection Example #2, log2.fee
@anchor{#example-2-log2.fee}

@smallformat
@verbatim
VAR t'
x(t) := derivative(log(1+t'), t', t)
y(t) := 1/(1+t)

PRINT_FUNCTION x y y(t)-x(t) MIN 0 MAX 1 NSTEPS 50

# exercise: why does this example give a smaller error than the exp.fee example?
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox log2.fee > log2.dat
$
@end verbatim
@end smallformat

@image{examples/log2,,,log2.fee,svg}@ 

@node mark_max
@subsection @code{mark_max}
@anchor{#mark_max}
Returns the integer index @math{i} of the maximum of the
arguments@ @math{x_i} provided. Currently only maximum of ten arguments
can be provided.

@smallformat
@verbatim
mark_max(x1, x2, [...], [x10])  
@end verbatim
@end smallformat

@math{ i / \max \Big (x_1, x_2, \dots, x_{10} \Big) = x_i}

@node mark_min
@subsection @code{mark_min}
@anchor{#mark_min}
Returns the integer index @math{i} of the minimum of the
arguments@ @math{x_i} provided. Currently only maximum of ten arguments
can be provided.

@smallformat
@verbatim
mark_max(x1, x2, [...], [x10])  
@end verbatim
@end smallformat

@math{ i / \min \Big (x_1, x_2, \dots, x_{10} \Big) = x_i}

@node max
@subsection @code{max}
@anchor{#max}
Returns the maximum of the arguments@ @math{x_i} provided. Currently
only maximum of ten arguments can be given.

@smallformat
@verbatim
max(x1, x2, [...], [x10])  
@end verbatim
@end smallformat

@math{ \max \Big (x_1, x_2, \dots, x_{10} \Big)}

@node memory
@subsection @code{memory}
@anchor{#memory}
Returns the maximum memory (resident set size) used by FeenoX, in
Gigabytes.

@smallformat
@verbatim
memory()  
@end verbatim
@end smallformat

@node min
@subsection @code{min}
@anchor{#min}
Returns the minimum of the arguments@ @math{x_i} provided. Currently
only maximum of ten arguments can be given.

@smallformat
@verbatim
min(x1, x2, [...], [x10])  
@end verbatim
@end smallformat

@math{ \min \Big (x_1, x_2, \dots, x_{10} \Big)}

@node mod
@subsection @code{mod}
@anchor{#mod}
Returns the remainder of the division between the first
argument@ @math{a} and the second one@ @math{b}. Both arguments may be
non-integral.

@smallformat
@verbatim
mod(a, b)  
@end verbatim
@end smallformat

@math{a - \left\lfloor \frac{a}{b} \right\rfloor \cdot b}

@node not
@subsection @code{not}
@anchor{#not}
Returns one if the first argument@ @math{x} is zero and zero otherwise.
The second optional argument @math{\epsilon} gives the precision of the
``zero'' evaluation. If not given, default is @math{\epsilon = 10^{-9}}.

@smallformat
@verbatim
not(x, [eps])  
@end verbatim
@end smallformat

@math{ \begin{cases}1 &\text{if $|x| < \epsilon$} \\ 0 &\text{otherwise} \end{cases}}

@node random
@subsection @code{random}
@anchor{#random}
Returns a random real number uniformly distributed between the first
real argument@ @math{x_1} and the second one@ @math{x_2}. If the third
integer argument @math{s} is given, it is used as the seed and thus
repetitive sequences can be obtained. If no seed is provided, the
current time (in seconds) plus the internal address of the expression is
used. Therefore, two successive calls to the function without seed
(hopefully) do not give the same result. This function uses a
second-order multiple recursive generator described by Knuth in
Seminumerical Algorithms, 3rd Ed., Section 3.6.

@smallformat
@verbatim
random(x1, x2, [s])  
@end verbatim
@end smallformat

@math{ x_1 + r \cdot (x_2-x_1) \quad \quad 0 \leq r < 1}

@node random_gauss
@subsection @code{random_gauss}
@anchor{#random_gauss}
Returns a random real number with a Gaussian distribution with a mean
equal to the first argument@ @math{x_1} and a standard deviation equatl
to the second one@ @math{x_2}. If the third integer argument @math{s} is
given, it is used as the seed and thus repetitive sequences can be
obtained. If no seed is provided, the current time (in seconds) plus the
internal address of the expression is used. Therefore, two successive
calls to the function without seed (hopefully) do not give the same
result. This function uses a second-order multiple recursive generator
described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6.

@smallformat
@verbatim
random_gauss(x1, x2, [s])  
@end verbatim
@end smallformat

@node round
@subsection @code{round}
@anchor{#round}
Rounds the argument@ @math{x} to the nearest integer. Halfway cases are
rounded away from zero.

@smallformat
@verbatim
round(x)  
@end verbatim
@end smallformat

@math{\begin{cases} \lceil x \rceil & \text{if $\lceil x \rceil - x < 0.5$} \\ \lceil x \rceil & \text{if $\lceil x \rceil - x = 0.5 \wedge x > 0$} \\ \lfloor x \rfloor & \text{if $x-\lfloor x \rfloor < 0.5$} \\ \lfloor x \rfloor & \text{if $x-\lfloor x \rfloor = 0.5 \wedge x < 0$} \end{cases}}
@image{figures/round,,,round,svg}@ 

@node sawtooth_wave
@subsection @code{sawtooth_wave}
@anchor{#sawtooth_wave}
Computes a sawtooth wave between zero and one with a period equal to
one. As with the sine wave, a sawtooh wave can be generated by passing
as the argument@ @math{x} a linear function of time such
as@ @math{\omega t+\phi}, where@ @math{\omega} controls the frequency of
the wave and @math{\phi} controls its phase.

@smallformat
@verbatim
sawtooth_wave(x)  
@end verbatim
@end smallformat

@math{x - \lfloor x \rfloor}
@image{figures/sawtooth_wave,,,sawtooth_wave,svg}@ 

@menu
* Example #1 sawtooth_wavefee::
@end menu

@node Example #1 sawtooth_wavefee
@subsubsection Example #1, sawtooth_wave.fee
@anchor{#example-1-sawtooth_wave.fee}

@smallformat
@verbatim
end_time = 10
dt = 1e-2

r = 2*sawtooth_wave(0.2*t + 0.5) - 1
y = lag(r, 0.5)

PRINT t r y
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox sawtooth_wave.fee > sawtooth_wave.dat
$
@end verbatim
@end smallformat

@image{examples/sawtooth_wave,,,sawtooth_wave.fee,svg}@ 

@node sgn
@subsection @code{sgn}
@anchor{#sgn}
Returns minus one, zero or plus one depending on the sign of the first
argument@ @math{x}. The second optional argument @math{\epsilon} gives
the precision of the ``zero'' evaluation. If not given, default is
@math{\epsilon = 10^{-9}}.

@smallformat
@verbatim
sgn(x, [eps])  
@end verbatim
@end smallformat

@math{ \begin{cases}-1 &\text{if $x \le -\epsilon$} \\ 0 &\text{if $|x| < \epsilon$} \\ +1 &\text{if $x \ge +\epsilon$} \end{cases}}
@image{figures/sgn,,,sgn,svg}@ 

@node sin
@subsection @code{sin}
@anchor{#sin}
Computes the sine of the argument@ @math{x}, where@ @math{x} is in
radians. A sine wave can be generated by passing as the
argument@ @math{x} a linear function of time such
as@ @math{\omega t+\phi}, where@ @math{\omega} controls the frequency of
the wave and@ @math{\phi} controls its phase.

@smallformat
@verbatim
sin(x)  
@end verbatim
@end smallformat

@math{\sin(x)}
@image{figures/sin,,,sin,svg}@ 

@menu
* Example #1 sinfee::
@end menu

@node Example #1 sinfee
@subsubsection Example #1, sin.fee
@anchor{#example-1-sin.fee}

@smallformat
@verbatim
PRINT sin(1)
PRINT sqrt(1-cos(1)^2)
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox sin.fee
0.841471
0.841471
$
@end verbatim
@end smallformat

@node sinh
@subsection @code{sinh}
@anchor{#sinh}
Computes the hyperbolic sine of the argument@ @math{x}, where@ @math{x}
is in radians.

@smallformat
@verbatim
sinh(x)  
@end verbatim
@end smallformat

@math{\sinh(x)}
@image{figures/sinh,,,sinh,svg}@ 

@node sqrt
@subsection @code{sqrt}
@anchor{#sqrt}
Computes the positive square root of the argument@ @math{x}.
If@ @math{x} is negative, a NaN error is issued.

@smallformat
@verbatim
sqrt(x)  
@end verbatim
@end smallformat

@math{+\sqrt{x}}
@image{figures/sqrt,,,sqrt,svg}@ 

@node square_wave
@subsection @code{square_wave}
@anchor{#square_wave}
Computes a square function between zero and one with a period equal to
one. The output is one for @math{0 < x < 1/2} and zero for
@math{1/2 \leq x < 1}. As with the sine wave, a square wave can be
generated by passing as the argument@ @math{x} a linear function of time
such as@ @math{\omega t+\phi}, where@ @math{\omega} controls the
frequency of the wave and@ @math{\phi} controls its phase.

@smallformat
@verbatim
square_wave(x)  
@end verbatim
@end smallformat

@math{\begin{cases} 1 & \text{if $x - \lfloor x \rfloor < 0.5$} \\ 0 & \text{otherwise} \end{cases}}
@image{figures/square_wave,,,square_wave,svg}@ 

@menu
* Example #1 square_wavefee::
@end menu

@node Example #1 square_wavefee
@subsubsection Example #1, square_wave.fee
@anchor{#example-1-square_wave.fee}

@smallformat
@verbatim
end_time = 10
dt = 1e-2

r = 2*square_wave(0.2*t - 0.1) - 1
y = lag(r, 0.5)

PRINT t r y
@end verbatim
@end smallformat

@smallformat
@verbatim
$ feenox square_wave.fee > square_wave.dat
$
@end verbatim
@end smallformat

@image{examples/square_wave,,,square_wave.fee,svg}@ 

@node tan
@subsection @code{tan}
@anchor{#tan}
Computes the tangent of the argument@ @math{x}, where@ @math{x} is in
radians.

@smallformat
@verbatim
tan(x)  
@end verbatim
@end smallformat

@math{ \tan(x)}
@image{figures/tan,,,tan,svg}@ 

@node tanh
@subsection @code{tanh}
@anchor{#tanh}
Computes the hyperbolic tangent of the argument@ @math{x},
where@ @math{x} is in radians.

@smallformat
@verbatim
tanh(x)  
@end verbatim
@end smallformat

@math{\tanh(x)}
@image{figures/tanh,,,tanh,svg}@ 

@node threshold_max
@subsection @code{threshold_max}
@anchor{#threshold_max}
Returns one if the first argument@ @math{x} is greater than the
threshold given by the second argument @math{a}, and @tex
\textit{exactly}
@end tex zero otherwise. If the optional third argument @math{b} is
provided, an hysteresis of width @math{b} is needed in order to reset
the function value. Default is no hysteresis, i.e.@ @math{b=0}.

@smallformat
@verbatim
threshold_max(x, a, [b])  
@end verbatim
@end smallformat

@math{\begin{cases} 1 & \text{if $x > a$} \\ 0 & \text{if $x < a-b$} \\ \text{last value of $y$} & \text{otherwise} \end{cases}}

@node threshold_min
@subsection @code{threshold_min}
@anchor{#threshold_min}
Returns one if the first argument@ @math{x} is less than the threshold
given by the second argument @math{a}, and @tex
\textit{exactly}
@end tex zero otherwise. If the optional third argument @math{b} is
provided, an hysteresis of width @math{b} is needed in order to reset
the function value. Default is no hysteresis, i.e.@ @math{b=0}.

@smallformat
@verbatim
threshold_min(x, a, [b])  
@end verbatim
@end smallformat

@math{\begin{cases} 1 & \text{if $x < a$} \\ 0 & \text{if $x > a+b$} \\ \text{last value of $y$} & \text{otherwise} \end{cases}}

@node triangular_wave
@subsection @code{triangular_wave}
@anchor{#triangular_wave}
Computes a triangular wave between zero and one with a period equal to
one. As with the sine wave, a triangular wave can be generated by
passing as the argument@ @math{x} a linear function of time such
as@ @math{\omega t+\phi}, where@ @math{\omega} controls the frequency of
the wave and@ @math{\phi} controls its phase.

@smallformat
@verbatim
triangular_wave(x)  
@end verbatim
@end smallformat

@math{\begin{cases} 2 (x - \lfloor x \rfloor) & \text{if $x - \lfloor x \rfloor < 0.5$} \\ 2 [1-(x - \lfloor x \rfloor)] & \text{otherwise} \end{cases}}
@image{figures/triangular_wave,,,triangular_wave,svg}@ 

@node wall_time
@subsection @code{wall_time}
@anchor{#wall_time}
Returns the time ellapsed since the invocation of FeenoX, in seconds.

@smallformat
@verbatim
wall_time()  
@end verbatim
@end smallformat

@node Functionals
@section Functionals
@anchor{#functionals}

@menu
* derivative::
@end menu

@node derivative
@subsection @code{derivative}
@anchor{#derivative}
Computes the derivative of the expression @math{f(x)} given in the first
argument with respect to the variable @math{x} given in the second
argument at the point @math{x=a} given in the third argument using an
adaptive scheme. The fourth optional argument @math{h} is the initial
width of the range the adaptive derivation method starts with. The fifth
optional argument @math{p} is a flag that indicates whether a backward
(@math{p < 0}), centered (@math{p = 0}) or forward (@math{p > 0})
stencil is to be used. This functional calls the GSL functions
@code{gsl_deriv_backward}, @code{gsl_deriv_central} or
@code{gsl_deriv_forward} according to the indicated flag @math{p}.
Defaults are @math{h = (1/2)^{-10} \approx 9.8 \times 10^{-4}} and
@math{p = 0}.

@smallformat
@verbatim
derivative(f(x), x, a, [h], [p])  
@end verbatim
@end smallformat

@math{\left. \frac{d}{dx} \Big[ f(x) \Big] \right|_{x = a} }

@node Vector functions
@section Vector functions
@anchor{#vector-functions}

@menu
* derivative::
@end menu

@node derivative
@subsection @code{derivative}
@anchor{#derivative}
Computes the derivative of the expression @math{f(x)} given in the first
argument with respect to the variable @math{x} given in the second
argument at the point @math{x=a} given in the third argument using an
adaptive scheme. The fourth optional argument @math{h} is the initial
width of the range the adaptive derivation method starts with. The fifth
optional argument @math{p} is a flag that indicates whether a backward
(@math{p < 0}), centered (@math{p = 0}) or forward (@math{p > 0})
stencil is to be used. This functional calls the GSL functions
@code{gsl_deriv_backward}, @code{gsl_deriv_central} or
@code{gsl_deriv_forward} according to the indicated flag @math{p}.
Defaults are @math{h = (1/2)^{-10} \approx 9.8 \times 10^{-4}} and
@math{p = 0}.

@smallformat
@verbatim
derivative(f(x), x, a, [h], [p])  
@end verbatim
@end smallformat

@math{\left. \frac{d}{dx} \Big[ f(x) \Big] \right|_{x = a} }
@tex
\appendix
@end tex

@node FeenoX & the UNIX Philospohy
@chapter FeenoX & the UNIX Philospohy
@anchor{#feenox-the-unix-philospohy}

@node Rule of Modularity
@subsection Rule of Modularity
@anchor{#rule-of-modularity}
@quotation
Developers should build a program out of simple parts connected by well
defined interfaces, so problems are local, and parts of the program can
be replaced in future versions to support new features. This rule aims
to save time on debugging code that is complex, long, and unreadable.
@end quotation
@itemize
@item
FeenoX uses third-party high-quality libraries
@itemize
@item
GNU Scientific Library
@item
SUNDIALS
@item
PETSc
@item
SLEPc
@end itemize

@end itemize

@node Rule of Clarity
@subsection Rule of Clarity
@anchor{#rule-of-clarity}
@quotation
Developers should write programs as if the most important communication
is to the developer who will read and maintain the program, rather than
the computer. This rule aims to make code as readable and comprehensible
as possible for whoever works on the code in the future.
@end quotation
@itemize
@item
Example two squares in thermal contact.
@item
LE10 & LE11: a one-to-one correspondence between the problem text and
the FeenoX input.
@end itemize

@node Rule of Composition
@subsection Rule of Composition
@anchor{#rule-of-composition}
@quotation
Developers should write programs that can communicate easily with other
programs. This rule aims to allow developers to break down projects into
small, simple programs rather than overly complex monolithic programs.
@end quotation
@itemize
@item
FeenoX uses meshes created by a separate mesher (i.e.@ Gmsh).
@item
FeenoX writes data that has to be plotted or post-processed by other
tools (Gnuplot, Gmsh, Paraview, etc.).
@item
ASCII output is 100% controlled by the user so it can be tailored to
suit any other programs' input needs such as AWK filters to create @tex
\LaTeX 
@end textables.
@end itemize

@node Rule of Separation
@subsection Rule of Separation
@anchor{#rule-of-separation}
@quotation
Developers should separate the mechanisms of the programs from the
policies of the programs; one method is to divide a program into a
front-end interface and a back-end engine with which that interface
communicates. This rule aims to prevent bug introduction by allowing
policies to be changed with minimum likelihood of destabilizing
operational mechanisms.
@end quotation
@itemize
@item
FeenoX does not include a GUI, but it is GUI-friendly.
@end itemize

@node Rule of Simplicity
@subsection Rule of Simplicity
@anchor{#rule-of-simplicity}
@quotation
Developers should design for simplicity by looking for ways to break up
program systems into small, straightforward cooperating pieces. This
rule aims to discourage developers' affection for writing ``intricate
and beautiful complexities'' that are in reality bug prone programs.
@end quotation
@itemize
@item
Simple problems need simple input.
@item
Similar problems need similar inputs.
@item
English-like self-evident input files matching as close as possible the
problem text.
@item
If there is a single material there is no need to link volumes to
properties.
@end itemize

@node Rule of Parsimony
@subsection Rule of Parsimony
@anchor{#rule-of-parsimony}
@quotation
Developers should avoid writing big programs. This rule aims to prevent
overinvestment of development time in failed or suboptimal approaches
caused by the owners of the program's reluctance to throw away visibly
large pieces of work. Smaller programs are not only easier to write,
optimize, and maintain; they are easier to delete when deprecated.
@end quotation
@itemize
@item
Parametric and/or optimization runs have to be driven from an outer
script (Bash, Python, etc.)
@end itemize

@node Rule of Transparency
@subsection Rule of Transparency
@anchor{#rule-of-transparency}
@quotation
Developers should design for visibility and discoverability by writing
in a way that their thought process can lucidly be seen by future
developers working on the project and using input and output formats
that make it easy to identify valid input and correct output. This rule
aims to reduce debugging time and extend the lifespan of programs.
@end quotation
@itemize
@item
Written in C99
@end itemize

@node Rule of Robustness
@subsection Rule of Robustness
@anchor{#rule-of-robustness}
@quotation
Developers should design robust programs by designing for transparency
and discoverability, because code that is easy to understand is easier
to stress test for unexpected conditions that may not be foreseeable in
complex programs. This rule aims to help developers build robust,
reliable products.
@end quotation

@node Rule of Representation
@subsection Rule of Representation
@anchor{#rule-of-representation}
@quotation
Developers should choose to make data more complicated rather than the
procedural logic of the program when faced with the choice, because it
is easier for humans to understand complex data compared with complex
logic. This rule aims to make programs more readable for any developer
working on the project, which allows the program to be maintained.
@end quotation

@node Rule of Least Surprise
@subsection Rule of Least Surprise
@anchor{#rule-of-least-surprise}
@quotation
Developers should design programs that build on top of the potential
users' expected knowledge; for example, `+' in a calculator program
should always mean `addition'. This rule aims to encourage developers to
build intuitive products that are easy to use.
@end quotation
@itemize
@item
If one needs a problem where the conductivity depends on@ @math{x} as
@math{k(x)=1+x} then the input is

@smallformat
@verbatim
k(x) = 1+x
@end verbatim
@end smallformat

@item
If a problem needs a temperature distribution given by an algebraic
expression @math{T(x,y,z)=\sqrt{x^2+y^2}+z} then do

@smallformat
@verbatim
T(x,y,z) = sqrt(x^2+y^2) + z
@end verbatim
@end smallformat

@end itemize

@node Rule of Silence
@subsection Rule of Silence
@anchor{#rule-of-silence}
@quotation
Developers should design programs so that they do not print unnecessary
output. This rule aims to allow other programs and developers to pick
out the information they need from a program's output without having to
parse verbosity.
@end quotation
@itemize
@item
No @code{PRINT} no output.
@end itemize

@node Rule of Repair
@subsection Rule of Repair
@anchor{#rule-of-repair}
@quotation
Developers should design programs that fail in a manner that is easy to
localize and diagnose or in other words ``fail noisily''. This rule aims
to prevent incorrect output from a program from becoming an input and
corrupting the output of other code undetected.
@end quotation
Input errors are detected before the computation is started and run-time
errors (i.e.@ a division by zero) con be user controled, they can be
fatal or ignored.

@node Rule of Economy
@subsection Rule of Economy
@anchor{#rule-of-economy}
@quotation
Developers should value developer time over machine time, because
machine cycles today are relatively inexpensive compared to prices in
the 1970s. This rule aims to reduce development costs of projects.
@end quotation
@itemize
@item
Output is 100% user-defined so the desired results is directly obtained
instead of needing further digging into tons of undesired data.The
approach of ``compute and write everything you can in one single run''
made sense in 1970 where CPU time was more expensive than human time,
but not anymore.
@item
Example: LE10 & LE11.
@end itemize

@node Rule of Generation
@subsection Rule of Generation
@anchor{#rule-of-generation}
@quotation
Developers should avoid writing code by hand and instead write abstract
high-level programs that generate code. This rule aims to reduce human
errors and save time.
@end quotation
@itemize
@item
Inputs are M4-friendly.
@item
Parametric runs can be done from scripts through command line arguments
expansion.
@item
Documentation is created out of simple Markdown sources and assembled as
needed.
@end itemize

@node Rule of Optimization
@subsection Rule of Optimization
@anchor{#rule-of-optimization}
@quotation
Developers should prototype software before polishing it. This rule aims
to prevent developers from spending too much time for marginal gains.
@end quotation
@itemize
@item
Premature optimization is the root of all evil
@item
We are still building. We will optimize later.
@itemize
@item
Code optimization: TODO
@item
Parallelization: TODO
@item
Comparison with other tools: TODO
@end itemize

@end itemize

@node Rule of Diversity
@subsection Rule of Diversity
@anchor{#rule-of-diversity}
@quotation
Developers should design their programs to be flexible and open. This
rule aims to make programs flexible, allowing them to be used in ways
other than those their developers intended.
@end quotation
@itemize
@item
Either Gmsh or Paraview can be used to post-process results.
@item
Other formats can be added.
@end itemize

@node Rule of Extensibility
@subsection Rule of Extensibility
@anchor{#rule-of-extensibility}
@quotation
Developers should design for the future by making their protocols
extensible, allowing for easy plugins without modification to the
program's architecture by other developers, noting the version of the
program, and more. This rule aims to extend the lifespan and enhance the
utility of the code the developer writes.
@end quotation
@itemize
@item
FeenoX is GPLv3+. The `+' is for the future.
@item
Each PDE has a separate source directory. Any of them can be used as a
template for new PDEs, especially @code{laplace} for elliptic operators.
@end itemize

@node History
@chapter History
@anchor{#history}
Very much like UNIX in the late 1960s,
@uref{https://www.seamplex.com/feenox,FeenoX} is a third-system effect:
I wrote a first hack that seemed to work better than I had expected.
Then I tried to add a lot of features and complexities which I felt the
code needed. After ten years of actual usage, I then realized what was
worth keeping, what needed to be rewritten and what had to be discarded.
The first version was called wasora, the second was ``The wasora suite''
(i.e.@ a generic framework plus a bunch of ``plugins'', including a
thermo-mechanical one named Fino) and then finally FeenoX. The story
that follows explains why I wrote the first hack to begin with.

It was at the movies when I first heard about dynamical systems,
non-linear equations and chaos theory. The year was@ 1993, I was ten
years old and the movie was Jurassic Park.
@uref{https://en.wikipedia.org/wiki/Ian_Malcolm_(character),Dr.@ Ian
Malcolm} (the character portrayed by
@uref{https://en.wikipedia.org/wiki/Jeff_Goldblum,Jeff Goldblum})
explained sensitivity to initial conditions in a
@uref{https://www.youtube.com/watch?v=n-mpifTiPV4,memorable scene},
which is worth watching again and again. Since then, the fact that tiny
variations may lead to unexpected results has always fascinated me.
During high school I attended a very interesting course on fractals and
chaos that made me think further about complexity and its mathematical
description. Nevertheless, it was not not until college that I was able
to really model and solve the differential equations that give rise to
chaotic behavior.

In fact, initial-value ordinary differential equations arise in a great
variety of subjects in science and engineering. Classical mechanics,
chemical kinetics, structural dynamics, heat transfer analysis and
dynamical systems, among other disciplines, heavily rely on equations of
the form

@math{
\dot{\mathbf{x}} = F(\mathbf{x},t)
}

During my years of undergraduate student (circa 2004--2007), whenever I
had to solve these kind of equations I had to choose one of the
following three options:

@enumerate 
@item
to program an @emph{ad-hoc} numerical method such as
@uref{https://en.wikipedia.org/wiki/Euler_method,Euler} or
@uref{https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods,Runge-Kutta},
matching the requirements of the system of equations to solve, or
@item
to use a standard numerical library such as the
@uref{https://www.gnu.org/software/gsl/,GNU Scientific Library} and code
the equations to solve into a C program (or maybe in Python), or
@item
to use a high-level system such as
@uref{https://www.gnu.org/software/octave/index,Octave},
@uref{https://maxima.sourceforge.io/,Maxima}, or some non-free (and
worse, see below) programs.
@end enumerate

Of course, each option had its pros and its cons. But none provided the
combination of advantages I was looking for, namely flexibility (option
one), efficiency (option two) and reduced input work (partially given by
option three). Back in those days I ended up wandering between options
one and two, depending on the type of problem I had to solve. However,
even though one can, with some effort, make the code read some
parameters from a text file, any other drastic change usually requires a
modification in the source code---some times involving a substantial
amount of work---and a further recompilation of the code. This was what
I most disliked about this way of working, but I could nevertheless live
with it.

Regardless of this situation, during my last year of Nuclear
Engineering, the tipping point came along. Here's a
slightly-fictionalized of a dialog between myself and the teacher at the
computer lab, as it might have happened (or not):

@quotation
--- (Prof.) Open MATLAB.™@*
--- (Me) It's not installed here. I type @code{mathlab} and it does not
work.@*
--- (Prof.) It's spelled @code{matlab}.@*
--- (Me) Ok, working. (A screen with blocks and lines connecting them
appears)@*
--- (Me) What's this?@*
--- (Prof.) The point reactor equations.@*
--- (Me) It's not. These are the point reactor equations:

@math{
\begin{cases}
\dot{\phi}(t) = \displaystyle \frac{\rho(t) - \beta}{\Lambda} \cdot \phi(t) + \sum_{i=1}^{N} \lambda_i \cdot c_i \\
\dot{c}_i(t)  = \displaystyle \frac{\beta_i}{\Lambda} \cdot \phi(t) - \lambda_i \cdot c_i
\end{cases}
}

--- (Me) And in any case, I'd write them like this in a computer:

@smallformat
@verbatim
phi_dot = (rho-Beta)/Lambda * phi + sum(lambda[i], c[i], i, 1, N)
c_dot[i] = beta[i]/Lambda * phi - lambda[i]*c[i]
@end verbatim
@end smallformat

@end quotation
This conversation forced me to re-think the ODE-solving issue. I could
not (and still cannot) understand why somebody would prefer to solve a
very simple set of differential equations by drawing blocks and
connecting them with a mouse with no mathematical sense whatsoever. Fast
forward fifteen years, and what I wrote above is essentially how one
would solve the point kinetics equations with FeenoX.

@bye
